<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' blob: data: file:; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src * blob: data: file:; frame-src * blob: data: file:; connect-src * blob: data:; media-src * blob: mediastream:;">
    <title>AI Cafe Presenter</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#x2615;</text></svg>">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        /* Prevent accidental text selection on presenter UI â€” iframe content unaffected */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            height: 100vh;
            display: flex;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }
        /* Allow text selection where needed */
        .content-frame, input, textarea, [contenteditable], #emptyState {
            user-select: text;
            -webkit-user-select: text;
        }
        
        /* Content Panel */
        .content-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0f0f1a;
            min-width: 200px;
            outline: none; /* Hide focus outline */
            position: relative; /* For draw overlay positioning */
            --toolbar-height: 44px;
        }
        
        /* URL Bar */
        .url-bar {
            display: flex;
            align-items: flex-start;
            flex-wrap: wrap;
            row-gap: 6px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.4);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }
        
        /* Toolbar Modes */
        .toolbar-mode {
            display: flex;
            align-items: flex-start;
            flex-wrap: wrap;
            row-gap: 6px;
            column-gap: 10px;
            gap: 8px;
            width: 100%;
        }
        /* .toolbar-mode.hidden no longer needed - single unified toolbar */
        
        /* Button Group for source buttons */
        .btn-group {
            display: flex;
            gap: 2px;
        }
        .btn-group .nav-btn {
            border-radius: 0;
        }
        .btn-group .nav-btn:first-child {
            border-radius: 6px 0 0 6px;
        }
        .btn-group .nav-btn:last-child {
            border-radius: 0 6px 6px 0;
        }
        
        /* Dropdown Menu */
        .dropdown-container {
            position: relative;
        }
        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: rgba(30, 30, 50, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            overflow: hidden;
            z-index: 1000;
            min-width: 160px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        .dropdown-menu.show {
            display: block;
        }
        .dropdown-menu button {
            display: block;
            width: 100%;
            padding: 10px 14px;
            background: transparent;
            border: none;
            color: #e0e0e0;
            text-align: left;
            cursor: pointer;
            font-size: 13px;
        }
        .dropdown-menu button:hover {
            background: rgba(0, 217, 255, 0.15);
        }
        
        /* Unified Mode Buttons (Capture, PPT, Browser) */
        .mode-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            border-radius: 6px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            font-size: 12px;
            font-weight: 600;
            color: #ccc;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
            box-shadow: none;
        }
        .mode-btn:hover {
            background: rgba(76, 175, 80, 0.2);
            border-color: #4caf50;
            color: #69f0ae;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.3);
        }
        .mode-btn .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.2s;
        }
        /* Active state (this mode is currently in foreground) */
        .mode-btn.active {
            border-color: #4caf50;
            background: rgba(76, 175, 80, 0.2);
            color: #69f0ae;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.3);
        }
        .mode-btn.active:hover {
            background: rgba(76, 175, 80, 0.35);
            box-shadow: 0 0 12px rgba(76, 175, 80, 0.5);
        }
        .mode-btn.active .status-dot {
            background: #4caf50;
            box-shadow: 0 0 8px #4caf50;
        }
        /* Background state (running but not the current view) */
        .mode-btn.background {
            border-color: rgba(76, 175, 80, 0.4);
            background: rgba(76, 175, 80, 0.08);
            color: rgba(105, 240, 174, 0.5);
            box-shadow: none;
        }
        .mode-btn.background:hover {
            background: rgba(76, 175, 80, 0.2);
            color: #69f0ae;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.3);
        }
        .mode-btn.background .status-dot {
            background: rgba(76, 175, 80, 0.5);
            box-shadow: 0 0 4px rgba(76, 175, 80, 0.3);
        }
        
        /* Zoom Button - same size as PPT Control */
        .zoom-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 600;
            background: rgba(0, 217, 255, 0.15);
            border: 2px solid rgba(0, 217, 255, 0.4);
            border-radius: 6px;
            color: #00d9ff;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .zoom-btn:hover {
            background: rgba(0, 217, 255, 0.25);
            border-color: rgba(0, 217, 255, 0.6);
        }
        
        /* Toolbar Groups with Dividers */
        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 0 0 auto;
            flex-wrap: nowrap;
            min-width: 0;
        }
        .toolbar-divider {
            display: none;
        }
        #drawGroup::before,
        #pptGroup::before,
        #fullscreenGroup::before,
        .browse-controls::before {
            content: '';
            width: 2px;
            height: 28px;
            background: rgba(255, 255, 255, 0.35);
            border-radius: 1px;
            box-shadow: 0 0 4px rgba(255, 255, 255, 0.1);
            margin: 0 10px 0 2px;
            flex: 0 0 auto;
        }

        /* Browser controls group */
        .browse-controls {
            flex: 1 1 480px;
            min-width: 0;
        }
        .browse-controls .url-input {
            flex: 1;
            min-width: 120px;
        }

        /* Tab Panel - floating right-aligned */
        .tab-panel {
            display: none;
            position: absolute;
            top: calc(var(--toolbar-height, 44px) + 4px);
            right: 8px;
            z-index: 35;
            background: rgba(20, 20, 35, 0.98);
            border: 1px solid rgba(0, 217, 255, 0.25);
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 12px rgba(0, 217, 255, 0.1);
            min-width: 300px;
            max-width: 400px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }
        .tab-panel.visible {
            display: block;
        }
        .tab-panel::-webkit-scrollbar {
            width: 6px;
        }
        .tab-panel::-webkit-scrollbar-track {
            background: transparent;
        }
        .tab-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 217, 255, 0.2);
            border-radius: 3px;
        }
        .tab-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }
        .tab-panel-title {
            color: #00d9ff;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .tab-panel-close {
            background: none;
            border: none;
            color: #888;
            font-size: 18px;
            cursor: pointer;
            padding: 0 4px;
            line-height: 1;
        }
        .tab-panel-close:hover {
            color: #fff;
        }
        .tab-list {
            padding: 4px 0;
        }
        .tab-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: grab;
            border-left: 3px solid transparent;
            transition: background 0.15s, border-color 0.15s;
            gap: 8px;
            position: relative;
        }
        .tab-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        .tab-item.active {
            border-left-color: #00d9ff;
            background: rgba(0, 217, 255, 0.08);
        }
        .tab-item.dragging {
            opacity: 0.3;
            cursor: grabbing;
        }
        .tab-item.drag-above::before {
            content: '';
            position: absolute;
            top: -1px;
            left: 8px;
            right: 8px;
            height: 2px;
            background: #00d9ff;
            border-radius: 1px;
            box-shadow: 0 0 6px rgba(0, 217, 255, 0.5);
        }
        .tab-item.drag-below::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 8px;
            right: 8px;
            height: 2px;
            background: #00d9ff;
            border-radius: 1px;
            box-shadow: 0 0 6px rgba(0, 217, 255, 0.5);
        }
        .tab-item-icon {
            font-size: 14px;
            flex-shrink: 0;
        }
        .tab-item-title {
            flex: 1;
            min-width: 0;
            font-size: 13px;
            color: #ccc;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .tab-item.active .tab-item-title {
            color: #fff;
        }
        .tab-delete {
            background: none;
            border: none;
            color: #666;
            font-size: 14px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 22px;
            height: 22px;
            padding: 0;
            line-height: 1;
            opacity: 0;
            transition: all 0.15s;
        }
        .tab-item:hover .tab-delete {
            opacity: 1;
        }
        .tab-delete:hover {
            color: #ff5555;
        }
        .tab-panel-footer {
            padding: 8px 12px 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.06);
        }
        .tab-add-btn {
            width: 100%;
            padding: 6px;
            background: transparent;
            border: 1px dashed rgba(0, 217, 255, 0.3);
            border-radius: 4px;
            color: #00d9ff;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .tab-add-btn:hover {
            background: rgba(0, 217, 255, 0.1);
            border-color: rgba(0, 217, 255, 0.5);
        }
        .tab-add-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .tab-export-import-row {
            display: flex;
            gap: 6px;
            margin-top: 6px;
        }
        .tab-export-btn, .tab-import-btn {
            flex: 1;
            padding: 5px 6px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            color: #aab;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .tab-export-btn:hover {
            background: rgba(0, 217, 255, 0.08);
            border-color: rgba(0, 217, 255, 0.4);
            color: #00d9ff;
        }
        .tab-import-btn:hover {
            background: rgba(80, 255, 120, 0.08);
            border-color: rgba(80, 255, 120, 0.4);
            color: #50ff78;
        }
        #tabPanelToggle.active {
            background: rgba(0, 217, 255, 0.15);
            border-color: #00d9ff;
            color: #00d9ff;
            box-shadow: 0 0 8px rgba(0, 217, 255, 0.3);
        }

        /* Disabled capture controls */
        .zoom-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        /* Disabled toolbar group - greyscale and non-interactive */
        .toolbar-group.group-disabled {
            opacity: 0.45;
            pointer-events: none;
            filter: grayscale(1);
        }
        /* Draw group in present mode: draw button stays clickable */
        #drawGroup.group-draw-disabled > *:not(.draw-tool-container) {
            opacity: 0.45;
            pointer-events: none;
            filter: grayscale(1);
        }
        #drawGroup.group-draw-disabled .draw-tool-container > *:not(#drawToggle) {
            opacity: 0.45;
            pointer-events: none;
            filter: grayscale(1);
        }
        
        /* PPT Nav buttons (Prev/Next) */
        .nav-btn.ppt-nav {
            padding: 6px 14px;
        }
        .nav-btn.ppt-nav:disabled,
        .nav-btn.ppt-start:disabled,
        .nav-btn.ppt-stop:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            pointer-events: none;
        }

        /* PPT Start Button (F5) - green */
        .nav-btn.ppt-start {
            background: rgba(76, 175, 80, 0.15);
            border-color: rgba(76, 175, 80, 0.4);
            color: #69f0ae;
        }
        .nav-btn.ppt-start:hover {
            background: rgba(76, 175, 80, 0.25);
            border-color: rgba(76, 175, 80, 0.6);
        }
        /* F5 active: slideshow is running */
        .nav-btn.ppt-start.slideshow-active {
            background: rgba(76, 175, 80, 0.35);
            border-color: #4caf50;
            color: #69f0ae;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.4);
        }

        /* PPT Stop Button (ESC) - orange */
        .nav-btn.ppt-stop {
            background: rgba(255, 152, 0, 0.15);
            border-color: rgba(255, 152, 0, 0.4);
            color: #ffb74d;
        }
        .nav-btn.ppt-stop:hover {
            background: rgba(255, 152, 0, 0.25);
            border-color: rgba(255, 152, 0, 0.6);
        }
        /* ESC active: slideshow is running (can be stopped) */
        .nav-btn.ppt-stop.slideshow-active {
            background: rgba(255, 152, 0, 0.35);
            border-color: #ff9800;
            color: #ffb74d;
            box-shadow: 0 0 8px rgba(255, 152, 0, 0.4);
        }
        
        .url-input {
            flex: 1;
            min-width: 150px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            color: #e8e8e8;
            font-size: 12px;
        }
        .url-input:focus {
            outline: none;
            border-color: #00d9ff;
            background: rgba(255, 255, 255, 0.12);
        }
        
        .nav-btn {
            padding: 6px 12px;
            background: rgba(0, 217, 255, 0.15);
            border: 2px solid rgba(0, 217, 255, 0.4);
            border-radius: 6px;
            color: #00d9ff;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .nav-btn:hover {
            background: rgba(0, 217, 255, 0.25);
            border-color: rgba(0, 217, 255, 0.6);
        }
        .nav-btn.secondary {
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: #ccc;
        }
        .nav-btn.secondary:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.35);
            color: #fff;
        }
        .nav-btn.back-btn {
            background: rgba(255, 152, 0, 0.15);
            border-color: rgba(255, 152, 0, 0.4);
            color: #ffb74d;
            padding: 6px 14px;
            font-size: 16px;
        }
        .nav-btn.back-btn:hover {
            background: rgba(255, 152, 0, 0.25);
            border-color: rgba(255, 152, 0, 0.6);
        }
        
        /* Content iframe */
        .content-frame {
            flex: 1;
            border: none;
            background: #000;
        }

        /* Black transition overlay for iframe page switches */
        .page-switch-overlay {
            position: absolute;
            left: 0;
            right: 0;
            top: var(--toolbar-height, 44px);
            bottom: 0;
            background: #000;
            opacity: 0;
            pointer-events: none;
            z-index: 22;
            transition: opacity 120ms linear;
            will-change: opacity;
        }
        .page-switch-overlay.active {
            opacity: 1;
        }

        /* PPT Slide Container */
        .ppt-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #1a1a2e;
            position: relative;
            overflow: hidden;
        }
        .ppt-slide-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        .ppt-slide-counter {
            position: absolute;
            bottom: 12px;
            right: 16px;
            background: rgba(0, 0, 0, 0.6);
            color: #69f0ae;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }
        
        /* Empty state */
        .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #a0a0a0;
            text-align: center;
            padding: 40px;
        }
        .empty-state .icon { font-size: 64px; margin-bottom: 20px; }
        .empty-state h2 { color: #e8e8e8; margin-bottom: 10px; }
        .empty-state p { max-width: 400px; line-height: 1.6; font-size: 14px; }
        .empty-state code { 
            background: rgba(0, 217, 255, 0.1); 
            padding: 2px 6px; 
            border-radius: 4px; 
            font-size: 12px;
            color: #00d9ff;
        }
        
        /* Error overlay for blocked iframes */
        .iframe-error {
            flex: 1;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #ff6b6b;
            text-align: center;
            padding: 40px;
            background: linear-gradient(135deg, #1a0a0a 0%, #2a1515 50%, #1a0a0a 100%);
        }
        .iframe-error .icon { font-size: 64px; margin-bottom: 20px; }
        .iframe-error h2 { 
            color: #ff8888; 
            margin-bottom: 15px; 
            font-size: 1.5rem;
        }
        .iframe-error .error-url {
            background: rgba(255, 100, 100, 0.15);
            padding: 8px 16px;
            border-radius: 6px;
            margin: 15px 0;
            color: #ffaaaa;
            font-family: monospace;
            font-size: 14px;
            word-break: break-all;
            max-width: 90%;
        }
        .iframe-error p { 
            max-width: 550px; 
            line-height: 1.8; 
            font-size: 14px;
            color: #ccaaaa;
        }
        .iframe-error .reason {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px 25px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 4px solid #ff6b6b;
        }
        .iframe-error .reason h3 {
            color: #ffcc66;
            margin-bottom: 10px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .iframe-error .reason p {
            color: #e0d0d0;
            margin: 0;
        }
        .iframe-error .btn-open-tab {
            margin-top: 25px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #00d9ff, #0099cc);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .iframe-error .btn-open-tab:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 217, 255, 0.4);
        }

        /* Info overlay for URLs opened externally in a new tab */
        .external-open-state {
            flex: 1;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #9ad3ff;
            text-align: center;
            padding: 40px;
            background: linear-gradient(135deg, #081a2a 0%, #10243a 50%, #081a2a 100%);
        }
        .external-open-state .icon { font-size: 64px; margin-bottom: 20px; }
        .external-open-state h2 {
            color: #7dd3ff;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }
        .external-open-state .error-url {
            background: rgba(0, 180, 255, 0.14);
            color: #bfe9ff;
            padding: 8px 16px;
            border-radius: 6px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 14px;
            word-break: break-all;
            max-width: 90%;
        }
        .external-open-state p {
            max-width: 600px;
            line-height: 1.7;
            font-size: 14px;
            color: #b5cfe0;
        }
        .external-open-state .btn-open-tab {
            margin-top: 25px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #00d9ff, #0099cc);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .external-open-state .btn-open-tab:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 217, 255, 0.4);
        }
        
        /* Screen Capture Video */
        .screen-video {
            flex: 1;
            width: 100%;
            height: 100%;
            min-height: 0; /* Important for flex shrinking */
            background: #000;
            object-fit: contain; /* Scale to fit while maintaining aspect ratio */
            display: none;
            cursor: pointer;
            /* GPU acceleration for cleaner rendering */
            transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            /* Prevent subpixel blur */
            will-change: contents;
        }
        .screen-video.ppt-control {
            cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'%3E%3Ctext y='24' font-size='24'%3E%F0%9F%91%86%3C/text%3E%3C/svg%3E") 16 16, pointer;
        }
        
        /* Container for screen capture to handle dynamic sizing */
        .screen-container {
            flex: 1;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 0;
            overflow: hidden;
            position: relative;
            /* GPU layer for container too */
            transform: translateZ(0);
            contain: strict;
        }
        .screen-container.active {
            display: flex;
        }
        /* Draw overlay: transparent canvas over browse content (hold-D-to-draw) */
        .screen-container.draw-overlay {
            display: flex !important;
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            background: transparent;
            z-index: 35;
        }
        .screen-container.draw-overlay .screen-video,
        .screen-container.draw-overlay .ppt-click-zones {
            display: none !important;
        }
        /* 100% Zoom mode - native resolution, scrollable from top-center */
        .screen-container.zoom-100 {
            overflow: auto;
            align-items: center;
            justify-content: flex-start;
        }
        .screen-container.zoom-100 .screen-video {
            object-fit: none;
            width: auto;
            height: auto;
            flex: none;
        }
        
        /* Server hint - prominent centered overlay (like empty-state) */
        .server-hint {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #ffcc80;
            text-align: center;
            padding: 40px;
            background: linear-gradient(135deg, #1a1508 0%, #2a1f10 50%, #1a1508 100%);
            z-index: 50;
        }
        .server-hint.show { display: flex; }
        .server-hint .icon { font-size: 64px; margin-bottom: 20px; }
        .server-hint h2 { 
            color: #ff9800; 
            margin-bottom: 15px; 
            font-size: 1.5rem;
        }
        .server-hint p { 
            max-width: 500px; 
            line-height: 1.8; 
            font-size: 14px;
            color: #ccaa80;
        }
        .server-hint .file-link {
            display: block;
            background: rgba(0,0,0,0.4);
            padding: 12px 24px;
            border-radius: 8px;
            margin: 15px 0;
            text-decoration: none;
            border: 2px solid transparent;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .server-hint .file-link:hover {
            background: rgba(255, 152, 0, 0.2);
            border-color: #ff9800;
            transform: scale(1.02);
        }
        .server-hint .file-link .path {
            display: block;
            font-family: Consolas, monospace;
            color: #4fc3f7;
            font-size: 13px;
        }
        .server-hint .file-link .hint {
            display: block;
            font-size: 11px;
            color: #888;
            margin-top: 5px;
            transition: color 0.2s;
        }
        .server-hint .file-link:hover .hint {
            color: #ff9800;
        }
        .server-hint .file-link.copied {
            border-color: #4caf50;
            background: rgba(76, 175, 80, 0.2);
        }
        .server-hint .file-link.copied .hint {
            color: #4caf50;
        }
        .server-hint .steps {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px 30px;
            border-radius: 10px;
            margin-top: 20px;
            text-align: left;
        }
        .server-hint .steps li {
            margin: 8px 0;
            color: #e0d0c0;
        }
        .server-hint .done-btn {
            margin-top: 30px;
            padding: 12px 40px;
            font-size: 16px;
            font-weight: bold;
            color: #000;
            background: #39ff14;
            border: 3px solid #1a8a0a;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 10px #39ff14, 0 0 20px #39ff14, 0 0 30px #39ff14;
            transition: all 0.3s ease;
        }
        .server-hint .done-btn:hover {
            background: #50ff30;
            border-color: #2ab015;
            box-shadow: 0 0 15px #39ff14, 0 0 30px #39ff14, 0 0 45px #39ff14, 0 0 60px #39ff14;
            transform: scale(1.05);
        }
        
        /* === DRAW TOOL STYLES === */
        .draw-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 6px;
            border: 2px solid;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
            transition: all 0.2s;
        }
        .draw-btn.inactive {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
            color: #ccc;
        }
        .draw-btn.active {
            background: rgba(255, 235, 59, 0.25);
            border-color: #ffeb3b;
            color: #ffeb3b;
            box-shadow: 0 0 12px rgba(255, 235, 59, 0.4);
        }
        .draw-btn:hover {
            transform: scale(1.02);
        }
        
        .draw-thickness-btn {
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #ccc;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 28px;
        }
        .draw-thickness-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }
        
        .draw-thickness-display {
            min-width: 35px;
            text-align: center;
            font-size: 11px;
            color: #aaa;
        }
        
        .draw-color-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 8px currentColor;
        }
        .draw-color-btn:hover {
            transform: scale(1.15);
        }
        .draw-color-btn.selected {
            border-color: #fff;
            transform: scale(1.1);
            box-shadow: 0 0 15px currentColor, 0 0 25px currentColor;
        }
        .draw-color-btn.neon-yellow { background: #ffeb3b; color: #ffeb3b; }
        .draw-color-btn.neon-green { background: #39ff14; color: #39ff14; }
        .draw-color-btn.neon-cyan { background: #00ffff; color: #00ffff; }
        .draw-color-btn.neon-pink { background: #ff1493; color: #ff1493; }
        .draw-color-btn.neon-orange { background: #ff6600; color: #ff6600; }
        .draw-color-btn.neon-white { background: #ffffff; color: #ffffff; }
        
        .draw-clear-btn {
            padding: 4px 10px;
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid #f44336;
            border-radius: 4px;
            color: #ff8a80;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .draw-clear-btn:hover {
            background: rgba(244, 67, 54, 0.4);
        }
        
        /* Fade slider */
        .draw-fade-group {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .draw-fade-slider {
            width: 60px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }
        .draw-fade-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #00d9ff;
            border-radius: 50%;
            cursor: pointer;
        }
        .draw-fade-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #00d9ff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        .draw-fade-display {
            min-width: 28px;
            font-size: 10px;
            color: #aaa;
            text-align: center;
        }
        .draw-fade-label {
            font-size: 10px;
            color: #888;
        }
        
        /* Draw tool container with help dropdown */
        .draw-tool-container {
            position: relative;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .shape-override-display {
            font-size: 14px;
            min-width: 32px;
            text-align: center;
            padding: 2px 6px;
            background: rgba(255, 235, 59, 0.15);
            border: 1px solid rgba(255, 235, 59, 0.3);
            border-radius: 4px;
            color: #ffeb3b;
            opacity: 0.5;
            transition: all 0.2s;
        }
        
        .draw-help-btn {
            background: rgba(255, 235, 59, 0.2);
            border: 1px solid rgba(255, 235, 59, 0.5);
            color: #ffeb3b;
            border-radius: 50%;
            width: 22px;
            height: 22px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            margin-left: 6px;
            transition: all 0.2s;
        }
        .draw-help-btn:hover {
            background: rgba(255, 235, 59, 0.4);
            transform: scale(1.1);
        }
        .draw-help-btn.active {
            background: rgba(255, 235, 59, 0.5);
            box-shadow: 0 0 8px rgba(255, 235, 59, 0.6);
        }
        
        .draw-help-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: -200px;
            margin-top: 8px;
            background: rgba(20, 20, 35, 0.98);
            border: 1px solid rgba(255, 235, 59, 0.3);
            border-radius: 8px;
            padding: 12px 16px;
            z-index: 1000;
            min-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
        }
        
        .draw-help-dropdown.visible {
            display: block;
        }
        
        .draw-help-title {
            font-size: 12px;
            font-weight: bold;
            color: #ffeb3b;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .draw-help-tree {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            line-height: 1.6;
            color: #ccc;
        }
        
        .help-item {
            white-space: nowrap;
        }
        
        .help-item.sub {
            color: #999;
            padding-left: 8px;
        }
        
        .help-item kbd {
            display: inline-block;
            padding: 1px 6px;
            margin: 0 2px;
            background: rgba(0, 217, 255, 0.15);
            border: 1px solid rgba(0, 217, 255, 0.4);
            border-radius: 3px;
            color: #00d9ff;
            font-size: 10px;
            font-family: inherit;
        }
        
        /* Drawing Canvas Overlay */
        #drawCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 40;
        }
        #drawCanvas.active {
            pointer-events: auto;
            cursor: none; /* Hide cursor when drawing (red follower replaces it) */
        }
        /* Browse draw overlay: hide cursor (colored follower replaces it) */
        .screen-container.draw-overlay #drawCanvas.active {
            cursor: none;
        }
        /* Browse cursor follower: no pulse, draw-color based */
        #cursorFollower.browse-draw {
            animation: none;
            transform: translate(-50%, -50%) scale(1);
            opacity: 0.9;
        }
        
        /* Red Cursor Follower */
        #cursorFollower {
            position: fixed;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: radial-gradient(circle, #ff3333 0%, #ff0000 50%, rgba(255, 0, 0, 0.6) 100%);
            pointer-events: none;
            z-index: 9999;
            transform: translate(-50%, -50%);
            display: none;
            box-shadow: 
                0 0 10px #ff0000,
                0 0 20px #ff0000,
                0 0 30px rgba(255, 0, 0, 0.5),
                0 0 40px rgba(255, 0, 0, 0.3);
            animation: cursorPulse 1.5s ease-in-out infinite;
        }
        #cursorFollower.active {
            display: block;
        }
        @keyframes cursorPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.9; }
            50% { transform: translate(-50%, -50%) scale(1.15); opacity: 1; }
        }
        
        /* Hide default cursor over screen container when follower is active */
        .screen-container.cursor-hidden,
        .screen-container.cursor-hidden * {
            cursor: none !important;
        }
        
        /* Click zones overlay for PPT control */
        .ppt-click-zones {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            pointer-events: none;
        }
        .ppt-click-zones.active { display: flex; pointer-events: auto; }
        .ppt-zone {
            width: 42%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 48px;
            color: white;
            text-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        .ppt-zone:hover { opacity: 0.7; }
        .ppt-zone.prev { background: linear-gradient(90deg, rgba(0,200,80,0.4), transparent); cursor: w-resize; }
        .ppt-zone.next { background: linear-gradient(-90deg, rgba(0,200,80,0.4), transparent); cursor: e-resize; }
        .ppt-zone.middle {
            width: 16%;
            pointer-events: none;
            cursor: default;
        }
    </style>
</head>
<body>
    <!-- Content -->
    <div class="content-panel" id="contentPanel" tabindex="-1">
        <!-- Unified Toolbar -->
        <div class="url-bar" style="position: relative;">
            <input type="file" id="fileInput" accept=".html,.htm,.pdf,.png,.jpg,.jpeg,.gif,.svg,.webp,.txt" style="display:none;" onchange="openLocalFile(event)">
            
            <!-- Unified Toolbar (always visible) -->
            <div id="mainToolbar" class="toolbar-mode">
                <!-- Group 1: Mode Buttons (Capture, Browse) -->
                <div class="toolbar-group" id="modeGroup">
                    <button class="mode-btn" id="presentBtn" onclick="togglePresent()" title="Click to start screen capture">
                        <span class="status-dot"></span>
                        <span class="status-text">&#x1F4FA; Capture</span>
                    </button>
                    <button class="mode-btn active" id="browseBtn" onclick="toggleBrowse()" title="Browse view (active)">
                        <span class="status-dot"></span>
                        <span class="status-text">&#x1F3E0; Browse</span>
                    </button>
                    <button class="zoom-btn" id="zoomToggle" onclick="toggleCaptureZoom()" title="Switch to 100% zoom (native resolution)" disabled>&#x1F50D; 100%</button>
                </div>

                <div class="toolbar-divider"></div>

                <!-- Group 2: Draw Tool -->
                <div class="toolbar-group group-disabled" id="drawGroup" style="position: relative;">
                    <div class="draw-tool-container">
                        <button class="draw-btn inactive" id="drawToggle" onclick="toggleDrawMode()" title="Toggle Draw Mode (D)">
                            &#x270F;&#xFE0F; Draw
                        </button>
                        <span class="shape-override-display" id="shapeOverrideDisplay" title="Current shape mode (press A/C/T/S/X/L to override)">Auto</span>
                        <button class="draw-help-btn active" id="drawHelpBtn" onclick="toggleDrawHelp()" title="Toggle shortcuts help">?</button>
                        <!-- Help dropdown -->
                        <div class="draw-help-dropdown visible" id="drawHelpDropdown">
                            <div class="draw-help-title">&#x1F3A8; Draw Tool Shortcuts</div>
                            <div class="draw-help-tree">
                                <div class="help-item">&#x1F4C1; <b>Shapes</b> (hold while drawing)</div>
                                <div class="help-item sub">&#x251C;&#x2500; <kbd>A</kbd> Arrow &#x2192; (direction = draw direction)</div>
                                <div class="help-item sub">&#x251C;&#x2500; <kbd>C</kbd> Circle &#x25CB; / Oval</div>
                                <div class="help-item sub">&#x251C;&#x2500; <kbd>T</kbd> Triangle &#x25B3;</div>
                                <div class="help-item sub">&#x251C;&#x2500; <kbd>S</kbd> Square &#x25A1; / Rectangle</div>
                                <div class="help-item sub">&#x251C;&#x2500; <kbd>X</kbd> X mark &#x2715;</div>
                                <div class="help-item sub">&#x2514;&#x2500; <kbd>L</kbd> Line -</div>
                                <div class="help-item" style="margin-top: 6px;">&#x1F4C1; <b>Actions</b></div>
                                <div class="help-item sub">&#x251C;&#x2500; <kbd>D</kbd> Toggle draw mode</div>
                                <div class="help-item sub">&#x251C;&#x2500; <kbd>Esc</kbd> Clear override / Exit</div>
                                <div class="help-item sub">&#x2514;&#x2500; <kbd>Right-click</kbd> + drag = Erase</div>
                            </div>
                        </div>
                    </div>
                    <button class="draw-thickness-btn" onclick="changeDrawThickness(-2)" title="Thinner">&#x2212;</button>
                    <span class="draw-thickness-display" id="thicknessDisplay">8px</span>
                    <button class="draw-thickness-btn" onclick="changeDrawThickness(2)" title="Thicker">+</button>
                    <button class="draw-color-btn neon-yellow selected" onclick="setDrawColor('#ffeb3b')" title="Neon Yellow"></button>
                    <button class="draw-color-btn neon-green" onclick="setDrawColor('#39ff14')" title="Neon Green"></button>
                    <button class="draw-color-btn neon-cyan" onclick="setDrawColor('#00ffff')" title="Neon Cyan"></button>
                    <button class="draw-color-btn neon-pink" onclick="setDrawColor('#ff1493')" title="Neon Pink"></button>
                    <button class="draw-color-btn neon-orange" onclick="setDrawColor('#ff6600')" title="Neon Orange"></button>
                    <button class="draw-color-btn neon-white" onclick="setDrawColor('#ffffff')" title="White"></button>
                    <div class="draw-fade-group" title="Auto-fade time (0 = off)">
                        <span class="draw-fade-label">&#x23F1;&#xFE0F;</span>
                        <input type="range" class="draw-fade-slider" id="fadeSlider" min="0" max="30" value="5" oninput="setDrawFade(this.value)">
                        <span class="draw-fade-display" id="fadeDisplay">5s</span>
                    </div>
                    <button class="draw-clear-btn" onclick="clearDrawing()" title="Clear all drawings">&#x1F5D1;&#xFE0F; Clear</button>
                </div>

                <div class="toolbar-divider"></div>

                <!-- Group 3: PPT Navigation (auto-enabled when PPT server is online) -->
                <div class="toolbar-group" id="pptGroup">
                    <button class="mode-btn" id="pptServerBtn" onclick="togglePptServer()" title="PowerPoint server: offline - click for start instructions">
                        <span class="status-dot"></span>
                        <span class="status-text">&#x1F3AF; PPT</span>
                    </button>
                    <button class="nav-btn ppt-start" id="startBtn" onclick="pptStart()" disabled title="Start SlideShow from slide 1 (F5)">&#x25B6;&#xFE0F; F5</button>
                    <button class="nav-btn ppt-start" id="startCurrentBtn" onclick="pptStartCurrent()" disabled title="Start from current slide (Shift+F5)">&#x25B6;&#xFE0F; &#x21E7;F5</button>
                    <button class="nav-btn secondary ppt-nav" id="prevBtn" onclick="pptPrevious()" disabled title="Previous slide">&#x25C0; Prev</button>
                    <button class="nav-btn secondary ppt-nav" id="nextBtn" onclick="pptNext()" disabled title="Next slide">Next &#x25B6;</button>
                    <button class="nav-btn ppt-stop" id="escBtn" onclick="pptStop()" disabled title="Exit SlideShow (ESC)">&#x23F9;&#xFE0F; ESC</button>
                </div>

                <div class="toolbar-divider"></div>

                <!-- Fullscreen (always visible) -->
                <div class="toolbar-group" id="fullscreenGroup">
                    <button class="nav-btn secondary" onclick="toggleFullscreen()" title="Fullscreen (F)" id="fullscreenBtn">&#x26F6;</button>
                </div>

                <div class="toolbar-divider"></div>

                <!-- Group 4: Browser Controls -->
                <div class="toolbar-group browse-controls">
                    <button class="nav-btn secondary active" id="tabPanelToggle" onclick="toggleTabPanel()" title="Toggle tab panel">&#x1F4D1;</button>
                    <div class="btn-group">
                        <button class="nav-btn secondary" onclick="document.getElementById('fileInput').click()" title="Open local file">&#x1F4C2;</button>
                    </div>
                    <input type="text" class="url-input" id="urlInput" placeholder="URL or path..." onkeydown="if(event.key==='Enter') loadUrl()">
                    <button class="nav-btn" onclick="loadUrl()" title="Load URL or file path">Go</button>
                    <div class="dropdown-container">
                        <button class="nav-btn secondary" onclick="toggleSettingsMenu()" title="Settings">&#x2699;&#xFE0F;</button>
                        <div id="settingsDropdown" class="dropdown-menu">
                            <button onclick="event.stopPropagation(); clearAllTabs()">&#x1F5D1;&#xFE0F; Clear All Tabs</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tab Panel (floating, inside content-panel) -->
        <div id="tabPanel" class="tab-panel visible">
            <div class="tab-panel-header">
                <span class="tab-panel-title">Tabs</span>
                <button class="tab-panel-close" onclick="toggleTabPanel()">&times;</button>
            </div>
            <div id="tabList" class="tab-list"></div>
            <div class="tab-panel-footer">
                <button class="tab-add-btn" id="addTabBtn" onclick="addTab()">+ New Tab</button>
                <div class="tab-export-import-row">
                    <button class="tab-export-btn" onclick="exportTabs()" title="Export all tab links as JSON">&#x1F4E4; Export</button>
                    <button class="tab-import-btn" onclick="document.getElementById('tabImportInput').click()" title="Import tab links from JSON">&#x1F4E5; Import</button>
                    <input type="file" id="tabImportInput" accept=".json" style="display:none" onchange="importTabs(event)">
                </div>
            </div>
        </div>

        <!-- Content area -->
        <div id="emptyState" class="empty-state" tabindex="0" onclick="this.focus()">
            <div class="icon">&#x1F310;</div>
            <h2>Enter URL or Open File</h2>
            <p>Enter a URL above, use &#x1F4C2; to browse, or paste a path:<br><br>
            <code>E:\AI Caf&#233;\presentation.html</code><br><br>
            <code>https://example.com</code></p>
            <p style="margin-top: 20px; font-size: 12px; opacity: 0.6;">Press <strong>F</strong> for fullscreen</p>
        </div>
        
        <iframe id="contentFrame" class="content-frame" allow="clipboard-read *; clipboard-write *; fullscreen *" referrerpolicy="no-referrer-when-downgrade" style="display: none;"></iframe>
        <div id="iframeFocusHint" style="position:absolute; bottom:12px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.75); color:#aaa; padding:5px 16px; border-radius:16px; font-size:11px; pointer-events:none; opacity:0; transition:opacity 0.3s; z-index:50; white-space:nowrap;">Maus rausbewegen f&uuml;r Draw (D)</div>
        <div id="pageSwitchOverlay" class="page-switch-overlay" aria-hidden="true"></div>
        <script>
        // Cache-busting reload for iframe on Ctrl+Shift+R
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.shiftKey && (e.key === 'R' || e.key === 'r')) {
                var frame = document.getElementById('contentFrame');
                if (frame && frame.src && frame.style.display !== 'none') {
                    // Add cache-buster param
                    var url = frame.src;
                    var sep = url.includes('?') ? '&' : '?';
                    showPageSwitchBlack();
                    frame.src = url + sep + 'cb=' + Date.now();
                }
            }
        });
        </script>

        <!-- PPT Slide Container (shows slide images from PPT server) -->
        <div id="pptContainer" class="ppt-container" style="display: none;">
            <img id="pptSlideImage" class="ppt-slide-image" alt="PowerPoint Slide">
            <div id="pptSlideCounter" class="ppt-slide-counter"></div>
            <!-- PPT Server Hint - shown when server is offline -->
            <div id="serverHint" class="server-hint">
                <div class="icon">âš ï¸</div>
                <h2>PowerPoint Server Not Running</h2>
                <p>To control PowerPoint slides, start the controller server first:</p>
                <p style="margin: 10px 0 15px 0; color: #e0d0c0;">Click the path below to copy the local start file path:</p>
                <div class="server-hint-content" style="max-width: 420px; width: 100%;">
                    <div style="margin-bottom:10px;">
                        <a href="#" class="file-link" onclick="copyBatPath(); return false;" title="Click to copy start path">
                            <span class="path" id="batPathDisplay">START-PPT-CONTROLLER.bat</span>
                            <span class="hint" id="batPathHint">Click to copy</span>
                        </a>
                    </div>
                    <div class="steps" style="margin-top:10px;">
                        <ol>
                            <li>Press <strong>Win+R</strong>, paste (Ctrl+V), press Enter</li>
                            <li>Open PowerPoint presentation</li>
                            <li>Use â—€ Prev / Next â–¶ buttons to navigate</li>
                        </ol>
                    </div>
                </div>
                <button class="done-btn" onclick="dismissServerHint()">Done</button>
            </div>
        </div>

        <!-- Screen Capture Container (hidden until capture starts) -->
        <div id="screenContainer" class="screen-container">
            <video id="screenVideo" class="screen-video" autoplay muted></video>
            
            <!-- Drawing Canvas Overlay -->
            <canvas id="drawCanvas"></canvas>
            
            <!-- PPT Click Zones Overlay (for screen capture PPT control) -->
            <div id="pptClickZones" class="ppt-click-zones">
                <div class="ppt-zone prev" onclick="pptPrevious()" title="Previous slide">â—€</div>
                <div class="ppt-zone middle"></div>
                <div class="ppt-zone next" onclick="pptNext()" title="Next slide">â–¶</div>
            </div>
        </div>
        
        <!-- Red Cursor Follower -->
        <div id="cursorFollower"></div>
        
        <!-- Error overlay for blocked sites -->
        <div id="iframeError" class="iframe-error">
            <div class="icon">ðŸš«</div>
            <h2>This Website Cannot Be Displayed Here</h2>
            <div class="error-url" id="errorUrl"></div>
            <div class="reason">
                <h3>Why is this happening?</h3>
                <p>This website has security settings that prevent it from being embedded in other pages. 
                   This is a common protection used by major websites like Google, Facebook, and many banking sites 
                   to keep your data safe.</p>
            </div>
            <p style="margin-top: 20px; color: #888;">Technical reason: The server sends an <code style="background: rgba(255,100,100,0.2); padding: 2px 6px; border-radius: 4px;">X-Frame-Options</code> or <code style="background: rgba(255,100,100,0.2); padding: 2px 6px; border-radius: 4px;">Content-Security-Policy</code> header blocking iframe embedding.</p>
            <button class="btn-open-tab" onclick="openInNewTab()">ðŸ”— Open in New Browser Tab</button>
        </div>
        <div id="externalOpenState" class="external-open-state">
            <div class="icon">â†—ï¸</div>
            <h2>Opened In New Browser Tab</h2>
            <div class="error-url" id="externalOpenUrl"></div>
            <p>This page uses login/security policies that are usually blocked inside iframes.
               AI Cafe opens it directly in a normal browser tab.</p>
            <button class="btn-open-tab" onclick="reopenExternalUrl()">ðŸ”— Open Again</button>
        </div>
        <div id="authRequiredState" class="external-open-state">
            <div class="icon">ðŸ”’</div>
            <h2>Page Cannot Be Displayed Here</h2>
            <div class="error-url" id="authRequiredUrl"></div>
            <p>This page cannot be embedded in the presenter due to authentication requirements or security restrictions.<br>
               <strong>Option 1:</strong> Open the page in a separate browser tab.<br>
               <strong>Option 2:</strong> After authenticating externally, click "Retry in Presenter" to try loading it here.</p>
            <div style="display:flex; gap:12px; justify-content:center; margin-top:12px; flex-wrap:wrap;">
                <button class="btn-open-tab" onclick="authLoginPopup()">â†—ï¸ Open in New Tab</button>
                <button class="btn-open-tab" onclick="retryAfterAuth()" style="background: linear-gradient(135deg, #2563eb, #1d4ed8);">ðŸ”„ Retry in Presenter</button>
            </div>
        </div>
    </div>

    <script>
        // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        // â•‘  CONFIGURATION - Adjust these paths when deploying to a new PC  â•‘
        // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const CONFIG = {
            // Path to the PowerPoint controller BAT file (resolved dynamically at runtime)
            PPT_CONTROLLER_PATH: 'START-PPT-CONTROLLER.bat',
            
            // Default folder for "Set as Home" suggestions (optional)
            DEFAULT_FOLDER: 'E:\\AI Caf\\u00E9\\',
            
            // PPT controller local server (usually no change needed)
            PPT_SERVER: 'http://localhost:8765'
        };
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const STORAGE_KEY = 'ai_cafe_presenter_url';
        const STORAGE_HOME_KEY = 'ai_cafe_presenter_home'; // kept for migration cleanup

        // Tab system
        const TABS_STORAGE_KEY = 'ai_cafe_presenter_tabs';
        const MAX_TABS = 12;
        const DEFAULT_TAB_COUNT = 5;
        let tabs = [];
        let activeTabIndex = 0;
        let nextTabId = 1;
        let tabPanelVisible = true;
        const MAX_TAB_RESUME_STATES = 20;
        let pendingTabResumeRestore = null;
        let iframeStateListenerWindow = null;
        let iframeStateListenerHandler = null;
        let iframeStateListenerTabId = null;
        let iframeStateScrollHandler = null;
        let iframeStateScrollTimer = null;

        function resolveLocalPptControllerPath() {
            if (window.location.protocol !== 'file:') {
                return CONFIG.PPT_CONTROLLER_PATH;
            }
            try {
                let decodedPath = decodeURIComponent(window.location.pathname || '');
                decodedPath = decodedPath.replace(/\//g, '\\');
                if (/^\\[A-Za-z]:\\/.test(decodedPath)) {
                    decodedPath = decodedPath.substring(1);
                }
                const lastSlash = decodedPath.lastIndexOf('\\');
                if (lastSlash >= 0) {
                    return decodedPath.substring(0, lastSlash + 1) + 'START-PPT-CONTROLLER.bat';
                }
            } catch (error) {}
            return CONFIG.PPT_CONTROLLER_PATH;
        }

        function initPptControllerPathDisplay() {
            const localPath = resolveLocalPptControllerPath();
            CONFIG.PPT_CONTROLLER_PATH = localPath;
            const batPathDisplay = document.getElementById('batPathDisplay');
            if (batPathDisplay) {
                batPathDisplay.textContent = localPath;
            }
        }
        
        let toolbarResizeObserver = null;

        function updateToolbarLayout() {
            const contentPanel = document.getElementById('contentPanel');
            const toolbar = document.querySelector('.url-bar');
            if (!contentPanel || !toolbar) return;
            const toolbarHeight = Math.max(44, Math.ceil(toolbar.getBoundingClientRect().height));
            contentPanel.style.setProperty('--toolbar-height', toolbarHeight + 'px');
        }

        function initToolbarLayoutObserver() {
            updateToolbarLayout();
            const toolbar = document.querySelector('.url-bar');
            if (!toolbar) return;
            window.addEventListener('resize', updateToolbarLayout);
            if (typeof ResizeObserver === 'function') {
                toolbarResizeObserver = new ResizeObserver(() => {
                    updateToolbarLayout();
                });
                toolbarResizeObserver.observe(toolbar);
            }
        }
        
        // === URL Loading ===
        let navigationHistory = [];
        
        function updateBackButton() {
            // Back button removed in toolbar redesign - function kept for history tracking
        }
        
        let currentLoadingUrl = '';
        let loadTimeout = null;
        let lastBlockedAutoOpen = { url: '', time: 0 };
        let externalOpenUrl = '';
        const BLOCKED_FRAME_HOSTS_KEY = 'ai_cafe_presenter_blocked_frame_hosts';
        const FORCE_EXTERNAL_HOSTS = new Set([
            'aura-v6-2.netlify.app'
        ]);
        let blockedFrameHosts = new Set();

        function loadBlockedFrameHosts() {
            try {
                const raw = localStorage.getItem(BLOCKED_FRAME_HOSTS_KEY);
                if (!raw) return;
                const arr = JSON.parse(raw);
                if (Array.isArray(arr)) {
                    blockedFrameHosts = new Set(arr.map(v => String(v).toLowerCase()));
                }
            } catch (e) {}
        }

        function saveBlockedFrameHosts() {
            try {
                localStorage.setItem(BLOCKED_FRAME_HOSTS_KEY, JSON.stringify(Array.from(blockedFrameHosts)));
            } catch (e) {}
        }

        function getUrlHostname(url) {
            try {
                const parsed = new URL(url, window.location.href);
                const protocol = parsed.protocol || '';
                if (protocol === 'http:' || protocol === 'https:') {
                    return parsed.hostname.toLowerCase();
                }
            } catch (e) {}
            return '';
        }

        function shouldOpenExternallyFirst(url) {
            try {
                const parsed = new URL(url, window.location.href);
                const protocol = parsed.protocol || '';
                if (protocol !== 'http:' && protocol !== 'https:') return false;

                const host = (parsed.hostname || '').toLowerCase();
                const path = (parsed.pathname || '').toLowerCase();

                if (FORCE_EXTERNAL_HOSTS.has(host)) return true;
                if (blockedFrameHosts.has(host)) return true;
                if (path.includes('/.auth/')) return true;
                if (host === 'github.com' || host.endsWith('.github.com')) return true;
                if (host.endsWith('.auth0.com')) return true;
                if (host === 'login.microsoftonline.com') return true;
                // Azure SWA: auth-protected, X-Frame-Options blocks iframe after redirect
                if (host.endsWith('.azurestaticapps.net')) return true;
                // Microsoft internal repos / auth-gated Microsoft pages
                if (host === 'repos.opensource.microsoft.com') return true;
                if (host.endsWith('.sharepoint.com')) return true;
                if (host === 'dev.azure.com' || host.endsWith('.visualstudio.com')) return true;

                return false;
            } catch (e) {
                return false;
            }
        }

        function isKnownBlockedFrameUrl(url) {
            const host = getUrlHostname(url);
            if (!host) return false;
            return blockedFrameHosts.has(host);
        }

        function rememberBlockedFrameUrl(url) {
            const host = getUrlHostname(url);
            if (!host) return;
            if (!blockedFrameHosts.has(host)) {
                blockedFrameHosts.add(host);
                saveBlockedFrameHosts();
            }
        }

        function hideExternalOpenState() {
            const panel = document.getElementById('externalOpenState');
            if (panel) panel.style.display = 'none';
            const authPanel = document.getElementById('authRequiredState');
            if (authPanel) authPanel.style.display = 'none';
        }

        const PAGE_SWITCH_BLACK_MIN_MS = 140;
        let pageSwitchShownAt = 0;
        let pageSwitchHideTimer = null;

        function showPageSwitchBlack() {
            const overlay = document.getElementById('pageSwitchOverlay');
            if (!overlay) return;
            if (pageSwitchHideTimer) {
                clearTimeout(pageSwitchHideTimer);
                pageSwitchHideTimer = null;
            }
            pageSwitchShownAt = performance.now();
            overlay.classList.add('active');
        }

        function hidePageSwitchBlack(force) {
            const overlay = document.getElementById('pageSwitchOverlay');
            if (!overlay) return;
            const hideNow = function() {
                overlay.classList.remove('active');
                pageSwitchHideTimer = null;
            };
            if (force) {
                if (pageSwitchHideTimer) {
                    clearTimeout(pageSwitchHideTimer);
                    pageSwitchHideTimer = null;
                }
                hideNow();
                return;
            }
            const elapsed = performance.now() - pageSwitchShownAt;
            const wait = Math.max(0, PAGE_SWITCH_BLACK_MIN_MS - elapsed);
            if (pageSwitchHideTimer) clearTimeout(pageSwitchHideTimer);
            if (wait === 0) hideNow();
            else pageSwitchHideTimer = setTimeout(hideNow, wait);
        }

        let authRequiredUrl = '';

        function isAuthProviderHost(host) {
            if (!host) return false;
            host = host.toLowerCase();
            return host === 'login.microsoftonline.com' ||
                   host === 'login.microsoft.com' ||
                   host === 'login.live.com' ||
                   host === 'sts.windows.net' ||
                   host.endsWith('.auth0.com') ||
                   host === 'accounts.google.com';
        }

        function isAzureStaticWebApp(url) {
            try {
                const parsed = new URL(url, window.location.href);
                return parsed.hostname.toLowerCase().endsWith('.azurestaticapps.net');
            } catch (e) { return false; }
        }

        function showAuthRequiredState(url) {
            authRequiredUrl = url;
            const panel = document.getElementById('authRequiredState');
            const urlEl = document.getElementById('authRequiredUrl');
            if (urlEl) urlEl.textContent = url;

            document.getElementById('contentFrame').style.display = 'none';
            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('iframeError').style.display = 'none';
            const extPanel = document.getElementById('externalOpenState');
            if (extPanel) extPanel.style.display = 'none';
            if (panel) panel.style.display = 'flex';
            hidePageSwitchBlack(true);

            // Do NOT remember host as permanently blocked â€” it will work after auth
            console.info('[AI Cafe] Auth required for URL:', url);
        }

        function authLoginPopup() {
            if (!authRequiredUrl) return;
            const opened = tryOpenInNewTab(authRequiredUrl);
            if (!opened) {
                alert('Popup blocked. Please allow popups for this page and try again.');
            }
        }

        function retryAfterAuth() {
            if (!authRequiredUrl) return;
            const url = authRequiredUrl;

            // Remove from blocked hosts if it was added
            const host = getUrlHostname(url);
            if (host && blockedFrameHosts.has(host)) {
                blockedFrameHosts.delete(host);
                saveBlockedFrameHosts();
                console.info('[AI Cafe] Removed', host, 'from blocked-frame-hosts for auth retry.');
            }

            // Hide auth panel, show iframe
            const authPanel = document.getElementById('authRequiredState');
            if (authPanel) authPanel.style.display = 'none';
            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('iframeError').style.display = 'none';

            const frame = document.getElementById('contentFrame');
            frame.style.display = 'block';
            currentLoadingUrl = url;
            showPageSwitchBlack();
            frame.src = url;

            // Give more time after auth (cookies may need to propagate)
            if (loadTimeout) clearTimeout(loadTimeout);
            loadTimeout = setTimeout(() => {
                checkIframeLoaded(url);
            }, 5000);

            // Re-check: if still redirecting after auth, show panel again
            detectAuthRedirect(url);
        }

        // Proactive auth/framing detection for ALL external URLs.
        // Uses fetch with redirect:'manual' to check if the server redirects to a login page.
        // This runs concurrently with iframe loading; if a redirect is detected,
        // it replaces the (broken) iframe with the info panel.
        async function detectAuthRedirect(url) {
            // Strategy: try a same-origin-safe fetch first; if that fails
            // (expected when running from file://), fall back to a timer that
            // checks whether the iframe loaded successfully.
            let fetchWorked = false;
            const canProbeWithFetch = window.location.protocol !== 'file:';
            if (canProbeWithFetch) {
                try {
                    // Use 'cors' mode with 'manual' redirect to detect 302â†’login.
                    // This will only succeed for same-origin or CORS-enabled servers.
                    const response = await fetch(url, {
                        mode: 'cors',
                        redirect: 'manual',
                        credentials: 'include'
                    });
                    fetchWorked = true;
                    // opaqueredirect = server returned 302 (likely to a login page)
                    if (response.type === 'opaqueredirect' && currentLoadingUrl === url) {
                        console.info('[AI Cafe] Auth redirect detected via fetch for:', url);
                        autoOpenInNewTab(url, 'auth-redirect-detected');
                    }
                    // 200 = page accessible, iframe should load fine
                } catch (e) {
                    // fetch failed due to CORS/network; timer fallback handles detection.
                }
            }

            // Timer fallback: wait and check if iframe is broken.
            // Runs regardless of fetch outcome as a safety net.
            if (!fetchWorked) {
                await new Promise(resolve => setTimeout(resolve, 4000));
                if (currentLoadingUrl !== url) return;
                const frame = document.getElementById('contentFrame');
                const authPanel = document.getElementById('authRequiredState');
                const errorPanel = document.getElementById('iframeError');
                const extPanel = document.getElementById('externalOpenState');
                // Only intervene if iframe is still showing but appears broken
                if (frame && frame.style.display !== 'none'
                    && (!authPanel || authPanel.style.display !== 'flex')
                    && (!errorPanel || errorPanel.style.display !== 'flex')
                    && (!extPanel || extPanel.style.display !== 'flex')) {
                    let isBroken = false;
                    try {
                        const loc = frame.contentWindow.location.href;
                        isBroken = !loc || loc === 'about:blank' || loc.startsWith('chrome-error://');
                    } catch (e2) {
                        // Cross-origin: page likely loaded fine, don't intervene
                        isBroken = false;
                    }
                    if (isBroken) {
                        console.info('[AI Cafe] Timer fallback: iframe broken, auto-opening in new tab:', url);
                        autoOpenInNewTab(url, 'iframe-broken-timer');
                    }
                }
            }
        }

        function tryOpenInNewTab(url) {
            if (!url) return false;

            let opened = window.open(url, '_blank', 'noopener,noreferrer');
            if (opened) return true;

            // Fallback: some browsers block window.open() but allow target=_blank anchor clicks.
            try {
                const link = document.createElement('a');
                link.href = url;
                link.target = '_blank';
                link.rel = 'noopener noreferrer';
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                link.remove();
                opened = true;
            } catch (e) {}

            return !!opened;
        }

        // Central helper: open a URL in a new browser tab and show the
        // "opened externally" info panel. Used by auth detection, timer
        // fallback, and anywhere else an iframe can't display a page.
        function autoOpenInNewTab(url, reason) {
            rememberBlockedFrameUrl(url);
            const opened = tryOpenInNewTab(url);
            if (opened) {
                console.info('[AI Cafe] Auto-opened in new tab (' + reason + '):', url);
            } else {
                console.warn('[AI Cafe] Popup blocked when trying to auto-open:', url);
            }
            showExternalOpenState(url, reason);
        }

        function showExternalOpenState(url, reason) {
            externalOpenUrl = url || '';
            const panel = document.getElementById('externalOpenState');
            const urlEl = document.getElementById('externalOpenUrl');
            if (urlEl) urlEl.textContent = externalOpenUrl;

            document.getElementById('contentFrame').style.display = 'none';
            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('iframeError').style.display = 'none';
            const authPanel = document.getElementById('authRequiredState');
            if (authPanel) authPanel.style.display = 'none';
            if (panel) panel.style.display = 'flex';
            hidePageSwitchBlack(true);

            if (reason) {
                console.info('[AI Cafe] Showing external-open notice (' + reason + '):', url);
            }
        }

        function reopenExternalUrl() {
            if (!externalOpenUrl) return;
            const opened = tryOpenInNewTab(externalOpenUrl);
            if (!opened) {
                alert('Popup blocked. Allow popups for this page and try again.');
            }
        }
        
        function loadUrl(addToHistory = true, captureCurrentState = true) {
            let input = document.getElementById('urlInput').value.trim();
            if (!input) return;
            if (captureCurrentState) {
                pendingTabResumeRestore = null;
                captureActiveTabResumeState();
            }

            // Determine storable (relative) vs loadable (absolute) URL
            let storableUrl = input;
            let loadableUrl;

            if (/^[A-Za-z]:[\\\/]/.test(input)) {
                // Windows absolute path: E:\AI CafÃ©\file.html
                loadableUrl = 'file:///' + input.replace(/\\/g, '/');
                storableUrl = toRelativePath(loadableUrl);
            } else if (/^file:\/\/\//.test(input)) {
                loadableUrl = input;
                storableUrl = toRelativePath(input);
            } else if (/^https?:\/\//.test(input)) {
                loadableUrl = input;
                storableUrl = input;
            } else if (isRelativeFilePath(input)) {
                storableUrl = input;
                loadableUrl = resolveUrl(input);
            } else {
                loadableUrl = 'https://' + input;
                storableUrl = loadableUrl;
            }

            document.getElementById('urlInput').value = storableUrl;

            // Update active tab
            if (tabs[activeTabIndex]) {
                tabs[activeTabIndex].url = storableUrl;
                tabs[activeTabIndex].title = getTabTitleFromUrl(storableUrl);
                renderTabList();
                saveTabs();
            }

            // Add to navigation history
            if (addToHistory) {
                navigationHistory.push(loadableUrl);
                updateBackButton();
            }

            // Backward compat
            localStorage.setItem(STORAGE_KEY, storableUrl);

            // Always update lastBrowseUrl
            lastBrowseUrl = loadableUrl;

            // Track loading URL for error detection
            currentLoadingUrl = loadableUrl;

            // URLs that are very likely auth-redirect/frame-blocked are opened directly.
            if (shouldOpenExternallyFirst(loadableUrl)) {
                rememberBlockedFrameUrl(loadableUrl);
                pendingTabResumeRestore = null;
                const opened = tryOpenInNewTab(loadableUrl);
                if (opened) {
                    console.info('[AI Cafe] URL matches auth-redirect pattern, opened directly in new tab:', loadableUrl);
                    showExternalOpenState(loadableUrl, 'auth-redirect-pattern');
                    return;
                }
                console.warn('[AI Cafe] Auth-redirect URL could not auto-open (popup blocked):', loadableUrl);
                showExternalOpenState(loadableUrl, 'auth-redirect-popup-blocked');
                return;
            }

            // Otherwise try loading in iframe first; timeout/CSP/error handlers
            // can still switch to external-open mode when embedding fails.

            const frame = document.getElementById('contentFrame');
            showPageSwitchBlack();
            frame.src = loadableUrl;

            // If capture is active, switch to browser view
            if (screenStream) {
                switchView('browse');
                return;
            }

            // Normal browse mode: show iframe
            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('iframeError').style.display = 'none';
            hideExternalOpenState();
            frame.style.display = 'block';

            // Clear previous timeout
            if (loadTimeout) clearTimeout(loadTimeout);

            // Set timeout for external URLs (not file://)
            if (!loadableUrl.startsWith('file://') && !loadableUrl.startsWith('blob:')) {
                loadTimeout = setTimeout(() => {
                    checkIframeLoaded(loadableUrl);
                }, 3000); // 3 second timeout
            }

            // Proactive auth/framing detection for all external URLs.
            // Runs concurrently with iframe loading. If auth redirect detected,
            // replaces the iframe with the info panel.
            if (loadableUrl.startsWith('https://') || loadableUrl.startsWith('http://')) {
                detectAuthRedirect(loadableUrl);
            }
        }
        
        function checkIframeLoaded(expectedUrl) {
            const frame = document.getElementById('contentFrame');
            if (!frame || frame.style.display === 'none') return;
            if (currentLoadingUrl !== expectedUrl) return;
            try {
                // Try to access the iframe's location - this throws if blocked
                const iframeLoc = frame.contentWindow.location.href;
                // Same-origin reachable but still blank/error after timeout -> treat as blocked/failed.
                if (!iframeLoc || iframeLoc === 'about:blank') {
                    showIframeError(expectedUrl, 'iframe-timeout-blank');
                    return;
                }
                if (iframeLoc.startsWith('chrome-error://')) {
                    showIframeError(expectedUrl, 'iframe-timeout-chrome-error');
                    return;
                }
            } catch (e) {
                // Cross-origin access usually means the page loaded successfully.
            }
        }
        
        function tryAutoOpenBlockedUrl(url, reason) {
            if (!url || url.startsWith('file://') || url.startsWith('blob:')) return false;
            rememberBlockedFrameUrl(url);

            const now = Date.now();
            if (lastBlockedAutoOpen.url === url && (now - lastBlockedAutoOpen.time) < 8000) {
                return false;
            }

            lastBlockedAutoOpen = { url: url, time: now };
            const opened = tryOpenInNewTab(url);
            if (opened) {
                console.warn('[AI Cafe] Iframe blocked, opened in new tab (' + reason + '):', url);
                showExternalOpenState(url, reason || 'iframe-blocked');
                return true;
            }

            console.warn('[AI Cafe] Iframe blocked and popup was blocked by browser:', url);
            return false;
        }

        function showIframeError(url, reason) {
            // Any external URL that can't be displayed: auto-open in a new
            // browser tab and show the info panel.
            // Covers auth redirects, X-Frame-Options blocks, CSP violations, etc.
            if (url && (url.startsWith('http://') || url.startsWith('https://'))) {
                autoOpenInNewTab(url, reason || 'iframe-error');
                return;
            }

            // Fallback for local file:// URLs
            document.getElementById('contentFrame').style.display = 'none';
            document.getElementById('emptyState').style.display = 'none';
            hideExternalOpenState();
            document.getElementById('iframeError').style.display = 'flex';
            document.getElementById('errorUrl').textContent = url;
            hidePageSwitchBlack(true);
        }
        
        function openInNewTab() {
            const url = document.getElementById('errorUrl').textContent;
            if (url) tryOpenInNewTab(url);
        }
        
        // Listen for iframe load errors and CSP/X-Frame-Options violations
        document.addEventListener('DOMContentLoaded', function() {
            loadBlockedFrameHosts();

            // Set initial toolbar state (no capture active)
            showBrowseMode();

            const frame = document.getElementById('contentFrame');
            
            frame.addEventListener('load', function() {
                hidePageSwitchBlack(false);

                // Clear timeout on successful load
                if (loadTimeout) {
                    clearTimeout(loadTimeout);
                    loadTimeout = null;
                }

                // Setup fullscreen listener for same-origin iframes
                setupIframeFullscreenListener();
                setupIframeStateListeners();
                if (typeof checkIframeCrossOrigin === 'function') checkIframeCrossOrigin();

                // Always focus contentPanel after page load so keyboard shortcuts
                // (D for draw, F for fullscreen, PPT controls) work immediately.
                // The user just navigated (Enter in URL bar or clicked a link),
                // so there is no editing context to preserve.
                if (currentView === 'browse') {
                    const contentPanel = document.getElementById('contentPanel');
                    if (contentPanel) contentPanel.focus();
                }

                // If this load came from tab activation, restore last known
                // scroll/slide position for this exact URL.
                restorePendingTabResumeState();
                 
                // Extract page title for tab
                try {
                    const doc = frame.contentDocument || frame.contentWindow.document;
                    if (doc && doc.title) updateActiveTabTitle(doc.title);
                } catch (e) { /* cross-origin: title already set from URL */ }

                // Check if iframe loaded successfully or was blocked
                if (currentLoadingUrl && !currentLoadingUrl.startsWith('file://') && !currentLoadingUrl.startsWith('blob:')) {
                    try {
                        const doc = frame.contentDocument || frame.contentWindow.document;
                        if (doc && doc.body && doc.body.innerHTML === '') {
                            showIframeError(currentLoadingUrl, 'empty-body');
                        }
                    } catch (e) {
                        // Cross-origin is expected for external sites
                    }

                    try {
                        const iframeLoc = frame.contentWindow.location.href;
                        if (!iframeLoc || iframeLoc === 'about:blank') {
                            showIframeError(currentLoadingUrl, 'about-blank-after-load');
                        } else if (iframeLoc.startsWith('chrome-error://')) {
                            showIframeError(currentLoadingUrl, 'chrome-error-page');
                        }
                    } catch (e) {
                        // Cross-origin access can throw; ignore here.
                    }
                }
            });
            
            frame.addEventListener('error', function() {
                hidePageSwitchBlack(true);
                // Show error if iframe fails to load
                if (currentLoadingUrl && !currentLoadingUrl.startsWith('file://')) {
                    showIframeError(currentLoadingUrl, 'iframe-error-event');
                }
            });
            
            // Listen for security policy violations (catches X-Frame-Options blocks)
            window.addEventListener('securitypolicyviolation', function(e) {
                if (!currentLoadingUrl || currentLoadingUrl.startsWith('file://') || currentLoadingUrl.startsWith('blob:')) return;

                const frame = document.getElementById('contentFrame');
                if (!frame || frame.style.display === 'none') return;

                const effectiveDirective = (e.effectiveDirective || '').toLowerCase();
                const violatedDirective = (e.violatedDirective || '').toLowerCase();
                const isFrameAncestorsViolation =
                    effectiveDirective.includes('frame-ancestors') || violatedDirective.includes('frame-ancestors');
                if (!isFrameAncestorsViolation) return;

                // Any security policy violation means the page can't be embedded.
                // Show unified info panel with options to open in new tab or retry.
                showIframeError(currentLoadingUrl, 'security-policy');
            });
        });
        
        function goBack() {
            if (navigationHistory.length > 1) {
                navigationHistory.pop(); // Remove current
                const previousUrl = navigationHistory[navigationHistory.length - 1];
                document.getElementById('urlInput').value = previousUrl;
                document.getElementById('iframeError').style.display = 'none';
                hideExternalOpenState();
                document.getElementById('contentFrame').style.display = 'block';
                showPageSwitchBlack();
                document.getElementById('contentFrame').src = previousUrl;
                localStorage.setItem(STORAGE_KEY, previousUrl);
                // Update active tab
                if (tabs[activeTabIndex]) {
                    tabs[activeTabIndex].url = toRelativePath(previousUrl);
                    tabs[activeTabIndex].title = getTabTitleFromUrl(previousUrl);
                    renderTabList();
                    saveTabs();
                }
                updateBackButton();
            }
        }
        
        // === Tab Management ===
        function isRelativeFilePath(input) {
            if (/\\/.test(input)) return true;
            if (/\.(html?|pdf|png|jpe?g|gif|svg|webp|txt|json|xml|css|js|md)(\?.*)?$/i.test(input)) return true;
            return false;
        }

        function resolveUrl(url) {
            if (!url) return url;
            if (/^(javascript|data|vbscript):/i.test(url.trim())) return '';
            if (/^https?:\/\//.test(url)) return url;
            if (/^file:\/\/\//.test(url)) return url;
            if (/^blob:/.test(url)) return url;
            if (/^[A-Za-z]:[\\\/]/.test(url)) return 'file:///' + url.replace(/\\/g, '/');
            // Relative path â€” resolve against presenter location
            if (window.location.protocol === 'file:') {
                const baseDir = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
                return baseDir + encodeURIComponent(url).replace(/%2F/g, '/').replace(/%5C/g, '/');
            }
            return url;
        }

        function toRelativePath(absoluteUrl) {
            if (!absoluteUrl) return absoluteUrl;
            if (!/^file:\/\/\//.test(absoluteUrl)) return absoluteUrl;
            if (window.location.protocol !== 'file:') return absoluteUrl;
            const baseDir = decodeURIComponent(window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1));
            const decoded = decodeURIComponent(absoluteUrl);
            if (decoded.startsWith(baseDir)) {
                return decoded.substring(baseDir.length);
            }
            return absoluteUrl;
        }

        function normalizeResumeStateUrl(url) {
            if (!url) return '';
            try {
                return new URL(url, window.location.href).href;
            } catch (e) {
                return String(url);
            }
        }

        function getResumeComparableUrlParts(url) {
            try {
                const parsed = new URL(normalizeResumeStateUrl(url), window.location.href);
                const protocol = (parsed.protocol || '').toLowerCase();
                const hostname = (parsed.hostname || '').toLowerCase();
                const search = parsed.search || '';
                const hash = parsed.hash || '';
                let pathname = parsed.pathname || '';
                if (protocol === 'file:') {
                    pathname = decodeURIComponent(pathname).replace(/\\/g, '/').toLowerCase();
                }
                return { protocol, hostname, pathname, search, hash };
            } catch (e) {
                return null;
            }
        }

        function resumeUrlsEqual(a, b) {
            const na = normalizeResumeStateUrl(a);
            const nb = normalizeResumeStateUrl(b);
            if (na === nb) return true;

            const pa = getResumeComparableUrlParts(na);
            const pb = getResumeComparableUrlParts(nb);
            if (!pa || !pb) return false;
            if (pa.protocol !== pb.protocol) return false;
            if (pa.hostname !== pb.hostname) return false;
            if (pa.search !== pb.search) return false;
            if (pa.hash !== pb.hash) return false;
            return pa.pathname === pb.pathname;
        }

        function findResumeStateForUrl(tab, url) {
            if (!tab || !tab.resumeStates || typeof tab.resumeStates !== 'object' || Array.isArray(tab.resumeStates)) {
                return null;
            }
            const normalizedUrl = normalizeResumeStateUrl(url);
            if (tab.resumeStates[normalizedUrl]) {
                return { key: normalizedUrl, state: tab.resumeStates[normalizedUrl] };
            }
            const keys = Object.keys(tab.resumeStates);
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                if (resumeUrlsEqual(key, normalizedUrl)) {
                    return { key: key, state: tab.resumeStates[key] };
                }
            }
            return null;
        }

        function pruneTabResumeStates(tab) {
            if (!tab || !tab.resumeStates || typeof tab.resumeStates !== 'object' || Array.isArray(tab.resumeStates)) return;
            const entries = Object.entries(tab.resumeStates);
            if (entries.length <= MAX_TAB_RESUME_STATES) return;
            entries.sort((a, b) => {
                const ta = a[1] && typeof a[1].ts === 'number' ? a[1].ts : 0;
                const tb = b[1] && typeof b[1].ts === 'number' ? b[1].ts : 0;
                return tb - ta;
            });
            const trimmed = entries.slice(0, MAX_TAB_RESUME_STATES);
            tab.resumeStates = Object.fromEntries(trimmed);
        }

        function getFrameResumeStateForWindow(win) {
            if (!win) return null;
            try {
                const doc = win.document;
                if (!doc || !win.location) return null;
                const url = normalizeResumeStateUrl(win.location.href);
                if (!url || url === 'about:blank') return null;

                const scrollY = Math.max(
                    0,
                    Math.round(
                        typeof win.scrollY === 'number'
                            ? win.scrollY
                            : ((doc.documentElement && doc.documentElement.scrollTop) || (doc.body && doc.body.scrollTop) || 0)
                    )
                );

                let nearestSlideId = '';
                const slides = doc.querySelectorAll('.slide[id]');
                if (slides && slides.length) {
                    let bestDist = Infinity;
                    slides.forEach(slide => {
                        const top = typeof slide.offsetTop === 'number' ? slide.offsetTop : 0;
                        const dist = Math.abs(top - scrollY);
                        if (dist < bestDist) {
                            bestDist = dist;
                            nearestSlideId = slide.id || '';
                        }
                    });
                }

                return {
                    url: url,
                    scrollY: scrollY,
                    slideId: nearestSlideId,
                    ts: Date.now()
                };
            } catch (e) {
                return null; // Cross-origin frame or transient navigation state
            }
        }

        function captureTabResumeState(tab, sourceWindow) {
            if (!tab) return;

            const frame = document.getElementById('contentFrame');
            const win = sourceWindow || (frame && frame.contentWindow);
            const state = getFrameResumeStateForWindow(win);
            if (!state) return;

            if (!tab.resumeStates || typeof tab.resumeStates !== 'object' || Array.isArray(tab.resumeStates)) {
                tab.resumeStates = {};
            }

            const prev = tab.resumeStates[state.url];
            const changed = !prev
                || Math.abs((prev.scrollY || 0) - state.scrollY) > 6
                || (prev.slideId || '') !== (state.slideId || '');
            if (!changed) return;

            tab.resumeStates[state.url] = state;
            pruneTabResumeStates(tab);
            saveTabs();
        }

        function captureActiveTabResumeState(sourceWindow) {
            const tab = tabs[activeTabIndex];
            captureTabResumeState(tab, sourceWindow);
        }

        function requestTabResumeRestore(tab, loadableUrl) {
            if (!tab || !loadableUrl) {
                pendingTabResumeRestore = null;
                return;
            }
            const matched = findResumeStateForUrl(tab, loadableUrl);
            const stateSnapshot = matched && matched.state
                ? {
                    scrollY: Math.max(0, Math.round(Number(matched.state.scrollY) || 0)),
                    slideId: matched.state.slideId ? String(matched.state.slideId) : '',
                    ts: typeof matched.state.ts === 'number' ? matched.state.ts : 0
                }
                : null;
            pendingTabResumeRestore = {
                tabId: tab.id,
                url: normalizeResumeStateUrl(loadableUrl),
                ts: Date.now(),
                state: stateSnapshot
            };
        }

        function restorePendingTabResumeState() {
            const pending = pendingTabResumeRestore;
            if (!pending) return;
            if (Date.now() - (pending.ts || 0) > 10000) {
                pendingTabResumeRestore = null;
                return;
            }

            const tab = tabs[activeTabIndex];
            if (!tab || tab.id !== pending.tabId) return;
            if (!tab.resumeStates || typeof tab.resumeStates !== 'object' || Array.isArray(tab.resumeStates)) return;

            const frame = document.getElementById('contentFrame');
            if (!frame || !frame.contentWindow) return;

            try {
                const win = frame.contentWindow;
                const doc = frame.contentDocument || win.document;
                const currentUrl = normalizeResumeStateUrl(win.location.href);
                if (!currentUrl || !resumeUrlsEqual(currentUrl, pending.url)) return;

                const matched = findResumeStateForUrl(tab, currentUrl);
                const state = pending.state || (matched && matched.state);
                if (!state || typeof state.scrollY !== 'number') {
                    pendingTabResumeRestore = null;
                    return;
                }

                const docEl = doc && doc.documentElement ? doc.documentElement : null;
                const body = doc && doc.body ? doc.body : null;
                const docHeight = Math.max(
                    docEl ? docEl.scrollHeight : 0,
                    body ? body.scrollHeight : 0
                );
                const viewportHeight = Math.max(win.innerHeight || 0, 1);
                const maxY = Math.max(0, docHeight - viewportHeight);
                let targetY = Math.max(0, Math.min(Math.round(state.scrollY), maxY));

                if (state.slideId && doc && doc.getElementById) {
                    const slideEl = doc.getElementById(state.slideId);
                    if (slideEl && typeof slideEl.offsetTop === 'number' && Math.abs(slideEl.offsetTop - targetY) > 120) {
                        targetY = Math.max(0, Math.min(Math.round(slideEl.offsetTop), maxY));
                    }
                }

                const applyRestore = function() {
                    try {
                        win.scrollTo(0, targetY);
                    } catch (e) {}
                };
                applyRestore();
                setTimeout(applyRestore, 120);
                setTimeout(applyRestore, 450);
                pendingTabResumeRestore = null;
            } catch (e) {
                // Cross-origin frame - cannot restore scroll position
                pendingTabResumeRestore = null;
            }
        }

        function setupIframeStateListeners() {
            const frame = document.getElementById('contentFrame');
            if (!frame || !frame.contentWindow) return;

            try {
                const win = frame.contentWindow;
                const tabAtAttach = tabs[activeTabIndex];
                const tabIdAtAttach = tabAtAttach ? tabAtAttach.id : null;

                if (iframeStateListenerWindow === win && iframeStateListenerTabId === tabIdAtAttach) return;

                if (iframeStateListenerWindow && iframeStateListenerHandler) {
                    try { iframeStateListenerWindow.removeEventListener('beforeunload', iframeStateListenerHandler); } catch (e) {}
                    try { iframeStateListenerWindow.removeEventListener('pagehide', iframeStateListenerHandler); } catch (e) {}
                }
                if (iframeStateListenerWindow && iframeStateScrollHandler) {
                    try { iframeStateListenerWindow.removeEventListener('scroll', iframeStateScrollHandler); } catch (e) {}
                }
                if (iframeStateScrollTimer) {
                    clearTimeout(iframeStateScrollTimer);
                    iframeStateScrollTimer = null;
                }

                iframeStateListenerWindow = win;
                iframeStateListenerTabId = tabIdAtAttach;
                const captureForAttachedTab = function() {
                    if (!tabIdAtAttach) return;
                    const targetTab = tabs.find(t => t && t.id === tabIdAtAttach);
                    captureTabResumeState(targetTab, win);
                };
                iframeStateListenerHandler = captureForAttachedTab;
                iframeStateScrollHandler = function() {
                    if (iframeStateScrollTimer) return;
                    iframeStateScrollTimer = setTimeout(function() {
                        iframeStateScrollTimer = null;
                        captureForAttachedTab();
                    }, 120);
                };
                win.addEventListener('beforeunload', iframeStateListenerHandler);
                win.addEventListener('pagehide', iframeStateListenerHandler);
                win.addEventListener('scroll', iframeStateScrollHandler, { passive: true });
            } catch (e) {
                iframeStateListenerWindow = null;
                iframeStateListenerHandler = null;
                iframeStateListenerTabId = null;
                iframeStateScrollHandler = null;
                if (iframeStateScrollTimer) {
                    clearTimeout(iframeStateScrollTimer);
                    iframeStateScrollTimer = null;
                }
            }
        }

        function initTabs() {
            let migratedTitles = false;
            const saved = localStorage.getItem(TABS_STORAGE_KEY);
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    tabs = data.tabs || [];
                    activeTabIndex = data.activeTabIndex || 0;
                    nextTabId = data.nextTabId || tabs.length + 1;
                    // Clean up expired blobs + migrate filename titles to clean names
                    tabs.forEach(t => {
                        if (t.url && t.url.startsWith('blob:')) {
                            t.url = '';
                            t.title = 'New Tab';
                        }
                        if (!t.resumeStates || typeof t.resumeStates !== 'object' || Array.isArray(t.resumeStates)) {
                            t.resumeStates = {};
                        } else {
                            const cleanedStates = {};
                            Object.keys(t.resumeStates).forEach(urlKey => {
                                const state = t.resumeStates[urlKey];
                                if (!state || typeof state !== 'object') return;
                                const key = normalizeResumeStateUrl(urlKey);
                                if (!key) return;
                                cleanedStates[key] = {
                                    scrollY: Math.max(0, Math.round(Number(state.scrollY) || 0)),
                                    slideId: state.slideId ? String(state.slideId) : '',
                                    ts: typeof state.ts === 'number' ? state.ts : 0
                                };
                            });
                            t.resumeStates = cleanedStates;
                            pruneTabResumeStates(t);
                        }
                        if (t.title && /\.(html?|pdf|png|jpe?g|gif|svg|txt|json|xml|md|css|js)$/i.test(t.title)) {
                            t.title = t.title.replace(/\.[^.]+$/, '');
                        }
                    });
                    if (tabs.length === 0) tabs = createDefaultTabs();
                    if (activeTabIndex >= tabs.length) activeTabIndex = 0;
                } catch (e) {
                    tabs = createDefaultTabs();
                    activeTabIndex = 0;
                }
            } else {
                // Migration: import old single-URL storage into first tab
                tabs = createDefaultTabs();
                const oldUrl = localStorage.getItem(STORAGE_KEY);
                if (oldUrl && !oldUrl.startsWith('blob:')) {
                    tabs[0].url = toRelativePath(oldUrl);
                    tabs[0].title = getTabTitleFromUrl(oldUrl);
                }
                activeTabIndex = 0;
            }
            migratedTitles = migrateStoredTabTitles();
            renderTabList();
            activateTab(activeTabIndex, false);
            if (migratedTitles) saveTabs();
        }

        function createDefaultTabs() {
            const result = [];
            for (let i = 0; i < DEFAULT_TAB_COUNT; i++) {
                result.push({ id: nextTabId++, url: '', title: 'New Tab' });
            }
            return result;
        }

        function saveTabs() {
            localStorage.setItem(TABS_STORAGE_KEY, JSON.stringify({
                tabs: tabs,
                activeTabIndex: activeTabIndex,
                nextTabId: nextTabId
            }));
        }

        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // Tab drag-and-drop reordering
        let dragSourceIndex = null;

        function onTabDragStart(e, index) {
            dragSourceIndex = index;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', index);
            requestAnimationFrame(() => {
                e.target.closest('.tab-item').classList.add('dragging');
            });
        }

        function onTabDragOver(e, index) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            if (dragSourceIndex === null || dragSourceIndex === index) return;
            // Clear all indicators
            document.querySelectorAll('.tab-item').forEach(el => el.classList.remove('drag-above', 'drag-below'));
            const item = e.target.closest('.tab-item');
            if (!item) return;
            const rect = item.getBoundingClientRect();
            if (e.clientY < rect.top + rect.height / 2) {
                item.classList.add('drag-above');
            } else {
                item.classList.add('drag-below');
            }
        }

        function onTabDrop(e, index) {
            e.preventDefault();
            if (dragSourceIndex === null || dragSourceIndex === index) return;
            const item = e.target.closest('.tab-item');
            if (!item) return;
            const rect = item.getBoundingClientRect();
            let targetIndex = e.clientY < rect.top + rect.height / 2 ? index : index + 1;

            const [movedTab] = tabs.splice(dragSourceIndex, 1);
            if (targetIndex > dragSourceIndex) targetIndex--;
            tabs.splice(targetIndex, 0, movedTab);

            // Adjust activeTabIndex to follow the active tab
            if (activeTabIndex === dragSourceIndex) {
                activeTabIndex = targetIndex;
            } else if (dragSourceIndex < activeTabIndex && targetIndex >= activeTabIndex) {
                activeTabIndex--;
            } else if (dragSourceIndex > activeTabIndex && targetIndex <= activeTabIndex) {
                activeTabIndex++;
            }

            dragSourceIndex = null;
            renderTabList();
            saveTabs();
        }

        function onTabDragEnd() {
            dragSourceIndex = null;
            document.querySelectorAll('.tab-item').forEach(el => {
                el.classList.remove('dragging', 'drag-above', 'drag-below');
            });
        }

        function onTabItemClick(event, index) {
            if (event && event.defaultPrevented) return;
            if (event && event.target && event.target.closest && event.target.closest('.tab-delete')) return;
            activateTab(index);
        }

        function onTabDeletePointerDown(event) {
            if (!event) return;
            event.stopPropagation();
        }

        function onTabDeleteClick(event, index) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
                if (typeof event.stopImmediatePropagation === 'function') {
                    event.stopImmediatePropagation();
                }
            }
            deleteTab(index);
        }

        function renderTabList() {
            const list = document.getElementById('tabList');
            if (!list) return;
            const showDelete = tabs.length > 1;
            list.innerHTML = tabs.map((tab, i) => {
                const isActive = i === activeTabIndex;
                const icon = tab.url ? 'ðŸŒ' : 'âž•';
                const title = escapeHtml(tab.title || 'New Tab');
                return '<div class="tab-item' + (isActive ? ' active' : '') + '"'
                    + ' draggable="true"'
                    + ' onclick="onTabItemClick(event,' + i + ')"'
                    + ' ondragstart="onTabDragStart(event,' + i + ')"'
                    + ' ondragover="onTabDragOver(event,' + i + ')"'
                    + ' ondrop="onTabDrop(event,' + i + ')"'
                    + ' ondragend="onTabDragEnd()"'
                    + '>'
                    + '<span class="tab-item-icon">' + icon + '</span>'
                    + '<span class="tab-item-title" title="' + escapeHtml(tab.url || '') + '">' + title + '</span>'
                    + (showDelete ? '<button class="tab-delete" type="button" draggable="false" onmousedown="onTabDeletePointerDown(event)" onpointerdown="onTabDeletePointerDown(event)" ontouchstart="onTabDeletePointerDown(event)" onclick="onTabDeleteClick(event,' + i + ')" title="Close tab">&times;</button>' : '')
                    + '</div>';
            }).join('');
            const addBtn = document.getElementById('addTabBtn');
            if (addBtn) addBtn.disabled = tabs.length >= MAX_TABS;
        }

        function activateTab(index, save) {
            if (save === undefined) save = true;
            if (save) {
                captureActiveTabResumeState();
            }
            activeTabIndex = index;
            const tab = tabs[index];
            if (!tab) return;

            const frame = document.getElementById('contentFrame');
            const urlInput = document.getElementById('urlInput');

            if (tab.url) {
                const loadableUrl = resolveUrl(tab.url);
                urlInput.value = tab.url;
                requestTabResumeRestore(tab, loadableUrl);
                // Use the unified URL loader for user tab clicks so iframe-block/auth
                // fallback rules are applied consistently (open-in-new-tab when needed).
                if (save) {
                    loadUrl(false, false);
                } else {
                    // During startup restore, avoid popup attempts without user gesture.
                    showPageSwitchBlack();
                    frame.src = loadableUrl;
                    frame.style.display = 'block';
                    document.getElementById('emptyState').style.display = 'none';
                    document.getElementById('iframeError').style.display = 'none';
                    hideExternalOpenState();
                    lastBrowseUrl = loadableUrl;
                }
            } else {
                pendingTabResumeRestore = null;
                urlInput.value = '';
                frame.style.display = 'none';
                frame.src = 'about:blank';
                hidePageSwitchBlack(true);
                document.getElementById('emptyState').style.display = 'flex';
                document.getElementById('iframeError').style.display = 'none';
                hideExternalOpenState();
            }

            renderTabList();
            if (save) saveTabs();
        }

        function addTab() {
            if (tabs.length >= MAX_TABS) return;
            tabs.push({ id: nextTabId++, url: '', title: 'New Tab' });
            activateTab(tabs.length - 1);
            document.getElementById('urlInput').focus();
        }

        function deleteTab(index) {
            if (tabs.length <= 1) return;
            tabs.splice(index, 1);
            if (activeTabIndex >= tabs.length) {
                activeTabIndex = tabs.length - 1;
            } else if (activeTabIndex > index) {
                activeTabIndex--;
            }
            activateTab(activeTabIndex);
        }

        function toggleTabPanel() {
            setTabPanelVisibility(!tabPanelVisible);
        }

        function setTabPanelVisibility(visible) {
            const panel = document.getElementById('tabPanel');
            const btn = document.getElementById('tabPanelToggle');
            tabPanelVisible = !!visible;
            if (panel) panel.classList.toggle('visible', tabPanelVisible);
            if (btn) btn.classList.toggle('active', tabPanelVisible);
        }

        function updateActiveTabTitle(title) {
            if (tabs[activeTabIndex] && title) {
                tabs[activeTabIndex].title = title;
                renderTabList();
                saveTabs();
            }
        }

        function normalizeTitle(value) {
            return String(value || '').trim().toLowerCase();
        }

        function prettifyTitleToken(token) {
            if (!token) return '';
            let text = token;
            try { text = decodeURIComponent(text); } catch (e) {}

            text = text.replace(/[?#].*$/, '');
            text = text.replace(/\.[^.\/]+$/, '');
            text = text.replace(/[_\-+]+/g, ' ');
            text = text.replace(/\s+/g, ' ').trim();
            if (!text) return '';

            const acronyms = new Set(['AI', 'API', 'CPU', 'CSS', 'GPU', 'HTML', 'JS', 'JSON', 'PDF', 'PPT', 'UI', 'URL', 'UX', 'XML']);
            return text.split(' ').map(part => {
                const alnum = part.replace(/[^a-zA-Z0-9]/g, '');
                const upper = alnum.toUpperCase();
                if (acronyms.has(upper)) return upper;
                if (/^[A-Z0-9]{2,}$/.test(part)) return part;
                return part.charAt(0).toUpperCase() + part.slice(1);
            }).join(' ');
        }

        function getHttpFallbackHostTitle(hostname) {
            const host = String(hostname || '').replace(/^www\./i, '');
            if (host === 'github.com') return 'GitHub';
            return host;
        }

        function migrateStoredTabTitles() {
            let changed = false;
            tabs.forEach(tab => {
                if (!tab || !tab.url) return;
                const suggested = getTabTitleFromUrl(tab.url);
                if (!suggested) return;

                const current = String(tab.title || '').trim();
                if (!current || current === 'New Tab') {
                    tab.title = suggested;
                    changed = true;
                    return;
                }

                let legacyHost = '';
                try {
                    if (/^https?:\/\//i.test(tab.url)) {
                        legacyHost = new URL(resolveUrl(tab.url)).hostname.replace(/^www\./i, '');
                    }
                } catch (e) {}

                const currentNorm = normalizeTitle(current);
                const suggestedNorm = normalizeTitle(suggested);
                const legacyHostNorm = normalizeTitle(legacyHost);
                if (legacyHostNorm && currentNorm === legacyHostNorm && currentNorm !== suggestedNorm) {
                    tab.title = suggested;
                    changed = true;
                }
            });
            return changed;
        }

        // Fallback title from URL â€” real title comes from page <title> via frame load handler
        function getTabTitleFromUrl(url) {
            if (!url) return 'New Tab';
            try {
                if (/^https?:\/\//.test(url)) {
                    const parsed = new URL(url);
                    const segments = (parsed.pathname || '').split('/').filter(Boolean);
                    let candidate = segments.length ? segments[segments.length - 1] : '';
                    if (/^index\.[a-z0-9]+$/i.test(candidate) && segments.length > 1) {
                        candidate = segments[segments.length - 2];
                    }
                    const fromPath = prettifyTitleToken(candidate);
                    if (fromPath) return fromPath;
                    return getHttpFallbackHostTitle(parsed.hostname);
                }
                // For file/relative paths, use filename without extension as readable placeholder
                const decoded = decodeURIComponent(url.replace(/^file:\/\/\//, ''));
                const parts = decoded.replace(/\\/g, '/').split('/');
                const filename = parts[parts.length - 1] || url;
                const pretty = prettifyTitleToken(filename);
                return pretty || filename.replace(/\.[^.]+$/, '') || filename;
            } catch (e) {
                return url.length > 40 ? url.substring(0, 40) + '...' : url;
            }
        }

        function exportTabs() {
            const exportData = tabs.map(t => ({ url: t.url || '', title: t.title || 'New Tab' }));
            const json = JSON.stringify(exportData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'ai_cafe_tabs_' + new Date().toISOString().slice(0, 10) + '.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        }

        function importTabs(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (!Array.isArray(imported)) { alert('Invalid format: expected a JSON array.'); return; }
                    const existingUrls = new Set(tabs.map(t => (t.url || '').trim().toLowerCase()));
                    let added = 0;
                    let skipped = 0;
                    imported.forEach(function(item) {
                        const url = (item.url || '').trim();
                        const title = item.title || getTabTitleFromUrl(url) || 'New Tab';
                        if (!url) return; // skip empty URLs
                        if (existingUrls.has(url.toLowerCase())) { skipped++; return; }
                        if (tabs.length >= MAX_TABS) return;
                        tabs.push({ id: nextTabId++, url: url, title: title });
                        existingUrls.add(url.toLowerCase());
                        added++;
                    });
                    renderTabList();
                    saveTabs();
                    alert('Import done: ' + added + ' tab(s) added, ' + skipped + ' duplicate(s) skipped.');
                } catch (err) {
                    alert('Import failed: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // reset so same file can be re-imported
        }

        function clearAllTabs() {
            if (!confirm('Clear all tabs and reset to defaults?')) return;
            localStorage.removeItem(TABS_STORAGE_KEY);
            localStorage.removeItem(STORAGE_KEY);
            localStorage.removeItem(STORAGE_HOME_KEY);
            nextTabId = 1;
            tabs = createDefaultTabs();
            activeTabIndex = 0;
            renderTabList();
            activateTab(0);
            toggleSettingsMenu();
        }
        
        function openLocalFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Determine MIME type from file extension
            const ext = file.name.split('.').pop().toLowerCase();
            const mimeTypes = {
                'html': 'text/html',
                'htm': 'text/html',
                'pdf': 'application/pdf',
                'png': 'image/png',
                'jpg': 'image/jpeg',
                'jpeg': 'image/jpeg',
                'gif': 'image/gif',
                'svg': 'image/svg+xml',
                'webp': 'image/webp',
                'txt': 'text/plain',
                'json': 'application/json',
                'xml': 'application/xml'
            };
            const mimeType = mimeTypes[ext] || file.type || 'application/octet-stream';
            
            // For HTML files in the same directory as the presenter, load directly via file:// URL
            // This allows relative paths (like Images/...) to work correctly
            if ((ext === 'html' || ext === 'htm') && window.location.protocol === 'file:') {
                // Get the presenter's directory path
                const presenterPath = window.location.href;
                const baseDir = presenterPath.substring(0, presenterPath.lastIndexOf('/') + 1);
                
                // Construct the file:// URL for the selected HTML file (assuming same directory)
                const fileUrl = baseDir + encodeURIComponent(file.name).replace(/%20/g, '%20');
                
                // Store relative path in tab
                const relativePath = toRelativePath(fileUrl);
                document.getElementById('urlInput').value = relativePath;
                if (tabs[activeTabIndex]) {
                    tabs[activeTabIndex].url = relativePath;
                    tabs[activeTabIndex].title = file.name;
                    renderTabList();
                    saveTabs();
                }

                // Load directly via file:// URL
                showPageSwitchBlack();
                document.getElementById('contentFrame').src = fileUrl;
                localStorage.setItem(STORAGE_KEY, relativePath);
                navigationHistory.push(fileUrl);
                updateBackButton();

                // If capture active, switch to browser view
                if (screenStream) {
                    lastBrowseUrl = fileUrl;
                    switchView('browse');
                } else {
                    document.getElementById('contentFrame').style.display = 'block';
                    document.getElementById('emptyState').style.display = 'none';
                    document.getElementById('iframeError').style.display = 'none';
                    hideExternalOpenState();
                }

                // Reset file input for re-selection of same file
                event.target.value = '';
                return;
            }
            
            // For other files (PDFs, images, etc.), use blob URL as before
            const reader = new FileReader();
            reader.onload = function(e) {
                // Create a blob URL with correct MIME type
                const blob = new Blob([e.target.result], { type: mimeType });
                const blobUrl = URL.createObjectURL(blob);
                
                // Load the blob URL
                showPageSwitchBlack();
                document.getElementById('contentFrame').src = blobUrl;

                // Show file name in URL bar and update tab
                document.getElementById('urlInput').value = 'ðŸ“‚ ' + file.name;
                if (tabs[activeTabIndex]) {
                    tabs[activeTabIndex].url = blobUrl;
                    tabs[activeTabIndex].title = file.name;
                    renderTabList();
                    saveTabs();
                }

                // If capture active, switch to browser view
                if (screenStream) {
                    lastBrowseUrl = blobUrl;
                    switchView('browse');
                } else {
                    document.getElementById('contentFrame').style.display = 'block';
                    document.getElementById('emptyState').style.display = 'none';
                    document.getElementById('iframeError').style.display = 'none';
                    hideExternalOpenState();
                }

                // Note: Don't save blob URLs as home - they expire after refresh
            };
            
            // Read binary files as ArrayBuffer, text files as Text
            if (['pdf', 'png', 'jpg', 'jpeg', 'gif', 'webp', 'svg'].includes(ext)) {
                reader.readAsArrayBuffer(file);
            } else {
                reader.readAsText(file);
            }
            
            // Reset file input for re-selection of same file
            event.target.value = '';
        }
        
        // clearMemory removed â€” replaced by clearAllTabs()
        
        // === Screen Capture ===
        let screenStream = null;
        let lastBrowseUrl = ''; // Remembers the last browsed URL to restore after capture
        let currentView = 'browse'; // 'browse' or 'present'
        let browseDrawActive = false; // Hold-D-to-draw overlay in browse mode

        function getCaptureKeepaliveVideo() {
            let keepalive = document.getElementById('screenVideoKeepalive');
            if (keepalive) return keepalive;

            keepalive = document.createElement('video');
            keepalive.id = 'screenVideoKeepalive';
            keepalive.muted = true;
            keepalive.autoplay = true;
            keepalive.playsInline = true;
            keepalive.style.position = 'fixed';
            keepalive.style.left = '-10000px';
            keepalive.style.top = '-10000px';
            keepalive.style.width = '1px';
            keepalive.style.height = '1px';
            keepalive.style.opacity = '0';
            keepalive.style.pointerEvents = 'none';
            document.body.appendChild(keepalive);
            return keepalive;
        }

        async function startCaptureKeepalive() {
            if (!screenStream) return;
            const keepalive = getCaptureKeepaliveVideo();
            if (keepalive.srcObject !== screenStream) {
                keepalive.srcObject = screenStream;
            }
            try {
                await keepalive.play();
            } catch (e) {
                // Ignore autoplay restrictions in background keepalive
            }
        }

        function stopCaptureKeepalive() {
            const keepalive = document.getElementById('screenVideoKeepalive');
            if (!keepalive) return;
            try {
                keepalive.srcObject = null;
            } catch (e) {
                // Ignore teardown errors
            }
        }

        async function ensureCaptureVideoSynced() {
            if (!screenStream) return;

            const video = document.getElementById('screenVideo');
            const tracks = screenStream.getVideoTracks ? screenStream.getVideoTracks() : [];
            const videoTrack = tracks.length > 0 ? tracks[0] : null;

            if (!videoTrack || videoTrack.readyState !== 'live') return;

            if (video.srcObject !== screenStream) {
                video.srcObject = screenStream;
            }

            try {
                await video.play();
            } catch (e) {
                // Browser may block play() without a fresh user gesture
            }

            const t0 = Number(video.currentTime) || 0;
            await new Promise(resolve => setTimeout(resolve, 140));
            const t1 = Number(video.currentTime) || 0;

            // If frame time does not move, rebind the stream to force decoder refresh.
            if (t1 <= t0) {
                try {
                    video.srcObject = null;
                    await new Promise(resolve => setTimeout(resolve, 40));
                    video.srcObject = screenStream;
                    await video.play();
                } catch (e) {
                    console.log('Capture resync fallback failed:', e);
                }
            }
        }

        // Toggle present mode on/off
        function togglePresent() {
            if (!screenStream) {
                // No capture â†’ start it
                startScreenCapture();
            } else if (currentView === 'present') {
                // Already presenting â†’ stop capture, go to browse
                stopScreenCapture();
            } else {
                // Capture running but in browse view â†’ switch to present (no re-pick)
                switchView('present');
            }
        }

        // Toggle browse view
        function toggleBrowse() {
            if (currentView === 'browse') {
                toggleTabPanel();
            } else {
                switchView('browse');
            }
        }

        // Switch between browse and present views (without stopping capture)
        function switchView(view) {
            const video = document.getElementById('screenVideo');
            const captureContainer = document.getElementById('screenContainer');
            const frame = document.getElementById('contentFrame');
            const pptContainer = document.getElementById('pptContainer');

            // Clean up browse draw overlay if active
            if (browseDrawActive) {
                browseDrawActive = false;
                browseDrawFading = false;
                captureContainer.classList.remove('draw-overlay');
                captureContainer.style.top = '';
                clearDrawing();
            }

            // Enforce per-mode draw defaults (completely decoupled)
            if (view === 'browse') {
                // Browse default: Draw OFF
                if (drawMode) toggleDrawMode();
                drawFadeTime = browseFadeTime;
            } else {
                // Present default: Draw ON
                drawFadeTime = presentFadeTime;
                if (!drawMode) toggleDrawMode();
            }
            syncFadeUI();

            // Hide all content layers first
            frame.style.display = 'none';
            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('iframeError').style.display = 'none';
            hideExternalOpenState();
            pptContainer.style.display = 'none';
            captureContainer.classList.remove('active');
            video.style.display = 'none';

            currentView = view;
            applyShapeOverrideForCurrentMode();
            setPptPollingActive(view === 'present');

            if (view === 'present') {
                // Hide tab panel in present mode
                setTabPanelVisibility(false);

                if (screenStream) {
                    // Primary: show live screen capture
                    stopCaptureKeepalive();
                    captureContainer.classList.add('active');
                    video.style.display = 'block';
                    ensureCaptureVideoSynced();
                    setTimeout(resizeDrawCanvas, 50);
                } else if (pptServerOnline) {
                    // Fallback: no capture but PPT server online â†’ show slide images
                    pptContainer.style.display = 'flex';
                    if (Number.isFinite(pptLastKnownSlide) && pptLastRenderedSlide !== pptLastKnownSlide) {
                        fetchSlideImage(pptLastKnownSlide);
                    }
                    checkPptConnection(true);
                } else {
                    // No capture, no PPT server â†’ show server hint
                    pptContainer.style.display = 'flex';
                    updateServerHint(true);
                }
            } else {
                // Browse view â€” restore active tab
                if (screenStream) {
                    startCaptureKeepalive();
                }
                const tab = tabs[activeTabIndex];
                const url = tab && tab.url ? resolveUrl(tab.url) : '';
                if (url) {
                    document.getElementById('urlInput').value = tab.url;
                    if (!frame.src || frame.src === 'about:blank') {
                        showPageSwitchBlack();
                        frame.src = url;
                    }
                    frame.style.display = 'block';
                } else {
                    hidePageSwitchBlack(true);
                    document.getElementById('emptyState').style.display = 'flex';
                }
                // Auto-open tab panel in browse mode
                setTabPanelVisibility(true);

                // Recapture keyboard focus so D/F/PPT shortcuts work immediately
                var cp = document.getElementById('contentPanel');
                if (cp) cp.focus({ preventScroll: true });
            }
            updateModeButtons();
        }

        // Update mode buttons to reflect current state
        function updateModeButtons() {
            const presentBtn = document.getElementById('presentBtn');
            const browseBtn = document.getElementById('browseBtn');
            const zoomBtn = document.getElementById('zoomToggle');
            const presentText = presentBtn.querySelector('.status-text');

            // --- Present button ---
            if (currentView === 'present' && screenStream) {
                // Active: capturing with live screen feed
                presentBtn.className = 'mode-btn active';
                presentBtn.title = 'Click to stop capture';
                presentText.textContent = '\uD83D\uDCFA Capturing';
            } else if (currentView === 'present' && !screenStream) {
                // Active but showing PPT fallback (no capture stream)
                presentBtn.className = 'mode-btn active';
                presentBtn.title = 'Click to start screen capture';
                presentText.textContent = '\uD83D\uDCFA Capture';
            } else if (screenStream) {
                // Capture running but in browse view (background)
                presentBtn.className = 'mode-btn background';
                presentBtn.title = 'Click to switch to capture view';
                presentText.textContent = '\uD83D\uDCFA Capturing';
            } else {
                // No capture active
                presentBtn.className = 'mode-btn';
                presentBtn.title = 'Click to start screen capture';
                presentText.textContent = '\uD83D\uDCFA Capture';
            }

            // --- Browse button ---
            if (currentView === 'browse') {
                browseBtn.className = 'mode-btn active';
                browseBtn.title = 'Browse view (active) - click for Home';
            } else {
                browseBtn.className = 'mode-btn';
                browseBtn.title = 'Click to switch to browse view';
            }

            // --- Zoom: enabled when capture stream exists ---
            zoomBtn.disabled = !screenStream;

            // --- Draw group ---
            const drawGroup = document.getElementById('drawGroup');
            drawGroup.classList.remove('group-disabled', 'group-draw-disabled');
            if (!drawMode) {
                // Draw off: draw button stays clickable (both browse & present)
                drawGroup.classList.add('group-draw-disabled');
            }

            // --- Browse controls: disabled when not in browse view ---
            const browseControls = document.querySelector('.browse-controls');
            if (currentView === 'browse') {
                browseControls.classList.remove('group-disabled');
            } else {
                browseControls.classList.add('group-disabled');
            }

            // --- PPT nav buttons: enabled when PPT server is online ---
            updatePptButtonsState();
            updateToolbarLayout();
        }
        
        async function startScreenCapture() {
            try {
                // Save current browse URL before switching to capture
                const frame = document.getElementById('contentFrame');
                const currentUrl = document.getElementById('urlInput').value;
                if (currentUrl && !currentUrl.startsWith('blob:')) {
                    lastBrowseUrl = currentUrl;
                } else if (frame.src && frame.src !== 'about:blank' && !frame.src.startsWith('blob:')) {
                    lastBrowseUrl = frame.src;
                }

                // Request high-quality screen capture
                screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        displaySurface: "monitor",
                        cursor: "always",
                        // Request high resolution for sharp capture
                        width: { ideal: 3840 },
                        height: { ideal: 2160 },
                        frameRate: { ideal: 30, max: 30 }
                    },
                    audio: false,
                    // Prefer current tab for browser captures
                    preferCurrentTab: false,
                    selfBrowserSurface: "exclude"
                });
                
                const video = document.getElementById('screenVideo');
                const container = document.getElementById('screenContainer');
                video.srcObject = screenStream;
                ensureCaptureVideoSynced();
                stopCaptureKeepalive();
                
                // Show container with video, hide other content
                container.classList.add('active');
                video.style.display = 'block';
                document.getElementById('contentFrame').style.display = 'none';
                document.getElementById('emptyState').style.display = 'none';
                document.getElementById('iframeError').style.display = 'none';
                hideExternalOpenState();
                document.getElementById('pptContainer').style.display = 'none';

                // Initialize/resize drawing canvas for the capture
                setTimeout(resizeDrawCanvas, 100);

                // Enable draw mode by default in capture mode
                setTimeout(() => {
                    if (!drawMode) {
                        toggleDrawMode();
                    }
                }, 150);

                // Switch to Present Mode
                showPresentMode();

                // Handle stream ending (user stops sharing)
                screenStream.getVideoTracks()[0].addEventListener('ended', stopScreenCapture);

            } catch (err) {
                console.log('Screen capture not started:', err?.name || 'unknown');
                // User cancelled screen picker â†’ fall to present mode (PPT fallback or server hint)
                if (currentView !== 'present') {
                    switchView('present');
                }
            }
        }
        
        // Switch capture source without leaving capture mode
        async function switchCaptureSource() {
            try {
                // Request new screen capture
                const newStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        displaySurface: "monitor",
                        cursor: "always",
                        width: { ideal: 3840 },
                        height: { ideal: 2160 },
                        frameRate: { ideal: 30, max: 30 }
                    },
                    audio: false,
                    preferCurrentTab: false,
                    selfBrowserSurface: "exclude"
                });

                // Stop old stream
                if (screenStream) {
                    screenStream.getTracks().forEach(track => track.stop());
                }

                // Connect new stream
                screenStream = newStream;
                const video = document.getElementById('screenVideo');
                video.srcObject = screenStream;
                ensureCaptureVideoSynced();
                if (currentView === 'browse') {
                    startCaptureKeepalive();
                }

                // Clear drawings for fresh start
                clearDrawing();
                setTimeout(resizeDrawCanvas, 100);

                // Handle new stream ending
                screenStream.getVideoTracks()[0].addEventListener('ended', stopScreenCapture);

                updateCaptureStatus('\uD83D\uDCFA Capturing...', '');
            } catch (err) {
                // User cancelled the picker - keep current capture
                console.log('Switch capture cancelled:', err?.name || 'unknown');
            }
        }

        // (loadUrlFromCapture removed - loadUrl handles both modes now)

        // Zoom toggle state
        let captureZoom100 = false;
        
        function toggleCaptureZoom() {
            captureZoom100 = !captureZoom100;
            const container = document.getElementById('screenContainer');
            const btn = document.getElementById('zoomToggle');
            
            if (captureZoom100) {
                // Currently at 100%, button shows what you GET: Fit
                container.classList.add('zoom-100');
                btn.textContent = '\uD83D\uDD0D Fit';
                btn.title = 'Switch to Fit mode';
            } else {
                // Currently at Fit, button shows what you GET: 100%
                container.classList.remove('zoom-100');
                btn.textContent = '\uD83D\uDD0D 100%';
                btn.title = 'Switch to 100% zoom (native resolution)';
            }
        }
        
        function stopScreenCapture() {
            if (screenStream) {
                screenStream.getTracks().forEach(track => track.stop());
                screenStream = null;
            }

            const video = document.getElementById('screenVideo');
            const container = document.getElementById('screenContainer');
            video.srcObject = null;
            video.style.display = 'none';
            container.classList.remove('active');
            stopCaptureKeepalive();

            // Clear and disable draw mode
            if (drawMode) {
                toggleDrawMode();
            }
            clearDrawing();

            // Clean up capture-based PPT overlays
            document.getElementById('pptClickZones').classList.remove('active');
            video.classList.remove('ppt-control');

            // Switch back to Browse Mode
            showBrowseMode();
            
            // Auto-restore active tab URL
            const tab = tabs[activeTabIndex];
            const urlToRestore = tab && tab.url ? resolveUrl(tab.url) : '';
            if (urlToRestore && !urlToRestore.startsWith('blob:')) {
                document.getElementById('urlInput').value = tab.url;
                const frame = document.getElementById('contentFrame');
                if (frame.src && frame.src === urlToRestore) {
                    frame.style.display = 'block';
                } else {
                    showPageSwitchBlack();
                    frame.src = urlToRestore;
                    frame.style.display = 'block';
                }
                document.getElementById('emptyState').style.display = 'none';
                document.getElementById('iframeError').style.display = 'none';
                hideExternalOpenState();
            } else {
                hidePageSwitchBlack(true);
                document.getElementById('emptyState').style.display = 'flex';
                hideExternalOpenState();
            }
        }
        
        // === Toolbar State Updates (unified toolbar) ===
        function showBrowseMode() {
            currentView = 'browse';
            setTabPanelVisibility(true);
            setPptPollingActive(false);
            updateModeButtons();
        }

        function showPresentMode() {
            currentView = 'present';
            setTabPanelVisibility(false);
            setPptPollingActive(true);
            updateModeButtons();
        }
        
        function updateCaptureStatus(message, type) {
            // Update mode buttons to reflect any state changes
            updateModeButtons();
        }
        
        function updatePptButtonsState() {
            const isEnabled = pptServerOnline;
            document.getElementById('prevBtn').disabled = !isEnabled;
            document.getElementById('nextBtn').disabled = !isEnabled;
            document.getElementById('startBtn').disabled = !isEnabled;
            document.getElementById('startCurrentBtn').disabled = !isEnabled;
            document.getElementById('escBtn').disabled = !isEnabled;

            // F5 glows when slideshow IS running, ESC glows when slideshow is NOT running
            const startBtn = document.getElementById('startBtn');
            const startCurrentBtn = document.getElementById('startCurrentBtn');
            const escBtn = document.getElementById('escBtn');
            startBtn.classList.toggle('slideshow-active', pptSlideshowRunning);
            startCurrentBtn.classList.toggle('slideshow-active', pptSlideshowRunning);
            escBtn.classList.toggle('slideshow-active', isEnabled && !pptSlideshowRunning);

            // Update PPT server status button
            const pptBtn = document.getElementById('pptServerBtn');
            const pptText = pptBtn.querySelector('.status-text');
            if (isEnabled) {
                pptBtn.classList.add('active');
                pptBtn.classList.remove('background');
                pptBtn.title = 'PowerPoint server: online â€” click to stop';
                pptText.textContent = '\uD83C\uDFAF PPT Stop';
            } else {
                pptBtn.classList.remove('active', 'background');
                pptBtn.title = 'PowerPoint server: offline - click for start instructions';
                pptText.textContent = '\uD83C\uDFAF PPT';
            }
        }

        let pptShutdownCooldown = false; // Prevent polling from re-enabling after shutdown

        async function togglePptServer() {
            if (pptServerOnline) {
                serverHintPinned = false;
                // Server is online â†’ shut it down
                let shutdownConfirmed = false;
                try {
                    await ensurePptAuthToken(false); // try to get token, but don't require it
                    const response = await fetch(CONFIG.PPT_SERVER + '/shutdown', {
                        method: 'POST',
                        mode: 'cors',
                        headers: getPptRequestHeaders(true)
                    });
                    shutdownConfirmed = response.ok;
                } catch (e) {
                    console.warn('PPT shutdown request failed:', e);
                }
                if (!shutdownConfirmed) {
                    await checkPptConnection(true);
                    updateModeButtons();
                    return;
                }
                pptServerOnline = false;
                pptSlideshowRunning = false;
                // Cooldown: ignore next few polls so stale responses don't re-enable
                pptShutdownCooldown = true;
                setTimeout(() => { pptShutdownCooldown = false; }, 8000);
                updateModeButtons();
            } else {
                serverHintPinned = true;
                // Server is offline â†’ show start instructions
                // Hide all content layers first
                document.getElementById('contentFrame').style.display = 'none';
                document.getElementById('emptyState').style.display = 'none';
                document.getElementById('iframeError').style.display = 'none';
                hideExternalOpenState();
                document.getElementById('screenContainer').classList.remove('active');
                document.getElementById('screenVideo').style.display = 'none';
                // Show pptContainer with hint
                document.getElementById('pptContainer').style.display = 'flex';
                document.getElementById('serverHint').classList.add('show');
            }
        }
        
        // === Settings Dropdown ===
        function toggleSettingsMenu() {
            const dropdown = document.getElementById('settingsDropdown');
            dropdown.classList.toggle('show');
        }
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            const dropdown = document.getElementById('settingsDropdown');
            const settingsBtn = e.target.closest('[onclick="toggleSettingsMenu()"]');
            if (!settingsBtn && !e.target.closest('.dropdown-menu')) {
                dropdown.classList.remove('show');
            }
        });
        
        // (togglePptServer removed - PPT is now auto-detected, not a mode)
        
        // === PowerPoint Control ===
        let pptServerChecked = false;
        let pptServerOnline = false;
        let pptSlideshowRunning = false;
        let pptPollingInterval = null;
        let serverHintPinned = false;
        let pptImageRetryTimer = null;
        const PPT_CLIENT_ID = 'ai-cafe-presenter';
        let pptAuthToken = '';
        let pptLastKnownSlide = null;
        let pptLastRenderedSlide = null;

        function getPptRequestHeaders(includeToken = true) {
            const headers = { 'X-PPT-Client': PPT_CLIENT_ID };
            if (includeToken && pptAuthToken) {
                headers['X-PPT-Token'] = pptAuthToken;
            }
            return headers;
        }

        async function ensurePptAuthToken(forceRefresh = false) {
            if (!forceRefresh && pptAuthToken) {
                return true;
            }

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 2000);
                const response = await fetch(CONFIG.PPT_SERVER + '/auth-token', {
                    method: 'GET',
                    mode: 'cors',
                    headers: getPptRequestHeaders(false),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                if (!response.ok) {
                    return false;
                }

                const data = await response.json();
                if (data && data.success && data.authClient === PPT_CLIENT_ID && typeof data.authToken === 'string' && data.authToken.length > 0) {
                    pptAuthToken = data.authToken;
                    return true;
                }
            } catch (e) {}

            return false;
        }

        function schedulePptImageRetry() {
            if (pptImageRetryTimer) return;
            pptImageRetryTimer = setTimeout(() => {
                pptImageRetryTimer = null;
                if (currentView === 'present' && !screenStream && pptServerOnline) {
                    checkPptConnection(true);
                }
            }, 1200);
        }

        function setPptPollingActive(active) {
            if (active) {
                checkPptConnection(true);
                startPptPolling();
                return;
            }
            stopPptPolling();
        }
        
        function startPptPolling() {
            // Stop any existing polling
            stopPptPolling();
            // Auto-detect PPT server every 5 seconds
            pptPollingInterval = setInterval(() => {
                checkPptConnection();
            }, 5000);
        }
        
        function stopPptPolling() {
            if (pptPollingInterval) {
                clearInterval(pptPollingInterval);
                pptPollingInterval = null;
            }
        }
        
        function copyBatPath() {
            const path = CONFIG.PPT_CONTROLLER_PATH;
            const link = document.querySelector('.server-hint .file-link');
            if (!link) return;
            const hintSpan = document.getElementById('batPathHint') || link.querySelector('.hint');
            if (!hintSpan) return;
            link.classList.remove('copied');
            copyTextToClipboard(path).then(() => {
                link.classList.add('copied');
                hintSpan.textContent = 'Copied! Press Win+R, paste, Enter';
                setTimeout(() => {
                    link.classList.remove('copied');
                    hintSpan.textContent = 'Click to copy';
                }, 5000);
            }).catch(err => {
                console.error('Could not copy path:', err);
                hintSpan.textContent = 'Copy failed - select manually';
            });
        }

        function copyTextToClipboard(text) {
            if (navigator.clipboard && window.isSecureContext) {
                return navigator.clipboard.writeText(text);
            }
            return new Promise((resolve, reject) => {
                try {
                    const ta = document.createElement('textarea');
                    ta.value = text;
                    ta.setAttribute('readonly', '');
                    ta.style.position = 'fixed';
                    ta.style.top = '-9999px';
                    ta.style.left = '-9999px';
                    document.body.appendChild(ta);
                    ta.focus();
                    ta.select();
                    const copied = document.execCommand('copy');
                    ta.remove();
                    if (copied) resolve();
                    else reject(new Error('execCommand(copy) returned false'));
                } catch (error) {
                    reject(error);
                }
            });
        }

        function dismissServerHint() {
            serverHintPinned = false;
            // Hide the server hint and restore the current view
            document.getElementById('serverHint').classList.remove('show');
            switchView(currentView);
            // Re-check connection after a short delay
            setTimeout(checkPptConnection, 1000);
        }
        
        function updateServerHint(show) {
            const hint = document.getElementById('serverHint');
            if (show && currentView === 'present' && !screenStream) {
                // Once shown, keep instructions pinned until user explicitly presses Done.
                serverHintPinned = true;
            }
            if (serverHintPinned && currentView === 'present') {
                document.getElementById('pptContainer').style.display = 'flex';
                hint.classList.add('show');
                return;
            }
            if (show && currentView === 'present' && !screenStream) {
                hint.classList.add('show');
            } else {
                hint.classList.remove('show');
                // If hint was force-shown (PPT button click), clean up pptContainer
                // Only keep pptContainer visible in present fallback mode
                if (currentView === 'browse') {
                    document.getElementById('pptContainer').style.display = 'none';
                }
            }
        }
        
        async function checkPptConnection(forceImageSync = false) {
            // Skip polling during shutdown cooldown
            if (pptShutdownCooldown) return;

            try {
                if (!pptAuthToken) {
                    await ensurePptAuthToken(false);
                }
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 2000);

                const response = await fetch(CONFIG.PPT_SERVER + '/status', {
                    method: 'GET',
                    mode: 'cors',
                    headers: getPptRequestHeaders(false),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                const data = await response.json();
                pptServerChecked = true;
                pptServerOnline = data.success;
                pptSlideshowRunning = data.slideshowRunning || false;
                updateServerHint(!data.success);
                updateModeButtons();
                if (data.success && data.currentSlide && data.totalSlides) {
                    const currentSlide = Number(data.currentSlide);
                    if (Number.isFinite(currentSlide)) {
                        pptLastKnownSlide = currentSlide;
                    }
                    updateSlideCounter(data.currentSlide, data.totalSlides);
                    const shouldRefreshImage = currentView === 'present' &&
                        !screenStream &&
                        Number.isFinite(pptLastKnownSlide) &&
                        (forceImageSync || pptLastRenderedSlide !== pptLastKnownSlide);
                    if (shouldRefreshImage) {
                        fetchSlideImage(pptLastKnownSlide);
                    }
                }
            } catch (e) {
                pptServerOnline = false;
                pptSlideshowRunning = false;
                updateModeButtons();
                updateServerHint(true);
            }
        }

        // Fetch current slide image from PPT server
        async function fetchSlideImage(slideNum) {
            const img = document.getElementById('pptSlideImage');
            if (!img.dataset.retryBound) {
                img.dataset.retryBound = '1';
                img.addEventListener('error', () => {
                    pptLastRenderedSlide = null;
                    schedulePptImageRetry();
                });
                img.addEventListener('load', () => {
                    if (pptImageRetryTimer) {
                        clearTimeout(pptImageRetryTimer);
                        pptImageRetryTimer = null;
                    }
                });
            }
            const resolvedSlide = Number.isFinite(Number(slideNum))
                ? Number(slideNum)
                : (Number.isFinite(pptLastKnownSlide) ? pptLastKnownSlide : null);
            const url = resolvedSlide
                ? `${CONFIG.PPT_SERVER}/slide-image?slide=${resolvedSlide}&t=${Date.now()}`
                : `${CONFIG.PPT_SERVER}/slide-image?t=${Date.now()}`;
            try {
                img.src = url;
                if (resolvedSlide) {
                    pptLastRenderedSlide = resolvedSlide;
                }
            } catch (e) {
                console.log('Failed to fetch slide image:', e);
            }
        }

        // Update the slide counter overlay
        function updateSlideCounter(current, total) {
            const counter = document.getElementById('pptSlideCounter');
            if (counter) {
                counter.textContent = `Slide ${current} / ${total}`;
            }
        }

        async function pptCommand(action) {
            if (!pptServerOnline) return;

            try {
                await ensurePptAuthToken(false); // try to get token, but don't require it
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 2000);

                let response = await fetch(CONFIG.PPT_SERVER + '/' + action, {
                    method: 'POST',
                    mode: 'cors',
                    headers: getPptRequestHeaders(true),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                if (response.status === 401) {
                    // Auth required or token rotated -> refresh and retry with fresh timeout
                    const refreshed = await ensurePptAuthToken(true);
                    if (refreshed) {
                        const ctrl2 = new AbortController();
                        const tid2 = setTimeout(() => ctrl2.abort(), 2000);
                        response = await fetch(CONFIG.PPT_SERVER + '/' + action, {
                            method: 'POST',
                            mode: 'cors',
                            headers: getPptRequestHeaders(true),
                            signal: ctrl2.signal
                        });
                        clearTimeout(tid2);
                    }
                }

                if (!response.ok) return; // server rejected â€” don't parse as success

                const data = await response.json();
                pptServerOnline = true;
                pptSlideshowRunning = data.slideshowRunning || false;
                updateServerHint(false);

                // Update slide counter and refresh image ONLY in present fallback mode
                if (data.currentSlide) {
                    const currentSlide = Number(data.currentSlide);
                    if (Number.isFinite(currentSlide)) {
                        pptLastKnownSlide = currentSlide;
                    }
                    updateSlideCounter(data.currentSlide, data.totalSlides || '?');
                    if (currentView === 'present' && !screenStream) {
                        fetchSlideImage(pptLastKnownSlide);
                    }
                }
                updateModeButtons();
            } catch (e) {
                console.log('PPT command failed:', e);
                pptServerOnline = false;
                updateModeButtons();
                updateServerHint(true);
            }
        }
        
        function pptNext() {
            pptCommand('next');
        }
        
        function pptPrevious() {
            pptCommand('previous');
        }
        
        function pptStart() {
            pptCommand('start');
        }

        function pptStartCurrent() {
            pptCommand('start-current');
        }
        
        function pptStop() {
            pptCommand('stop');
        }
        
        // === Fullscreen Toggle ===
        function isNativeFullscreen() {
            // Detect F11 native fullscreen (Fullscreen API reports nothing)
            return !document.fullscreenElement &&
                   window.innerHeight >= screen.height &&
                   window.innerWidth >= screen.width;
        }

        function toggleFullscreen() {
            if (document.fullscreenElement) {
                // Exit API fullscreen
                document.exitFullscreen();
            } else if (isNativeFullscreen()) {
                // F11 native fullscreen: enter API fullscreen first (takes over from F11),
                // then exit. Small delay needed so the API fully takes over.
                document.documentElement.requestFullscreen().then(() => {
                    setTimeout(() => document.exitFullscreen(), 100);
                }).catch(() => {
                    console.log('Press F11 to exit native fullscreen');
                });
            } else {
                // Enter API fullscreen
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen error:', err);
                });
            }
        }

        // Listen for fullscreen changes (ESC key exits fullscreen)
        function updateFullscreenButton() {
            const btn = document.getElementById('fullscreenBtn');
            if (document.fullscreenElement || isNativeFullscreen()) {
                btn.title = 'Exit Fullscreen (F)';
            } else {
                btn.title = 'Fullscreen (F)';
            }
        }
        document.addEventListener('fullscreenchange', updateFullscreenButton);
        // Also detect F11 native fullscreen via resize
        window.addEventListener('resize', updateFullscreenButton);

        // Try to add F key listener to iframe for same-origin content
        function setupIframeFullscreenListener() {
            const frame = document.getElementById('contentFrame');
            try {
                if (frame.contentWindow && frame.contentDocument) {
                    frame.contentWindow.addEventListener('keydown', function(e) {
                        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                        // Never steal browser/system shortcuts like Ctrl+F/C/A/V.
                        if (e.ctrlKey || e.metaKey || e.altKey) return;
                        if (e.key === 'f' || e.key === 'F') {
                            e.preventDefault();
                            toggleFullscreen();
                        }
                        // Forward D key to parent for hold-D-to-draw in browse mode
                        if (e.key === 'd' || e.key === 'D') {
                            e.preventDefault();
                            document.dispatchEvent(new KeyboardEvent('keydown', {
                                key: e.key, code: e.code, bubbles: true
                            }));
                        }
                    });
                    frame.contentWindow.addEventListener('keyup', function(e) {
                        if (e.key === 'd' || e.key === 'D') {
                            document.dispatchEvent(new KeyboardEvent('keyup', {
                                key: e.key, code: e.code, bubbles: true
                            }));
                        }
                    });
                }
            } catch (err) {
                // Cross-origin iframe, can't add listener
            }
        }

        // === DRAWING TOOL ===
        const DRAW_STORAGE_KEY = 'ai_cafe_draw_settings';
        let drawMode = false;
        let drawColor = '#ffeb3b';
        let drawThickness = 8;
        let drawFadeTime = 5; // active fade time â€” drives slider & fade logic
        let presentFadeTime = 5; // saved present-mode default
        let browseFadeTime = 1; // saved browse-mode default
        let browseDrawFading = false; // true while browse-draw paths are still fading out

        // Update the fade slider + display to reflect current drawFadeTime
        function syncFadeUI() {
            const slider = document.getElementById('fadeSlider');
            const display = document.getElementById('fadeDisplay');
            if (slider) slider.value = drawFadeTime;
            if (display) display.textContent = drawFadeTime === 0 ? 'Off' : drawFadeTime + 's';
        }
        let isDrawing = false;
        let isErasing = false; // Right-click hold eraser mode
        let currentPath = [];
        let allPaths = []; // Store all drawn paths for redraw
        let shapeOverride = null; // null = auto-detect, or 'arrow', 'circle', 'triangle', 'square', 'x', 'line'
        let presentShapeOverride = null;
        let browseShapeOverride = null;

        function normalizeShapeOverride(value) {
            const allowed = ['arrow', 'circle', 'triangle', 'square', 'x', 'line'];
            return allowed.includes(value) ? value : null;
        }

        function applyShapeOverrideForCurrentMode() {
            shapeOverride = currentView === 'browse' ? browseShapeOverride : presentShapeOverride;
            updateShapeOverrideDisplay();
        }

        function setShapeOverrideForCurrentMode(value) {
            const normalized = normalizeShapeOverride(value);
            shapeOverride = normalized;
            if (currentView === 'browse') {
                browseShapeOverride = normalized;
            } else {
                presentShapeOverride = normalized;
            }
            updateShapeOverrideDisplay();
            saveDrawSettings();
        }
        
        // Shape override display
        function updateShapeOverrideDisplay() {
            const display = document.getElementById('shapeOverrideDisplay');
            if (!display) return;
            if (shapeOverride) {
                const icons = { arrow: 'â†’', circle: 'â—‹', triangle: 'â–³', square: 'â–¡', x: 'âœ•', line: 'â€”', delete: 'ðŸ—‘' };
                display.textContent = icons[shapeOverride] || shapeOverride;
                display.style.opacity = '1';
            } else {
                display.textContent = 'Auto';
                display.style.opacity = '0.5';
            }
        }
        let drawCanvas, drawCtx;
        let fadeIntervalId = null;

        function loadDrawSettings() {
            try {
                const saved = localStorage.getItem(DRAW_STORAGE_KEY);
                if (saved) {
                    const settings = JSON.parse(saved);
                    if (settings.color) drawColor = settings.color;
                    if (settings.thickness) drawThickness = settings.thickness;
                    if (settings.presentFadeTime !== undefined) presentFadeTime = settings.presentFadeTime;
                    if (settings.browseFadeTime !== undefined) browseFadeTime = settings.browseFadeTime;
                    if (settings.presentShapeOverride !== undefined) presentShapeOverride = normalizeShapeOverride(settings.presentShapeOverride);
                    if (settings.browseShapeOverride !== undefined) browseShapeOverride = normalizeShapeOverride(settings.browseShapeOverride);
                    if (settings.shapeOverride !== undefined) {
                        // Legacy single-value migration: apply to both modes once.
                        const legacyShape = normalizeShapeOverride(settings.shapeOverride);
                        presentShapeOverride = legacyShape;
                        browseShapeOverride = legacyShape;
                    }
                    // Legacy single-value migration
                    if (settings.presentFadeTime === undefined && settings.fadeTime !== undefined) {
                        presentFadeTime = settings.fadeTime;
                    }
                    if (settings.helpVisible !== undefined) drawHelpVisible = settings.helpVisible;
                }
            } catch (e) { console.log('Could not load draw settings'); }
        }

        function saveDrawSettings() {
            try {
                localStorage.setItem(DRAW_STORAGE_KEY, JSON.stringify({
                    color: drawColor,
                    thickness: drawThickness,
                    presentFadeTime: presentFadeTime,
                    browseFadeTime: browseFadeTime,
                    presentShapeOverride: presentShapeOverride,
                    browseShapeOverride: browseShapeOverride,
                    helpVisible: drawHelpVisible
                }));
            } catch (e) { console.log('Could not save draw settings'); }
        }

        function applyDrawSettingsToUI() {
            // Update thickness display
            document.getElementById('thicknessDisplay').textContent = drawThickness + 'px';
            // Update fade slider and display
            const fadeSlider = document.getElementById('fadeSlider');
            const fadeDisplay = document.getElementById('fadeDisplay');
            if (fadeSlider) fadeSlider.value = drawFadeTime;
            if (fadeDisplay) fadeDisplay.textContent = drawFadeTime === 0 ? 'Off' : drawFadeTime + 's';
            // Update color selection
            setDrawColor(drawColor);
            // Update help visibility
            const dropdown = document.getElementById('drawHelpDropdown');
            const helpBtn = document.getElementById('drawHelpBtn');
            if (dropdown && helpBtn) {
                if (drawHelpVisible) {
                    dropdown.classList.add('visible');
                    helpBtn.classList.add('active');
                } else {
                    dropdown.classList.remove('visible');
                    helpBtn.classList.remove('active');
                }
            }
        }

        // === CURSOR FOLLOWER ===
        let cursorFollowerEnabled = false;
        let cursorFollowerPending = false; // Wait for first mousemove to show follower
        const cursorFollower = document.getElementById('cursorFollower');

        function updateCursorFollowerStyle() {
            if (browseDrawActive || (drawMode && currentView === 'present')) {
                // Drawing active: use draw color + draw thickness
                const size = Math.max(drawThickness, 6);
                cursorFollower.style.width = size + 'px';
                cursorFollower.style.height = size + 'px';
                cursorFollower.style.background = `radial-gradient(circle, ${drawColor} 0%, ${drawColor} 50%, ${drawColor}99 100%)`;
                cursorFollower.style.boxShadow = `0 0 8px ${drawColor}, 0 0 16px ${drawColor}88`;
                // No pulse when drawing (browse or present)
                cursorFollower.classList.add('browse-draw');
            } else {
                // Present mode pointer: red pulsing dot (default CSS)
                cursorFollower.style.width = '';
                cursorFollower.style.height = '';
                cursorFollower.style.background = '';
                cursorFollower.style.boxShadow = '';
                cursorFollower.classList.remove('browse-draw');
            }
        }

        function initCursorFollower() {
            const screenContainer = document.getElementById('screenContainer');
            if (!screenContainer) return;

            // Track mouse movement over screen container
            screenContainer.addEventListener('mouseenter', (e) => {
                if (screenContainer.classList.contains('active') || browseDrawActive) {
                    cursorFollowerEnabled = true;
                    cursorFollower.style.left = e.clientX + 'px';
                    cursorFollower.style.top = e.clientY + 'px';
                    updateCursorFollowerStyle();
                    cursorFollower.classList.add('active');
                    screenContainer.classList.add('cursor-hidden');
                }
            });

            screenContainer.addEventListener('mouseleave', () => {
                cursorFollowerEnabled = false;
                cursorFollower.classList.remove('active');
                screenContainer.classList.remove('cursor-hidden');
            });

            // Update follower position
            document.addEventListener('mousemove', (e) => {
                // First mousemove after D key: show follower only if mouse is
                // over the content area (not toolbar). If mouse is over the
                // toolbar, mouseenter on screenContainer will enable it later.
                if (cursorFollowerPending) {
                    cursorFollowerPending = false;
                    const sc = document.getElementById('screenContainer');
                    const r = sc.getBoundingClientRect();
                    if (e.clientX >= r.left && e.clientX <= r.right &&
                        e.clientY >= r.top && e.clientY <= r.bottom) {
                        cursorFollowerEnabled = true;
                        cursorFollower.style.left = e.clientX + 'px';
                        cursorFollower.style.top = e.clientY + 'px';
                        updateCursorFollowerStyle();
                        cursorFollower.classList.add('active');
                        sc.classList.add('cursor-hidden');
                    }
                }
                if (cursorFollowerEnabled) {
                    cursorFollower.style.left = e.clientX + 'px';
                    cursorFollower.style.top = e.clientY + 'px';
                }
            });
        }

        function initDrawCanvas() {
            drawCanvas = document.getElementById('drawCanvas');
            if (!drawCanvas) return;
            drawCtx = drawCanvas.getContext('2d');
            
            // Load saved settings
            loadDrawSettings();
            // Page starts in browse mode â€” set active fade time to browse default
            drawFadeTime = browseFadeTime;
            applyShapeOverrideForCurrentMode();
            applyDrawSettingsToUI();
            
            resizeDrawCanvas();
            
            // Initialize cursor follower
            initCursorFollower();
            
            // Mouse events for drawing
            drawCanvas.addEventListener('mousedown', handleDrawMouseDown);
            drawCanvas.addEventListener('mousemove', handleDrawMouseMove);
            drawCanvas.addEventListener('mouseup', handleDrawMouseUp);
            drawCanvas.addEventListener('mouseleave', handleDrawMouseLeave);
            drawCanvas.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Also track mouseup globally (in case mouse leaves canvas while erasing)
            document.addEventListener('mouseup', () => {
                if (isErasing) isErasing = false;
            });
            
            // Resize handler
            window.addEventListener('resize', resizeDrawCanvas);
            
            // Start fade check interval
            startFadeInterval();
        }

        function handleDrawMouseDown(e) {
            if (!drawMode) return;
            
            if (e.button === 0) { // Left click = draw
                startDrawing(e);
            } else if (e.button === 2) { // Right click = erase mode
                e.preventDefault();
                isErasing = true;
                eraseAtPosition(e);
            }
        }
        
        function handleDrawMouseMove(e) {
            if (!drawMode) return;
            
            // Check if right mouse button is held (buttons is bitmask, 2 = right button)
            if (e.buttons === 2 || isErasing) {
                isErasing = true;
                eraseAtPosition(e);
                return;
            }
            
            if (isDrawing) {
                draw(e);
            }
        }
        
        function handleDrawMouseUp(e) {
            isErasing = false;
            if (isDrawing) {
                stopDrawing();
            }
        }
        
        function handleDrawMouseLeave(e) {
            // Stop all operations when leaving canvas
            isErasing = false;
            if (isDrawing) {
                stopDrawing();
            }
        }

        function eraseAtPosition(e) {
            if (!drawMode) return;
            
            const rect = drawCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Find and remove path that contains this point
            const hitRadius = 20; // Detection radius
            for (let i = allPaths.length - 1; i >= 0; i--) {
                const path = allPaths[i];
                let shouldErase = false;
                
                // Check all line segments between points (catches entire lines, not just vertices)
                for (let j = 0; j < path.points.length - 1; j++) {
                    const p1 = path.points[j];
                    const p2 = path.points[j + 1];
                    
                    // Calculate distance from cursor to line segment
                    const dist = pointToSegmentDistance(x, y, p1.x, p1.y, p2.x, p2.y);
                    if (dist < hitRadius + path.thickness) {
                        shouldErase = true;
                        break;
                    }
                }
                
                // Also check the points themselves (for single dots)
                if (!shouldErase) {
                    for (const point of path.points) {
                        const dist = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);
                        if (dist < hitRadius + path.thickness) {
                            shouldErase = true;
                            break;
                        }
                    }
                }
                
                if (shouldErase) {
                    allPaths.splice(i, 1);
                    redrawAllPaths();
                }
            }
        }
        
        // Calculate distance from point (px, py) to line segment (x1,y1)-(x2,y2)
        function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const lengthSq = dx * dx + dy * dy;
            
            if (lengthSq === 0) {
                // Segment is a point
                return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
            }
            
            // Project point onto line, clamped to segment
            let t = ((px - x1) * dx + (py - y1) * dy) / lengthSq;
            t = Math.max(0, Math.min(1, t));
            
            // Find closest point on segment
            const closestX = x1 + t * dx;
            const closestY = y1 + t * dy;
            
            return Math.sqrt((px - closestX) ** 2 + (py - closestY) ** 2);
        }

        function setDrawFade(value) {
            drawFadeTime = parseInt(value);
            // Persist to the correct mode variable based on current view
            if (currentView === 'browse') {
                browseFadeTime = drawFadeTime;
            } else {
                presentFadeTime = drawFadeTime;
            }
            const display = document.getElementById('fadeDisplay');
            if (display) display.textContent = drawFadeTime === 0 ? 'Off' : drawFadeTime + 's';
            saveDrawSettings();
        }

        function startFadeInterval() {
            if (fadeIntervalId) clearInterval(fadeIntervalId);
            fadeIntervalId = setInterval(checkFadePaths, 100);
        }

        function checkFadePaths() {
            // While D is held in browse mode, don't fade â€” keep drawings visible
            if (browseDrawActive) return;
            if (drawFadeTime === 0 || allPaths.length === 0) return;
            
            const now = Date.now();
            let needsRedraw = false;
            
            // Update opacity for fading paths
            for (let i = allPaths.length - 1; i >= 0; i--) {
                const path = allPaths[i];
                const age = (now - path.createdAt) / 1000; // age in seconds
                
                if (age >= drawFadeTime) {
                    // Fully faded - remove
                    allPaths.splice(i, 1);
                    needsRedraw = true;
                } else if (age >= drawFadeTime * 0.5) {
                    // Start fading after 50% of time
                    const fadeProgress = (age - drawFadeTime * 0.5) / (drawFadeTime * 0.5);
                    path.opacity = 1 - fadeProgress;
                    needsRedraw = true;
                }
            }
            
            if (needsRedraw) redrawAllPaths();
        }

        function resizeDrawCanvas() {
            if (!drawCanvas) return;
            const container = document.getElementById('screenContainer');
            if (!container) return;
            
            // Store current drawings
            const tempPaths = [...allPaths];
            
            drawCanvas.width = container.offsetWidth;
            drawCanvas.height = container.offsetHeight;
            
            // Restore all paths
            allPaths = tempPaths;
            redrawAllPaths();
        }

        let drawHelpVisible = true; // Help dropdown visible by default
        
        function toggleDrawHelp() {
            drawHelpVisible = !drawHelpVisible;
            const dropdown = document.getElementById('drawHelpDropdown');
            const btn = document.getElementById('drawHelpBtn');
            
            if (drawHelpVisible) {
                dropdown.classList.add('visible');
                btn.classList.add('active');
            } else {
                dropdown.classList.remove('visible');
                btn.classList.remove('active');
            }
            saveDrawSettings();
        }

        function toggleDrawMode() {
            drawMode = !drawMode;
            const btn = document.getElementById('drawToggle');
            const canvas = document.getElementById('drawCanvas');

            if (drawMode) {
                btn.classList.remove('inactive');
                btn.classList.add('active');
                canvas.classList.add('active');
                // Disable PPT click zones while drawing
                document.getElementById('pptClickZones').classList.remove('active');
            } else {
                btn.classList.remove('active');
                btn.classList.add('inactive');
                canvas.classList.remove('active');
                // Re-enable PPT click zones if PPT server online and capture is showing
                if (pptServerOnline && screenStream && currentView === 'present') {
                    document.getElementById('pptClickZones').classList.add('active');
                }
            }
            // Update cursor follower style (draw color vs red pointer)
            if (cursorFollowerEnabled) {
                updateCursorFollowerStyle();
            }
            // Update draw group disabled state
            const drawGroup = document.getElementById('drawGroup');
            drawGroup.classList.remove('group-disabled', 'group-draw-disabled');
            if (!drawMode) {
                // Both browse and present: use group-draw-disabled so Draw button stays clickable
                drawGroup.classList.add('group-draw-disabled');
            }
        }

        function setDrawColor(color) {
            drawColor = color;
            // Find matching button by class
            const colorMap = {
                '#ffeb3b': 'neon-yellow',
                '#39ff14': 'neon-green',
                '#00ffff': 'neon-cyan',
                '#ff1493': 'neon-pink',
                '#ff6600': 'neon-orange',
                '#ffffff': 'neon-white'
            };
            document.querySelectorAll('.draw-color-btn').forEach(btn => btn.classList.remove('selected'));
            const selectedBtn = document.querySelector(`.draw-color-btn.${colorMap[color]}`);
            if (selectedBtn) selectedBtn.classList.add('selected');
            if (cursorFollowerEnabled && drawMode) updateCursorFollowerStyle();
            saveDrawSettings();
        }

        function changeDrawThickness(delta) {
            drawThickness = Math.max(2, Math.min(30, drawThickness + delta));
            document.getElementById('thicknessDisplay').textContent = drawThickness + 'px';
            if (cursorFollowerEnabled && drawMode) updateCursorFollowerStyle();
            saveDrawSettings();
        }

        function clearDrawing() {
            if (!drawCtx || !drawCanvas) return;
            allPaths = [];
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        }

        function startDrawing(e) {
            if (!drawMode) return;
            isDrawing = true;
            currentPath = [];
            const rect = drawCanvas.getBoundingClientRect();
            currentPath.push({
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            });
        }

        function draw(e) {
            if (!isDrawing || !drawMode) return;
            const rect = drawCanvas.getBoundingClientRect();
            const point = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            currentPath.push(point);
            
            // Draw preview line (raw, unsmoothed)
            drawPreviewLine();
        }

        function drawPreviewLine() {
            if (currentPath.length < 2) return;
            
            // Redraw all previous paths + current preview
            redrawAllPaths();
            
            // Draw current path as preview (lighter, thinner)
            drawCtx.save();
            drawCtx.strokeStyle = drawColor;
            drawCtx.lineWidth = drawThickness * 0.7;
            drawCtx.lineCap = 'round';
            drawCtx.lineJoin = 'round';
            drawCtx.globalAlpha = 0.5;
            
            drawCtx.beginPath();
            drawCtx.moveTo(currentPath[0].x, currentPath[0].y);
            for (let i = 1; i < currentPath.length; i++) {
                drawCtx.lineTo(currentPath[i].x, currentPath[i].y);
            }
            drawCtx.stroke();
            drawCtx.restore();
        }

        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            
            if (currentPath.length > 1) {
                let finalPoints;
                let shapeType = 'freehand';
                
                // Check for shape override first
                if (shapeOverride) {
                    const overrideResult = applyShapeOverride(currentPath, shapeOverride);
                    finalPoints = overrideResult.points;
                    shapeType = overrideResult.type;
                } else {
                    // Try auto shape recognition
                    const recognizedShape = recognizeShape(currentPath);
                    if (recognizedShape) {
                        finalPoints = recognizedShape.points;
                        shapeType = recognizedShape.type;
                    } else {
                        // No shape recognized - use smoothing
                        finalPoints = smoothPath(currentPath);
                    }
                }
                
                // Store the path with its style and timestamp
                allPaths.push({
                    points: finalPoints,
                    color: drawColor,
                    thickness: drawThickness,
                    createdAt: Date.now(),
                    opacity: 1,
                    shapeType: shapeType
                });
                
                // Redraw everything
                redrawAllPaths();
            }
            currentPath = [];
        }
        
        // Apply forced shape based on key override
        function applyShapeOverride(points, shape) {
            const start = points[0];
            const end = points[points.length - 1];
            const bounds = getBoundingBox(points);
            const center = { x: bounds.cx, y: bounds.cy };
            
            switch (shape) {
                case 'line':
                    return { type: 'line', points: generateLine(start, end) };
                    
                case 'arrow':
                    // Arrow in drawing direction
                    const dir = { x: end.x - start.x, y: end.y - start.y };
                    const dirLen = Math.sqrt(dir.x ** 2 + dir.y ** 2);
                    if (dirLen < 10) return { type: 'line', points: [start, end] };
                    dir.x /= dirLen;
                    dir.y /= dirLen;
                    const headSize = Math.min(25, dirLen * 0.18);
                    const headAngle = 28 * Math.PI / 180;
                    const leftHead = {
                        x: end.x - headSize * (dir.x * Math.cos(headAngle) - dir.y * Math.sin(headAngle)),
                        y: end.y - headSize * (dir.y * Math.cos(headAngle) + dir.x * Math.sin(headAngle))
                    };
                    const rightHead = {
                        x: end.x - headSize * (dir.x * Math.cos(-headAngle) - dir.y * Math.sin(-headAngle)),
                        y: end.y - headSize * (dir.y * Math.cos(-headAngle) + dir.x * Math.sin(-headAngle))
                    };
                    return { type: 'arrow', points: [start, end, end, leftHead, leftHead, end, end, rightHead] };
                    
                case 'circle':
                    const rx = bounds.width / 2;
                    const ry = bounds.height / 2;
                    return { type: 'ellipse', points: generateEllipse(center, rx, ry) };
                    
                case 'square':
                    return { type: 'rectangle', points: generateRectangle(bounds) };
                    
                case 'triangle':
                    // Equilateral-ish triangle fitting bounds
                    const triPoints = [
                        { x: center.x, y: bounds.minY },
                        { x: bounds.maxX, y: bounds.maxY },
                        { x: bounds.minX, y: bounds.maxY },
                        { x: center.x, y: bounds.minY }
                    ];
                    return { type: 'triangle', points: triPoints };
                    
                case 'x':
                    const halfW = bounds.width / 2;
                    const halfH = bounds.height / 2;
                    return { type: 'x', points: [
                        { x: center.x - halfW, y: center.y - halfH },
                        { x: center.x + halfW, y: center.y + halfH },
                        { x: center.x, y: center.y },
                        { x: center.x + halfW, y: center.y - halfH },
                        { x: center.x + halfW, y: center.y - halfH },
                        { x: center.x - halfW, y: center.y + halfH }
                    ]};
                    
                default:
                    return { type: 'freehand', points: smoothPath(points) };
            }
        }

        // === SHAPE RECOGNITION ===
        function recognizeShape(points) {
            if (points.length < 10) return null;
            
            const start = points[0];
            const end = points[points.length - 1];
            const bounds = getBoundingBox(points);
            const center = { x: bounds.cx, y: bounds.cy };
            const size = Math.max(bounds.width, bounds.height);
            
            // Too small to recognize
            if (size < 30) return null;
            
            const closedThreshold = size * 0.25;
            const isClosed = distance(start, end) < closedThreshold;
            
            // Calculate path length
            let pathLength = 0;
            for (let i = 1; i < points.length; i++) {
                pathLength += distance(points[i-1], points[i]);
            }
            
            // 1. STRAIGHT LINE - very high linearity, not closed
            const lineScore = getLinearityScore(points);
            if (lineScore > 0.90 && !isClosed && pathLength > 40) {
                return { type: 'line', points: generateLine(start, end) };
            }
            
            // 2. ARROW - check BEFORE X! Line with V-shape at end
            const arrowResult = detectArrow(points);
            if (arrowResult) {
                return { type: 'arrow', points: arrowResult };
            }
            
            // 3. CLOSED SHAPES - must be closed
            if (isClosed) {
                // Check for RECTANGLE FIRST (corners before curves!)
                const rectResult = detectRectangle(points, bounds);
                if (rectResult) {
                    return { type: 'rectangle', points: rectResult };
                }
                
                // TRIANGLE - 3 clear corners
                const triResult = detectTriangle(points, bounds);
                if (triResult) {
                    return { type: 'triangle', points: triResult };
                }
                
                // CIRCLE/OVAL - only if no corners detected
                const circleScore = getCircularityScore(points, center, bounds);
                if (circleScore > 0.70) {
                    return { type: 'ellipse', points: generateEllipse(center, bounds.width / 2, bounds.height / 2) };
                }
            }
            
            // 4. CROSS/PLUS - must have clear horizontal AND vertical segments
            const crossResult = detectCrossShape(points, bounds, center);
            if (crossResult) {
                return { type: 'cross', points: crossResult };
            }
            
            // 5. X SHAPE - very strict, only if nothing else matches
            const xResult = detectXShape(points, bounds, center);
            if (xResult) {
                return { type: 'x', points: xResult };
            }
            
            // No shape recognized - return null for freehand smoothing
            return null;
        }

        function getBoundingBox(points) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const p of points) {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            }
            return {
                minX, minY, maxX, maxY,
                width: maxX - minX,
                height: maxY - minY,
                cx: (minX + maxX) / 2,
                cy: (minY + maxY) / 2
            };
        }

        function distance(p1, p2) {
            return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
        }

        function getLinearityScore(points) {
            if (points.length < 3) return 1;
            const start = points[0];
            const end = points[points.length - 1];
            const lineLen = distance(start, end);
            if (lineLen < 10) return 0;
            
            let maxDev = 0;
            for (const p of points) {
                const dev = perpendicularDistance(p, start, end);
                maxDev = Math.max(maxDev, dev);
            }
            return 1 - (maxDev / lineLen);
        }

        function getCircularityScore(points, center, bounds) {
            const avgRadius = (bounds.width + bounds.height) / 4;
            if (avgRadius < 10) return 0;
            
            let totalDev = 0;
            for (const p of points) {
                const dist = distance(p, center);
                // Account for ellipse by scaling
                const expectedDist = avgRadius;
                totalDev += Math.abs(dist - expectedDist);
            }
            const avgDev = totalDev / points.length;
            return 1 - Math.min(1, avgDev / avgRadius);
        }

        function getAngle(p1, p2, p3) {
            const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
            const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };
            const dot = v1.x * v2.x + v1.y * v2.y;
            const mag1 = Math.sqrt(v1.x ** 2 + v1.y ** 2);
            const mag2 = Math.sqrt(v2.x ** 2 + v2.y ** 2);
            if (mag1 === 0 || mag2 === 0) return 180;
            const cos = Math.max(-1, Math.min(1, dot / (mag1 * mag2)));
            return Math.acos(cos) * 180 / Math.PI;
        }

        function detectRectangle(points, bounds) {
            // Use less aggressive reduction to keep corners
            const reduced = douglasPeucker(points, 5);
            
            // Find sharp corners (angles less than 135Â°)
            const corners = [];
            for (let i = 1; i < reduced.length - 1; i++) {
                const angle = getAngle(reduced[i-1], reduced[i], reduced[i+1]);
                if (angle < 135) {
                    corners.push({ point: reduced[i], angle: angle });
                }
            }
            
            // Need 3-5 corners for a rectangle (4 corners, maybe split at start/end)
            if (corners.length < 3 || corners.length > 6) return null;
            
            // Check that corners have roughly 90Â° angles (between 50Â° and 130Â°)
            let validCorners = corners.filter(c => c.angle > 50 && c.angle < 130);
            if (validCorners.length < 3) return null;
            
            // Check aspect ratio - rectangles shouldn't be too extreme
            const aspectRatio = bounds.width / bounds.height;
            if (aspectRatio < 0.2 || aspectRatio > 5) return null;
            
            return generateRectangle(bounds);
        }

        function detectTriangle(points, bounds) {
            const reduced = douglasPeucker(points, 8);
            
            // Find sharp corners
            const corners = [];
            for (let i = 1; i < reduced.length - 1; i++) {
                const angle = getAngle(reduced[i-1], reduced[i], reduced[i+1]);
                if (angle < 150) {
                    corners.push(reduced[i]);
                }
            }
            
            // Need exactly 2-4 corners for a triangle
            if (corners.length < 2 || corners.length > 4) return null;
            
            // Use bounding box corners for clean triangle
            const mainCorners = corners.slice(0, Math.min(3, corners.length));
            if (mainCorners.length < 2) return null;
            
            // Add start point if needed
            if (mainCorners.length === 2) {
                mainCorners.unshift(points[0]);
            }
            
            return generatePolygon(mainCorners);
        }

        function detectArrow(points) {
            if (points.length < 20) return null;
            
            const start = points[0];
            const len = points.length;
            
            // The first 60% should be fairly linear (the shaft)
            const shaftEnd = Math.floor(len * 0.6);
            const shaftPoints = points.slice(0, shaftEnd);
            const shaftLinearity = getLinearityScore(shaftPoints);
            
            // Shaft must be quite straight
            if (shaftLinearity < 0.80) return null;
            
            // Find the furthest point from start (arrow tip)
            let maxDist = 0;
            let tipIndex = shaftEnd;
            for (let i = shaftEnd; i < len; i++) {
                const d = distance(start, points[i]);
                if (d > maxDist) {
                    maxDist = d;
                    tipIndex = i;
                }
            }
            
            const tip = points[tipIndex];
            const shaftLength = distance(start, tip);
            
            // Arrow must be long enough
            if (shaftLength < 40) return null;
            
            // Check if there's a V-shape after the tip (user drew arrowhead)
            let hasArrowHead = false;
            for (let i = tipIndex + 5; i < len - 3; i++) {
                const angle = getAngle(points[i-3], points[i], points[Math.min(i+3, len-1)]);
                if (angle < 120) {
                    hasArrowHead = true;
                    break;
                }
            }
            
            // Also accept if the stroke just ends (simple arrow)
            // Check if last portion goes back toward the shaft
            if (!hasArrowHead && len - tipIndex > 5) {
                const endDist = distance(tip, points[len-1]);
                if (endDist > shaftLength * 0.1) {
                    hasArrowHead = true;
                }
            }
            
            if (!hasArrowHead) return null;
            
            // Generate arrow
            const dir = { x: tip.x - start.x, y: tip.y - start.y };
            const dirLen = Math.sqrt(dir.x ** 2 + dir.y ** 2);
            dir.x /= dirLen;
            dir.y /= dirLen;
            
            const headSize = Math.min(25, shaftLength * 0.18);
            const headAngle = 28 * Math.PI / 180;
            
            const leftHead = {
                x: tip.x - headSize * (dir.x * Math.cos(headAngle) - dir.y * Math.sin(headAngle)),
                y: tip.y - headSize * (dir.y * Math.cos(headAngle) + dir.x * Math.sin(headAngle))
            };
            const rightHead = {
                x: tip.x - headSize * (dir.x * Math.cos(-headAngle) - dir.y * Math.sin(-headAngle)),
                y: tip.y - headSize * (dir.y * Math.cos(-headAngle) + dir.x * Math.sin(-headAngle))
            };
            
            return [start, tip, tip, leftHead, leftHead, tip, tip, rightHead];
        }

        function detectXShape(points, bounds, center) {
            if (points.length < 25) return null;
            
            const reduced = douglasPeucker(points, 12);
            
            // X needs exactly 4-6 segments (drawn as one stroke going back and forth)
            if (reduced.length < 5 || reduced.length > 9) return null;
            
            // Must have exactly 2-3 very sharp angles (< 60Â°)
            let verySharpAngles = 0;
            for (let i = 1; i < reduced.length - 1; i++) {
                const angle = getAngle(reduced[i-1], reduced[i], reduced[i+1]);
                if (angle < 60) verySharpAngles++;
            }
            
            if (verySharpAngles < 2 || verySharpAngles > 4) return null;
            
            // X should be roughly square
            const aspectRatio = bounds.width / bounds.height;
            if (aspectRatio < 0.6 || aspectRatio > 1.7) return null;
            
            // All segments should be diagonal (not horizontal/vertical)
            let diagonalSegments = 0;
            for (let i = 0; i < reduced.length - 1; i++) {
                const dx = Math.abs(reduced[i+1].x - reduced[i].x);
                const dy = Math.abs(reduced[i+1].y - reduced[i].y);
                const segLen = Math.sqrt(dx*dx + dy*dy);
                if (segLen < 15) continue;
                
                // Diagonal: neither mostly horizontal nor mostly vertical
                const ratio = Math.min(dx, dy) / Math.max(dx, dy);
                if (ratio > 0.3) diagonalSegments++;
            }
            
            // Most segments should be diagonal for an X
            if (diagonalSegments < 2) return null;
            
            // Generate perfect X
            const halfW = bounds.width / 2;
            const halfH = bounds.height / 2;
            return [
                { x: center.x - halfW, y: center.y - halfH },
                { x: center.x + halfW, y: center.y + halfH },
                { x: center.x, y: center.y },
                { x: center.x + halfW, y: center.y - halfH },
                { x: center.x + halfW, y: center.y - halfH },
                { x: center.x - halfW, y: center.y + halfH }
            ];
        }

        function detectCrossShape(points, bounds, center) {
            if (points.length < 25) return null;
            
            const reduced = douglasPeucker(points, 12);
            if (reduced.length < 4 || reduced.length > 9) return null;
            
            // Count truly horizontal and truly vertical segments
            let horizontalLen = 0;
            let verticalLen = 0;
            
            for (let i = 0; i < reduced.length - 1; i++) {
                const dx = Math.abs(reduced[i+1].x - reduced[i].x);
                const dy = Math.abs(reduced[i+1].y - reduced[i].y);
                const segLen = Math.sqrt(dx*dx + dy*dy);
                
                if (segLen < 20) continue;
                
                // Horizontal: dx >> dy (at least 4x)
                if (dx > dy * 4) horizontalLen += segLen;
                // Vertical: dy >> dx (at least 4x)
                if (dy > dx * 4) verticalLen += segLen;
            }
            
            // Need significant horizontal AND vertical length
            const minLen = Math.min(bounds.width, bounds.height) * 0.4;
            if (horizontalLen < minLen || verticalLen < minLen) return null;
            
            // Generate perfect cross
            const halfW = bounds.width / 2;
            const halfH = bounds.height / 2;
            return [
                { x: center.x - halfW, y: center.y },
                { x: center.x + halfW, y: center.y },
                { x: center.x, y: center.y },
                { x: center.x, y: center.y - halfH },
                { x: center.x, y: center.y - halfH },
                { x: center.x, y: center.y + halfH }
            ];
        }

        // Shape generators
        function generateLine(start, end) {
            return [start, end];
        }

        function generateEllipse(center, rx, ry, segments = 60) {
            const points = [];
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                points.push({
                    x: center.x + rx * Math.cos(angle),
                    y: center.y + ry * Math.sin(angle)
                });
            }
            return points;
        }

        function generateRectangle(bounds) {
            return [
                { x: bounds.minX, y: bounds.minY },
                { x: bounds.maxX, y: bounds.minY },
                { x: bounds.maxX, y: bounds.maxY },
                { x: bounds.minX, y: bounds.maxY },
                { x: bounds.minX, y: bounds.minY }
            ];
        }

        function generatePolygon(corners) {
            // Close the polygon
            return [...corners, corners[0]];
        }

        function smoothPath(points) {
            if (points.length < 3) return points;
            
            // Step 1: First pass - aggressive point reduction
            const reduced = douglasPeucker(points, 8);
            
            // Step 2: If very few points, it's likely a straight line
            if (reduced.length <= 2) return reduced;
            
            // Step 3: Apply moving average to smooth control points
            const averaged = movingAverageSmooth(reduced, 3);
            
            // Step 4: Generate smooth curve through points using Catmull-Rom
            const smooth = catmullRomSpline(averaged, 20);
            
            return smooth;
        }

        // Moving average smoothing for control points
        function movingAverageSmooth(points, windowSize) {
            if (points.length <= windowSize) return points;
            
            const result = [];
            const half = Math.floor(windowSize / 2);
            
            // Keep first point unchanged
            result.push(points[0]);
            
            // Smooth middle points
            for (let i = 1; i < points.length - 1; i++) {
                let sumX = 0, sumY = 0, count = 0;
                for (let j = Math.max(0, i - half); j <= Math.min(points.length - 1, i + half); j++) {
                    sumX += points[j].x;
                    sumY += points[j].y;
                    count++;
                }
                result.push({ x: sumX / count, y: sumY / count });
            }
            
            // Keep last point unchanged
            result.push(points[points.length - 1]);
            
            return result;
        }

        // Douglas-Peucker algorithm for line simplification
        function douglasPeucker(points, epsilon) {
            if (points.length < 3) return points;
            
            let dmax = 0;
            let index = 0;
            const end = points.length - 1;
            
            for (let i = 1; i < end; i++) {
                const d = perpendicularDistance(points[i], points[0], points[end]);
                if (d > dmax) {
                    index = i;
                    dmax = d;
                }
            }
            
            if (dmax > epsilon) {
                const left = douglasPeucker(points.slice(0, index + 1), epsilon);
                const right = douglasPeucker(points.slice(index), epsilon);
                return left.slice(0, -1).concat(right);
            } else {
                return [points[0], points[end]];
            }
        }

        function perpendicularDistance(point, lineStart, lineEnd) {
            const dx = lineEnd.x - lineStart.x;
            const dy = lineEnd.y - lineStart.y;
            const mag = Math.sqrt(dx * dx + dy * dy);
            if (mag === 0) return Math.sqrt((point.x - lineStart.x) ** 2 + (point.y - lineStart.y) ** 2);
            
            const u = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (mag * mag);
            const closestX = lineStart.x + u * dx;
            const closestY = lineStart.y + u * dy;
            return Math.sqrt((point.x - closestX) ** 2 + (point.y - closestY) ** 2);
        }

        // Catmull-Rom spline interpolation
        function catmullRomSpline(points, segments) {
            if (points.length < 2) return points;
            
            const result = [];
            
            for (let i = 0; i < points.length - 1; i++) {
                const p0 = points[Math.max(0, i - 1)];
                const p1 = points[i];
                const p2 = points[i + 1];
                const p3 = points[Math.min(points.length - 1, i + 2)];
                
                for (let t = 0; t < segments; t++) {
                    const s = t / segments;
                    const s2 = s * s;
                    const s3 = s2 * s;
                    
                    const x = 0.5 * (
                        (2 * p1.x) +
                        (-p0.x + p2.x) * s +
                        (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * s2 +
                        (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * s3
                    );
                    const y = 0.5 * (
                        (2 * p1.y) +
                        (-p0.y + p2.y) * s +
                        (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * s2 +
                        (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * s3
                    );
                    
                    result.push({ x, y });
                }
            }
            result.push(points[points.length - 1]);
            
            return result;
        }

        function redrawAllPaths() {
            if (!drawCtx || !drawCanvas) return;
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            
            allPaths.forEach(path => {
                if (path.points.length < 2) return;
                const opacity = path.opacity !== undefined ? path.opacity : 1;
                if (opacity <= 0) return;
                
                // Draw glow effect (multiple layers)
                drawCtx.save();
                drawCtx.lineCap = 'round';
                drawCtx.lineJoin = 'round';
                
                // Outer glow
                drawCtx.shadowColor = path.color;
                drawCtx.shadowBlur = path.thickness * 2;
                drawCtx.strokeStyle = path.color;
                drawCtx.lineWidth = path.thickness;
                drawCtx.globalAlpha = 0.4 * opacity;
                
                drawCtx.beginPath();
                drawCtx.moveTo(path.points[0].x, path.points[0].y);
                for (let i = 1; i < path.points.length; i++) {
                    drawCtx.lineTo(path.points[i].x, path.points[i].y);
                }
                drawCtx.stroke();
                
                // Inner line (brighter core)
                drawCtx.shadowBlur = path.thickness * 0.8;
                drawCtx.globalAlpha = 1 * opacity;
                drawCtx.lineWidth = path.thickness * 0.6;
                drawCtx.stroke();
                
                drawCtx.restore();
            });
        }

        // Keyboard shortcuts for PPT control and Fullscreen
        document.addEventListener('keydown', function(e) {
            // Don't capture when typing in input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            // Let browser/system shortcuts (Ctrl/Cmd/Alt combos) pass through.
            if (e.ctrlKey || e.metaKey || e.altKey) return;

            // Fullscreen toggle with F key (works always)
            if (e.key === 'f' || e.key === 'F') {
                e.preventDefault();
                toggleFullscreen();
                return;
            }

            // Draw mode with D key
            if (e.key === 'd' || e.key === 'D') {
                // Browse mode: hold-D-to-draw (overlay canvas over webpage)
                if (currentView === 'browse' && !browseDrawActive) {
                    e.preventDefault();
                    browseDrawActive = true;
                    const container = document.getElementById('screenContainer');
                    const toolbar = document.querySelector('.url-bar');
                    container.classList.add('draw-overlay');
                    container.style.top = toolbar.offsetHeight + 'px';
                    resizeDrawCanvas();
                    if (!drawMode) toggleDrawMode();
                    // Cursor follower: wait for first mousemove to get correct position
                    // (mouse was over cross-origin iframe, so we don't know the position yet)
                    cursorFollowerPending = true;
                    return;
                }
                // Present mode: toggle draw on/off (ignore key repeat)
                if (currentView === 'present' && screenStream && !e.repeat) {
                    e.preventDefault();
                    if (drawMode && shapeOverride) {
                        setShapeOverrideForCurrentMode(null);
                    } else {
                        toggleDrawMode();
                    }
                    return;
                }
            }

            // Shape override keys (only when draw mode is active)
            if (drawMode) {
                const shapeKeys = {
                    'a': 'arrow', 'A': 'arrow',
                    'c': 'circle', 'C': 'circle',
                    't': 'triangle', 'T': 'triangle',
                    's': 'square', 'S': 'square',
                    'x': 'x', 'X': 'x',
                    'l': 'line', 'L': 'line'
                };
                
                if (shapeKeys[e.key]) {
                    e.preventDefault();
                    setShapeOverrideForCurrentMode(shapeKeys[e.key]);
                    return;
                }
                
                // Escape clears shape override, or exits draw mode if no override
                if (e.key === 'Escape') {
                    e.preventDefault();
                    if (shapeOverride) {
                        setShapeOverrideForCurrentMode(null);
                    } else {
                        toggleDrawMode();
                    }
                    return;
                }
            }

            // PPT controls only when server is online
            if (!pptServerOnline) return;

            switch (e.key) {
                case 'ArrowRight':
                case 'ArrowDown':
                case ' ':
                case 'PageDown':
                    e.preventDefault();
                    pptNext();
                    break;
                case 'ArrowLeft':
                case 'ArrowUp':
                case 'PageUp':
                    e.preventDefault();
                    pptPrevious();
                    break;
                case 'F5':
                    e.preventDefault();
                    if (e.shiftKey) {
                        pptStartCurrent();
                    } else {
                        pptStart();
                    }
                    break;
                case 'Escape':
                    e.preventDefault();
                    pptStop();
                    break;
            }
        });

        // Keyup handler for browse draw overlay (release D to stop drawing)
        document.addEventListener('keyup', function(e) {
            if ((e.key === 'd' || e.key === 'D') && browseDrawActive) {
                browseDrawActive = false;
                browseDrawFading = true;
                // drawFadeTime is already set to browseFadeTime - keep it for the fade
                // Reset all path timestamps so the fade countdown starts NOW
                const now = Date.now();
                allPaths.forEach(function(p) { p.createdAt = now; p.opacity = 1; });
                if (drawMode) toggleDrawMode();
                // Deactivate cursor follower
                cursorFollowerEnabled = false;
                cursorFollowerPending = false;
                cursorFollower.classList.remove('active');
                document.getElementById('screenContainer').classList.remove('cursor-hidden');
                updateCursorFollowerStyle();
                // Let drawings fade naturally, then remove overlay
                fadeBrowseDrawOverlay();
            }
        });

        // Fade out browse draw overlay: wait for drawings to fade, then clean up
        function fadeBrowseDrawOverlay() {
            const container = document.getElementById('screenContainer');
            if (drawFadeTime === 0 || allPaths.length === 0) {
                // No fade or no drawings - clean up immediately
                container.classList.remove('draw-overlay');
                container.style.top = '';
                clearDrawing();
                browseDrawFading = false;
                return;
            }
            // Poll until all paths have faded away
            const checkInterval = setInterval(() => {
                if (allPaths.length === 0) {
                    clearInterval(checkInterval);
                    container.classList.remove('draw-overlay');
                    container.style.top = '';
                    browseDrawFading = false;
                }
            }, 200);
        }

        // === Initialize on Load ===
        window.addEventListener('DOMContentLoaded', function() {
            // Initialize drawing canvas
            initDrawCanvas();
            
            // Resolve and display local BAT path for this presenter location
            initPptControllerPathDisplay();
            
            // Initialize tab system (replaces single-URL and home restore)
            initTabs();
            initToolbarLayoutObserver();

            // Check URL parameter (override)
            const params = new URLSearchParams(window.location.search);
            const urlParam = params.get('url');
            if (urlParam) {
                document.getElementById('urlInput').value = urlParam;
                loadUrl();
            }

            // === Focus Manager ===
            // Two modes, controlled by mouse position:
            //   contentPanel focused (default) â†’ keyboard shortcuts work (D, F, PPT)
            //   iframe focused (after click)   â†’ page interaction works (type, Ctrl+A/C/V)
            // Transition: mouseleave iframe â†’ back to contentPanel instantly.
            // Same-origin iframes: D/F forwarded via setupIframeFullscreenListener(),
            //   so shortcuts work even when iframe has focus. No hint needed.
            // Cross-origin iframes: D cannot work while iframe has focus (browser
            //   security boundary). A hint tells the user to move the mouse out.

            var contentPanel = document.getElementById('contentPanel');
            var contentFrame = document.getElementById('contentFrame');
            var mouseOverIframe = false;
            var iframeCrossOrigin = true; // assume cross-origin until proven otherwise

            function clearPresenterSelection() {
                var sel = window.getSelection ? window.getSelection() : null;
                if (sel && sel.type === 'Range') sel.removeAllRanges();
            }

            function isEditableElement(el) {
                if (!el || !el.tagName) return false;
                var t = el.tagName;
                if (t === 'INPUT' || t === 'TEXTAREA') return true;
                return !!(el.closest && el.closest(
                    '[contenteditable=""], [contenteditable="true"], [contenteditable="plaintext-only"]'
                ));
            }

            function checkIframeCrossOrigin() {
                try { iframeCrossOrigin = !contentFrame.contentDocument; }
                catch (e) { iframeCrossOrigin = true; }
            }

            function recaptureKeyboardFocus() {
                try {
                    if (document.activeElement && document.activeElement.tagName === 'IFRAME')
                        document.activeElement.blur();
                    contentPanel.focus({ preventScroll: true });
                } catch (e) {}
                hideIframeFocusHint();
            }

            function showIframeFocusHint() {
                if (!iframeCrossOrigin) return; // same-origin forwards D automatically
                var hint = document.getElementById('iframeFocusHint');
                if (hint) hint.style.opacity = '1';
            }

            function hideIframeFocusHint() {
                var hint = document.getElementById('iframeFocusHint');
                if (hint) hint.style.opacity = '0';
            }

            if (contentFrame) {
                // Track mouse position relative to iframe
                contentFrame.addEventListener('mouseenter', function() { mouseOverIframe = true; });
                contentFrame.addEventListener('mouseleave', function() {
                    mouseOverIframe = false;
                    if (document.activeElement === contentFrame && currentView === 'browse')
                        recaptureKeyboardFocus();
                });

                // Click outside iframe in content panel â†’ recapture
                contentPanel.addEventListener('click', function(e) {
                    if (e.target.tagName === 'IFRAME' || e.target.id === 'drawCanvas') return;
                    if (isEditableElement(e.target)) return;
                    recaptureKeyboardFocus();
                });

                // mousedown outside iframe â†’ clear stray selections
                contentPanel.addEventListener('mousedown', function(e) {
                    if (e.target === contentFrame) return;
                    if (e.target && e.target.closest && e.target.closest('.url-bar')) return;
                    if (isEditableElement(e.target)) return;
                    clearPresenterSelection();
                });
            }

            // When iframe gains focus: show hint (user click) or recapture (auto-focus)
            document.addEventListener('focusin', function(e) {
                if (e.target !== contentFrame || currentView !== 'browse') return;
                if (!mouseOverIframe) {
                    recaptureKeyboardFocus(); // auto-focus steal â†’ block
                    return;
                }
                showIframeFocusHint(); // user click â†’ show hint
            });

            // Safety: recapture if iframe has focus but mouse is NOT over it
            setInterval(function() {
                if (currentView !== 'browse') return;
                if (mouseOverIframe) return;
                if (document.activeElement === contentFrame)
                    recaptureKeyboardFocus();
            }, 1000);

            // Ctrl/Cmd key â†’ give iframe focus for clipboard operations.
            // Ctrl fires BEFORE the letter key (A/C/V), so focusing the iframe
            // here means the letter fires natively inside the loaded page.
            document.addEventListener('keydown', function(e) {
                if (e.key !== 'Control' && e.key !== 'Meta') return;
                if (currentView !== 'browse') return;
                if (!contentFrame || contentFrame.style.display === 'none') return;
                if (document.activeElement === contentFrame) return;
                if (isEditableElement(document.activeElement)) return;
                if (document.activeElement && document.activeElement.closest &&
                    document.activeElement.closest('.url-bar')) return;

                contentFrame.focus();
                // After 1.5 s, recapture so D works again.
                // Clipboard ops (Ctrl+A/C/V) are brief; user expects shortcuts back.
                // If user clicks in iframe to type, mouseleave will handle recapture
                // naturally when they're done.
                setTimeout(function() {
                    if (document.activeElement === contentFrame && currentView === 'browse')
                        recaptureKeyboardFocus();
                }, 1500);
            }, true);

            // Fallback for same-origin: if Ctrl+A/C/V fires while contentPanel
            // still has focus, use Selection API / execCommand.
            document.addEventListener('keydown', function(e) {
                var isClipboardCombo = (e.ctrlKey || e.metaKey) && !e.altKey && (
                    e.key === 'a' || e.key === 'A' ||
                    e.key === 'c' || e.key === 'C' ||
                    e.key === 'v' || e.key === 'V'
                );
                if (!isClipboardCombo) return;
                if (currentView !== 'browse') return;
                if (!contentFrame || contentFrame.style.display === 'none') return;
                if (document.activeElement === contentFrame) {
                    clearPresenterSelection();
                    return; // iframe has focus â†’ native clipboard is correct
                }

                var target = e.target;
                if (isEditableElement(target)) return;
                if (target && target.closest && target.closest('.url-bar')) return;

                var doc = null;
                try { doc = contentFrame.contentDocument; } catch (err) {}
                if (!doc) {
                    // Cross-origin: focus iframe so next Ctrl+A/C/V works natively
                    clearPresenterSelection();
                    contentFrame.focus();
                    return;
                }

                // Same-origin: handle via Selection API / execCommand
                var key = (e.key || '').toLowerCase();
                e.preventDefault();
                clearPresenterSelection();

                if (key === 'a') {
                    var sel = doc.getSelection();
                    if (sel) {
                        sel.removeAllRanges();
                        var range = doc.createRange();
                        range.selectNodeContents(doc.body);
                        sel.addRange(range);
                    }
                } else if (key === 'c') {
                    contentFrame.focus();
                    try { doc.execCommand('copy'); } catch (copyErr) {}
                    contentPanel.focus({ preventScroll: true });
                } else if (key === 'v') {
                    contentFrame.focus();
                }
            }, true);

            // Escape while iframe focused â†’ recapture (works in some browsers)
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && document.activeElement === contentFrame
                    && currentView === 'browse') {
                    recaptureKeyboardFocus();
                }
            }, true);

            // Initial focus
            setTimeout(recaptureKeyboardFocus, 100);
        });

    </script>
</body>
</html>
