<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1.0, user-scalable=no">
<title>Conway's Game of Life ‚Äî Sphere Edition</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap');

*{margin:0;padding:0;box-sizing:border-box}
:root{--bg:#0a0a0f;--panel:rgba(12,12,22,0.94);--bdr:rgba(0,255,200,0.12);--cyan:#00ffc8;--mag:#ff00aa;--yel:#e6ff00;--txt:#d8e4f0;--txt2:#6a7a8a;--gcyan:0 0 10px rgba(0,255,200,0.35)}
html,body{width:100%;height:100dvh;background:var(--bg);color:var(--txt);font-family:'Rajdhani',sans-serif;overflow:hidden;user-select:none;-webkit-user-select:none}
canvas{display:block;touch-action:none}

#topbar{position:fixed;top:0;left:0;right:0;height:52px;background:var(--panel);backdrop-filter:blur(16px);border-bottom:1px solid var(--bdr);display:flex;align-items:center;justify-content:space-between;padding:0 20px;z-index:100}
#topbar h1{font-family:'Orbitron',sans-serif;font-size:16px;font-weight:700;letter-spacing:3px;background:linear-gradient(90deg,var(--cyan),var(--mag));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
#stats{display:flex;gap:18px;font-size:12px;font-weight:500;color:var(--txt2)}
#stats div{white-space:nowrap;display:flex;align-items:center;gap:2px}
#stats .stat-label{min-width:38px;text-align:right}
#stats em{font-style:normal;color:var(--cyan);font-weight:700;display:inline-block;min-width:62px;text-align:right;font-variant-numeric:tabular-nums;font-feature-settings:'tnum' 1}
#mStats{display:flex;gap:12px;font-size:11px;font-weight:500;color:#4488ff;flex-wrap:wrap;max-width:45vw;justify-content:flex-end}
#mStats span{white-space:nowrap;display:inline-flex;align-items:baseline;gap:2px}
#mStats .ml{min-width:52px;text-align:right}
#mStats .mc{color:#66aaff;font-weight:700;min-width:24px;display:inline-block;text-align:right;font-variant-numeric:tabular-nums}

#panel{position:fixed;top:62px;left:10px;width:272px;max-height:calc(100dvh - 76px);overflow-y:auto;background:var(--panel);backdrop-filter:blur(16px);border:1px solid var(--bdr);border-radius:10px;padding:14px;z-index:100;display:flex;flex-direction:column;gap:12px}
#panel::-webkit-scrollbar{width:3px}
#panel::-webkit-scrollbar-track{background:transparent}
#panel::-webkit-scrollbar-thumb{background:var(--bdr);border-radius:2px}

.sec{border-bottom:1px solid var(--bdr);padding-bottom:12px}
.sec:last-child{border-bottom:none;padding-bottom:0}
.sec-t{font-family:'Orbitron',sans-serif;font-size:9px;font-weight:700;letter-spacing:2px;text-transform:uppercase;color:var(--cyan);margin-bottom:8px}

.row{display:flex;gap:5px;flex-wrap:wrap}
.btn{display:inline-flex;align-items:center;justify-content:center;gap:5px;padding:7px 12px;border:1px solid var(--bdr);border-radius:5px;background:rgba(0,255,200,0.04);color:var(--txt);font-family:'Rajdhani',sans-serif;font-size:12px;font-weight:600;cursor:pointer;transition:all .2s;white-space:nowrap}
.btn:hover{background:rgba(0,255,200,0.1);border-color:var(--cyan);box-shadow:var(--gcyan)}
.btn.on{background:rgba(0,255,200,0.15);border-color:var(--cyan);color:var(--cyan);box-shadow:var(--gcyan)}
.btn.p{background:rgba(0,255,200,0.1);border-color:var(--cyan);color:var(--cyan)}
.btn.p:hover{background:rgba(0,255,200,0.2);box-shadow:0 0 16px rgba(0,255,200,0.4)}
.btn.d{border-color:rgba(255,0,170,0.2);color:var(--mag);background:rgba(255,0,170,0.04)}
.btn.d:hover{background:rgba(255,0,170,0.12);border-color:var(--mag)}

select{width:100%;padding:7px 30px 7px 10px;border:1px solid var(--bdr);border-radius:5px;background:rgba(0,255,200,0.04);color:var(--txt);font-family:'Rajdhani',sans-serif;font-size:12px;font-weight:500;cursor:pointer;outline:none;-webkit-appearance:none;appearance:none;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 5 5-5' stroke='%2300ffc8' stroke-width='1.5' fill='none'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:right 10px center}
select:hover{border-color:var(--cyan)}
select option{background:#151528;color:var(--txt)}
select optgroup{background:#0c0c20;color:var(--cyan);font-style:normal;font-weight:600}

.sg{display:flex;flex-direction:column;gap:3px}
.sl{display:flex;justify-content:space-between;font-size:11px;color:var(--txt2)}
.sl .v{color:var(--yel);font-weight:700}

input[type=range]{-webkit-appearance:none;width:100%;height:3px;border-radius:2px;background:rgba(0,255,200,0.12);outline:none}
input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:14px;height:14px;border-radius:50%;background:var(--cyan);cursor:pointer;box-shadow:0 0 6px rgba(0,255,200,0.5)}
input[type=range]::-moz-range-thumb{width:14px;height:14px;border-radius:50%;background:var(--cyan);cursor:pointer;border:none}

.trow{display:flex;justify-content:space-between;align-items:center;font-size:12px}
.tog{position:relative;width:36px;height:20px;cursor:pointer}
.tog input{opacity:0;width:0;height:0}
.tog-s{position:absolute;inset:0;background:rgba(255,255,255,0.08);border-radius:10px;transition:.3s}
.tog-s::before{content:'';position:absolute;width:14px;height:14px;left:3px;bottom:3px;background:var(--txt2);border-radius:50%;transition:.3s}
.tog input:checked+.tog-s{background:rgba(0,255,200,0.25)}
.tog input:checked+.tog-s::before{transform:translateX(16px);background:var(--cyan);box-shadow:0 0 5px var(--cyan)}

/* Color picker row */
.cpr{display:flex;align-items:center;gap:8px;margin-bottom:6px}
.cpr label{font-size:11px;color:var(--txt2);min-width:80px}
.cpr input[type=color]{-webkit-appearance:none;border:1px solid var(--bdr);border-radius:4px;width:32px;height:22px;padding:0;cursor:pointer;background:transparent}
.cpr input[type=color]::-webkit-color-swatch-wrapper{padding:1px}
.cpr input[type=color]::-webkit-color-swatch{border:none;border-radius:3px}
.cpr input[type=range]{flex:1}
.cpr .iv{font-size:10px;color:var(--yel);font-weight:700;min-width:28px;text-align:right}

#foot{position:fixed;bottom:8px;left:50%;transform:translateX(-50%);background:var(--panel);backdrop-filter:blur(16px);border:1px solid var(--bdr);border-radius:6px;padding:6px 14px;font-size:10px;color:var(--txt2);z-index:100;text-align:center}
#foot kbd{background:rgba(0,255,200,0.08);border:1px solid var(--bdr);border-radius:2px;padding:1px 4px;font-family:'Rajdhani',sans-serif;color:var(--cyan);font-size:10px}

/* Context menu */
#ctxMenu{position:fixed;z-index:200;background:var(--panel);backdrop-filter:blur(20px);border:1px solid var(--cyan);border-radius:8px;padding:6px 0;min-width:180px;max-height:70vh;overflow-y:auto;box-shadow:0 0 20px rgba(0,255,200,0.15),0 8px 32px rgba(0,0,0,0.6)}
#ctxMenu::-webkit-scrollbar{width:3px}
#ctxMenu::-webkit-scrollbar-thumb{background:var(--bdr);border-radius:2px}
.ctx-cat{font-family:'Orbitron',sans-serif;font-size:8px;font-weight:700;letter-spacing:2px;text-transform:uppercase;color:var(--cyan);padding:6px 14px 3px;opacity:.7}
.ctx-item{padding:5px 14px;font-size:12px;font-weight:500;cursor:pointer;transition:all .15s;color:var(--txt)}
.ctx-item:hover{background:rgba(0,255,200,0.12);color:var(--cyan);padding-left:18px}

/* Impact overlay ‚Äî positioned beside sphere */
#impactOverlay{position:fixed;left:0;top:0;z-index:150;pointer-events:none;display:none;grid-template-columns:repeat(4,auto);gap:8px}
.imp-card{display:flex;flex-direction:column;align-items:center;gap:4px;background:rgba(8,12,28,0.88);border:1px solid rgba(68,102,255,0.3);border-radius:8px;padding:8px 10px;backdrop-filter:blur(12px)}
.imp-card canvas{image-rendering:pixelated;border-radius:4px}
.imp-num{font-family:'Orbitron',sans-serif;font-size:10px;opacity:0.5;letter-spacing:1px}
.imp-label{font-family:'Orbitron',sans-serif;font-size:10px;letter-spacing:1.5px;text-transform:uppercase;font-weight:700;white-space:nowrap}

@media(max-width:768px){
  #panel{width:calc(100% - 20px);max-height:40dvh;top:auto;bottom:10px;left:10px;right:10px}
  #foot{display:none}
  #topbar h1{font-size:12px;letter-spacing:1px}
  #stats{gap:10px;font-size:11px}
  #mStats{display:none}
}
</style>
</head>
<body>

<div id="topbar">
  <h1>CONWAY'S LIFE ¬∑ SPHERE</h1>
  <div id="mStats" title="Meteor impact history ‚Äî shows total impacts and per-pattern breakdown of all meteor strikes on the sphere"></div>
  <div id="stats">
    <div title="Generation counter ‚Äî the number of simulation steps (ticks) that have been computed since the last reset"><span class="stat-label">Gen:</span> <em id="sGen">0</em></div>
    <div title="Population ‚Äî total count of currently living cells on the sphere surface"><span class="stat-label">Pop:</span> <em id="sPop">0</em></div>
    <div title="Alive percentage ‚Äî fraction of all cells on the sphere that are currently alive"><span class="stat-label">Alive:</span> <em id="sPct">0%</em></div>
  </div>
</div>

<div id="panel">

  <!-- SIMULATION -->
  <div class="sec">
    <div class="sec-t">Simulation</div>
    <div class="row" style="flex-wrap:nowrap">
      <button class="btn p" id="bPlay" title="Play / Pause ‚Äî start or pause the cellular automaton simulation. Each tick computes one generation using Conway's B3/S23 rules on the sphere" style="flex:1">‚ñ∂ Play</button>
      <button class="btn" id="bStep" title="Step ‚Äî advance the simulation by exactly one generation. Useful for observing how patterns evolve frame by frame" style="flex:1">‚è≠ Step</button>
      <button class="btn d" id="bClear" title="Clear ‚Äî kill all living cells, reset the generation counter to zero, and stop the simulation" style="flex:1">‚úï Clear</button>
      <button class="btn" id="bWipe" title="Wipe mode ‚Äî toggle eraser brush. While active, click-drag on the sphere surface to erase cells within the wipe radius" style="flex:1">‚óØ Wipe</button>
    </div>
    <div style="height:5px"></div>
    <div class="sg">
      <div class="sl"><span title="Wipe Radius ‚Äî diameter of the circular eraser brush used in wipe mode. Larger values erase bigger areas per stroke">Wipe Radius</span><span class="v" id="vWipeR">10</span></div>
      <input type="range" id="rWipeR" min="3" max="40" value="10">
    </div>
    <div style="height:8px"></div>
    <div class="sg">
      <div class="sl"><span title="Speed ‚Äî how many generations per second the simulation computes when playing. Higher values make evolution faster">Speed</span><span class="v" id="vSpd">5 gen/s</span></div>
      <input type="range" id="rSpd" min="1" max="60" value="5">
    </div>
    <div style="height:8px"></div>
    <div class="trow">
      <span title="Meteor Rain ‚Äî when enabled, random Game of Life patterns are launched as meteors from deep space toward the sphere at randomised intervals, impacting the surface and seeding new life">Meteor Rain</span>
      <label class="tog"><input type="checkbox" id="tMeteor" checked><span class="tog-s"></span></label>
    </div>
    <div style="height:5px"></div>
    <div class="sg">
      <div class="sl"><span title="Meteor Interval ‚Äî average time in seconds between meteor spawns. The actual timing is randomised around this value for organic variety">Meteor Interval</span><span class="v" id="vMInt">1s</span></div>
      <input type="range" id="rMInt" min="1" max="15" value="1">
    </div>
    <div style="height:5px"></div>
    <div class="sg">
      <div class="sl"><span title="Meteor Speed ‚Äî controls how fast meteors travel through space toward the sphere. Higher values make them arrive more quickly">Meteor Speed</span><span class="v" id="vMSpd">0.1</span></div>
      <input type="range" id="rMSpd" min="10" max="150" value="10">
    </div>
  </div>

  <!-- PATTERNS -->
  <div class="sec">
    <div class="sec-t">Initial State</div>
    <select id="selPat" title="Pattern selector ‚Äî choose a Game of Life pattern to place on the sphere. Random seeds fill the entire surface; named patterns are placed at random positions based on the Pattern Copies count">
      <optgroup label="‚îÄ‚îÄ‚îÄ Random Seeds ‚îÄ‚îÄ‚îÄ">
        <option value="rnd-15">Random Sparse (15%)</option>
        <option value="rnd-30">Random Medium (30%)</option>
        <option value="rnd-50">Random Dense (50%)</option>
      </optgroup>
      <optgroup label="‚îÄ‚îÄ‚îÄ Still Lifes ‚îÄ‚îÄ‚îÄ">
        <option value="block">Block</option>
        <option value="beehive">Beehive</option>
        <option value="loaf">Loaf</option>
        <option value="tub">Tub</option>
        <option value="boat">Boat</option>
        <option value="ship">Ship</option>
        <option value="pond">Pond</option>
      </optgroup>
      <optgroup label="‚îÄ‚îÄ‚îÄ Oscillators ‚îÄ‚îÄ‚îÄ">
        <option value="blinker">Blinker (p2)</option>
        <option value="toad">Toad (p2)</option>
        <option value="beacon">Beacon (p2)</option>
        <option value="clock">Clock (p2)</option>
        <option value="pulsar">Pulsar (p3)</option>
        <option value="penta">Pentadecathlon (p15)</option>
        <option value="figureEight">Figure Eight (p8)</option>
        <option value="tumbler">Tumbler (p14)</option>
      </optgroup>
      <optgroup label="‚îÄ‚îÄ‚îÄ Spaceships ‚îÄ‚îÄ‚îÄ">
        <option value="glider">Glider (c/4 diagonal)</option>
        <option value="lwss">Lightweight Spaceship</option>
        <option value="mwss">Middleweight Spaceship</option>
        <option value="hwss">Heavyweight Spaceship</option>
        <option value="copperhead">Copperhead (c/10)</option>
      </optgroup>
      <optgroup label="‚îÄ‚îÄ‚îÄ Guns / Factories ‚îÄ‚îÄ‚îÄ">
        <option value="gosper">Gosper Glider Gun (Factory)</option>
      </optgroup>
      <optgroup label="‚îÄ‚îÄ‚îÄ Methuselahs ‚îÄ‚îÄ‚îÄ">
        <option value="rpent">R-Pentomino (1103 gen)</option>
        <option value="acorn">Acorn (5206 gen)</option>
        <option value="diehard">Diehard (130 gen)</option>
        <option value="thunderbird">Thunderbird</option>
        <option value="piHept">&pi;-Heptomino</option>
        <option value="bhept">B-Heptomino</option>
      </optgroup>
      <optgroup label="‚îÄ‚îÄ‚îÄ Infinite Growth ‚îÄ‚îÄ‚îÄ">
        <option value="inf1">Infinite Growth I</option>
        <option value="inf2">Infinite Growth II</option>
      </optgroup>
    </select>
    <div style="height:6px"></div>
    <div class="row">
      <button class="btn p" id="bApply" title="Apply ‚Äî clear the sphere and place the selected pattern. Random seeds fill the whole surface; named patterns are scattered as copies at random locations">Apply</button>
      <button class="btn" id="bRand" title="Randomize ‚Äî clear the sphere and fill it with a random density of living cells (12‚Äì40%). Quick way to get unpredictable starting conditions">üé≤ Randomize</button>
    </div>
    <div style="height:6px"></div>
    <div class="sg">
      <div class="sl"><span title="Pattern Copies ‚Äî how many copies of the selected pattern are scattered across the sphere when Apply is pressed. Only used for named patterns, not for random seeds">Pattern Copies</span><span class="v" id="vScat">8</span></div>
      <input type="range" id="rScat" min="1" max="40" value="8">
    </div>
  </div>

  <!-- CAMERA -->
  <div class="sec">
    <div class="sec-t">Camera</div>
    <div class="sg">
      <div class="sl"><span title="Zoom Distance ‚Äî how far the camera is from the sphere. Lower values zoom in closer, higher values zoom out for a wider field of view">Zoom Distance</span><span class="v" id="vZoom">4.0</span></div>
      <input type="range" id="rZoom" min="15" max="80" value="40">
    </div>
    <div style="height:8px"></div>
    <div class="trow">
      <span title="Auto-Rotate ‚Äî slowly and randomly rotate the sphere so all areas are visible over time. The rotation axis drifts organically for a cinematic effect">Auto-Rotate</span>
      <label class="tog"><input type="checkbox" id="tRot" checked><span class="tog-s"></span></label>
    </div>
    <div style="height:5px"></div>
    <div class="sg">
      <div class="sl"><span title="Rotation Speed ‚Äî how fast the sphere auto-rotates. Higher values spin the sphere faster">Rotation Speed</span><span class="v" id="vRSpd">0.1</span></div>
      <input type="range" id="rRSpd" min="1" max="30" value="1">
    </div>
  </div>

  <!-- APPEARANCE -->
  <div class="sec">
    <div class="sec-t">Appearance</div>
    <div class="sg">
      <div class="sl"><span title="Emissive Glow ‚Äî overall self-illumination intensity of the sphere. At 0 the sphere is only lit by scene lights; at max it glows brightly from within">Emissive Glow</span><span class="v" id="vGlow">1.0</span></div>
      <input type="range" id="rGlow" min="0" max="100" value="100">
    </div>
    <div style="height:6px"></div>
    <div class="trow">
      <span title="Grid Dots ‚Äî toggle small circular reference dots on the sphere surface. These dots show the underlying cell grid structure on dead cells">Grid Dots</span>
      <label class="tog"><input type="checkbox" id="tGrid" checked><span class="tog-s"></span></label>
    </div>
    <div style="height:5px"></div>
    <div class="sg">
      <div class="sl"><span title="Dot Size ‚Äî radius of the grid reference dots on the sphere. Larger dots make the grid structure more visible">Dot Size</span><span class="v" id="vDotR">0.8</span></div>
      <input type="range" id="rDotR" min="3" max="25" value="8">
    </div>
    <div style="height:6px"></div>
    <div class="sg">
      <div class="sl"><span title="Cell Exposure ‚Äî brightens or darkens living cells. Positive values boost brightness and contrast, negative values dim them. Works like camera exposure compensation">Cell Exposure</span><span class="v" id="vExposure">+100</span></div>
      <input type="range" id="rExposure" min="-100" max="100" value="100">
    </div>
    <div style="height:4px"></div>
    <div class="sg">
      <div class="sl"><span title="Cell Saturation ‚Äî adjusts colour richness of living cells. Positive values make colours more vivid, negative values desaturate toward greyscale">Cell Saturation</span><span class="v" id="vSaturation">+100</span></div>
      <input type="range" id="rSaturation" min="-100" max="100" value="100">
    </div>
    <div style="height:6px"></div>
    <div class="trow">
      <span title="Cell Glow ‚Äî adds a soft bloom aura around living cells. Creates a neon-like glow effect whose radius and intensity can be fine-tuned below">Cell Glow</span>
      <label class="tog"><input type="checkbox" id="tCGlow" checked><span class="tog-s"></span></label>
    </div>
    <div style="height:5px"></div>
    <div class="sg">
      <div class="sl"><span title="Glow Radius ‚Äî blur radius of the cell glow aura. Larger values create a wider, softer bloom around living cells">Glow Radius</span><span class="v" id="vCGR">5</span></div>
      <input type="range" id="rCGR" min="1" max="20" value="5">
    </div>
    <div style="height:3px"></div>
    <div class="sg">
      <div class="sl"><span title="Glow Intensity ‚Äî brightness of the cell glow aura. Higher values produce a more visible bloom effect">Glow Intensity</span><span class="v" id="vCGI">0.1</span></div>
      <input type="range" id="rCGI" min="10" max="100" value="10">
    </div>
    <div style="height:6px"></div>
    <div class="trow">
      <span title="Wireframe ‚Äî overlay a geometric wireframe grid on the sphere surface. Fades based on viewing angle: bright on front-facing areas, transparent on edges">Wireframe</span>
      <label class="tog"><input type="checkbox" id="tWire" checked><span class="tog-s"></span></label>
    </div>
    <div style="height:4px"></div>
    <div class="sg">
      <div class="sl"><span title="Wire Exposure ‚Äî brightness of the wireframe overlay. Higher values make the wireframe more visible against the sphere texture">Wire Exposure</span><span class="v" id="vWireExp">30</span></div>
      <input type="range" id="rWireExp" min="1" max="80" value="30">
    </div>
  </div>

  <!-- COLORS -->
  <div class="sec">
    <div class="sec-t">Colors</div>

    <div class="cpr" title="Alive colour ‚Äî the base colour and brightness of living cells that have survived at least a few generations. This is the dominant colour visible on the sphere">
      <label>Alive</label>
      <input type="color" id="cAlive" value="#00ffc8">
      <input type="range" id="iAlive" min="10" max="100" value="100">
      <span class="iv" id="ivAlive">100%</span>
    </div>

    <div class="cpr" title="Born colour ‚Äî the flash colour of cells in their first few generations of life. They transition from this colour to the Alive colour over ~3 ticks">
      <label>Born</label>
      <input type="color" id="cBorn" value="#ff00aa">
      <input type="range" id="iBorn" min="10" max="100" value="100">
      <span class="iv" id="ivBorn">100%</span>
    </div>

    <div class="cpr" title="Dead / Background colour ‚Äî the colour of cells that are currently dead. Also serves as the sphere's background colour in areas with no activity">
      <label>Dead / BG</label>
      <input type="color" id="cDead" value="#0a0a14">
      <input type="range" id="iDead" min="10" max="100" value="100">
      <span class="iv" id="ivDead">100%</span>
    </div>

    <div class="cpr" title="Grid Dots colour ‚Äî the colour and brightness of the small reference dots overlaid on the sphere surface. Only visible when Grid Dots is enabled">
      <label>Grid Dots</label>
      <input type="color" id="cDots" value="#0066ff">
      <input type="range" id="iDots" min="0" max="100" value="60">
      <span class="iv" id="ivDots">60%</span>
    </div>

    <div class="cpr" title="Impact colour ‚Äî the colour used for meteor shockwave rings, the impact overlay cards, and the meteor statistics in the top bar">
      <label>Impact</label>
      <input type="color" id="cImpact" value="#4488ff">
      <input type="range" id="iImpact" min="10" max="100" value="100">
      <span class="iv" id="ivImpact">100%</span>
    </div>

    <div style="height:4px"></div>
    <div class="sl" style="margin-bottom:4px"><span title="Preset Themes ‚Äî one-click colour schemes that set all five colour channels at once. You can further fine-tune individual colours after selecting a theme">Preset Themes</span></div>
    <select id="selTheme" title="Preset Themes ‚Äî load a pre-configured colour scheme. Each preset changes Alive, Born, Dead, Grid Dots colours simultaneously">
      <option value="cm">Cyan & Magenta</option>
      <option value="go">Green & Orange</option>
      <option value="by">Blue & Yellow</option>
      <option value="pg">Purple & Green</option>
      <option value="fi">Fire</option>
      <option value="oc">Ocean</option>
      <option value="mx">Matrix</option>
    </select>
  </div>

</div>

<div id="ctxMenu" style="display:none"></div>
<div id="impactOverlay"></div>

<div id="foot">
  <kbd>Drag</kbd> Rotate ¬∑ <kbd>Scroll</kbd> Zoom ¬∑ <kbd>Right-click</kbd> Place Pattern ¬∑ <kbd>Wipe</kbd> Erase Region ¬∑ Spherical Game of Life
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ENGINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const W=400, H=200, TOTAL=W*H, HW=W>>1;
let grid=new Uint8Array(TOTAL), buf=new Uint8Array(TOTAL), age=new Float32Array(TOTAL);
let gen=0, pop=0, running=false, speed=5, lastTick=0;
let meteorMode=true, meteorInterval=1, meteorTimer=0, nextMeteorTime=1;
let meteorSpeed=0.1;
let meteorAge=new Float32Array(TOTAL);
let activeMeteors=[];
let meteorStats={};

// Appearance state
let dotRadius=0.8, cellGlow=true, glowRadius=5, glowIntensity=0.1, cellExposure=16, cellSaturation=1;

// Wipe mode
let wipeMode=false, wipeRadius=10, wiping=false;

// Impact shockwave rings
let impactRings=[];

// Texture upscale for pole distortion correction
const TEX_SCALE=10, TW=W*TEX_SCALE, TH=H*TEX_SCALE;
const poleStretch=new Float32Array(H);
const poleCellH=new Uint8Array(H);
for(let y=0;y<H;y++){
  const th=(y+0.5)/H*Math.PI;
  const sinTh=Math.max(0.06,Math.sin(th));
  poleStretch[y]=Math.min(12,1/sinTh);
  poleCellH[y]=Math.max(1,Math.round(TEX_SCALE*sinTh));
}

// Spherical polar topology: reflect at poles with x+W/2 offset
function ix(x,y){
  if(y<0){y=-y-1;x+=HW}
  else if(y>=H){y=2*H-1-y;x+=HW}
  if(y<0)y=0;if(y>=H)y=H-1;
  return y*W+((x%W+W)%W);
}

function nb(x,y){let n=0;for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){if(!dx&&!dy)continue;if(grid[ix(x+dx,y+dy)])n++}return n}

function step(){
  pop=0;
  for(let y=0;y<H;y++)for(let x=0;x<W;x++){
    const i=y*W+x,n=nb(x,y),alive=grid[i];
    buf[i]=alive?(n===2||n===3?1:0):(n===3?1:0);
    if(buf[i]){age[i]=alive?Math.min(age[i]+1,80):0;pop++}
    else{age[i]=alive?-1:Math.min(age[i],-1)}
  }
  [grid,buf]=[buf,grid]; gen++;
}

function clear(){grid.fill(0);buf.fill(0);age.fill(-15);meteorAge.fill(0);gen=0;pop=0;running=false;updPlayBtn()}

// Patterns
const PAT={
  block:[[0,0],[1,0],[0,1],[1,1]],
  beehive:[[1,0],[2,0],[0,1],[3,1],[1,2],[2,2]],
  loaf:[[1,0],[2,0],[0,1],[3,1],[1,2],[3,2],[2,3]],
  tub:[[1,0],[0,1],[2,1],[1,2]],
  blinker:[[0,0],[1,0],[2,0]],
  toad:[[1,0],[2,0],[3,0],[0,1],[1,1],[2,1]],
  beacon:[[0,0],[1,0],[0,1],[3,2],[2,3],[3,3]],
  pulsar:(()=>{const c=[];for(const x of[2,3,4,8,9,10])for(const y of[0,5,7,12])c.push([x,y]);for(const y of[2,3,4,8,9,10])for(const x of[0,5,7,12])c.push([x,y]);return c})(),
  penta:[[1,0],[2,0],[3,0],[0,1],[4,1],[0,2],[4,2],[1,3],[2,3],[3,3],[1,6],[2,6],[3,6],[0,7],[4,7],[0,8],[4,8],[1,9],[2,9],[3,9]],
  glider:[[1,0],[2,1],[0,2],[1,2],[2,2]],
  lwss:[[1,0],[4,0],[0,1],[0,2],[4,2],[0,3],[1,3],[2,3],[3,3]],
  mwss:[[2,0],[0,1],[4,1],[5,2],[0,3],[5,3],[1,4],[2,4],[3,4],[4,4],[5,4]],
  hwss:[[2,0],[3,0],[0,1],[5,1],[6,2],[0,3],[6,3],[1,4],[2,4],[3,4],[4,4],[5,4],[6,4]],
  gosper:[[24,0],[22,1],[24,1],[12,2],[13,2],[20,2],[21,2],[34,2],[35,2],[11,3],[15,3],[20,3],[21,3],[34,3],[35,3],[0,4],[1,4],[10,4],[16,4],[20,4],[21,4],[0,5],[1,5],[10,5],[14,5],[16,5],[17,5],[22,5],[24,5],[10,6],[16,6],[24,6],[11,7],[15,7],[12,8],[13,8]],
  rpent:[[1,0],[2,0],[0,1],[1,1],[1,2]],
  acorn:[[1,0],[3,1],[0,2],[1,2],[4,2],[5,2],[6,2]],
  diehard:[[6,0],[0,1],[1,1],[1,2],[5,2],[6,2],[7,2]],
  inf1:[[0,0],[2,0],[2,1],[4,2],[4,3],[4,4],[6,3],[6,4],[6,5],[7,4]],
  inf2:[[0,0],[1,0],[2,0],[4,0],[0,1],[3,2],[4,2],[1,3],[2,3],[0,4],[1,4],[2,4]],
  boat:[[0,0],[1,0],[0,1],[2,1],[1,2]],
  ship:[[0,0],[1,0],[0,1],[2,1],[1,2],[2,2]],
  pond:[[1,0],[2,0],[0,1],[3,1],[0,2],[3,2],[1,3],[2,3]],
  clock:[[2,0],[0,1],[1,1],[2,2],[3,2],[1,3]],
  figureEight:[[0,0],[1,0],[2,0],[0,1],[1,1],[2,1],[0,2],[1,2],[2,2],[3,3],[4,3],[5,3],[3,4],[4,4],[5,4],[3,5],[4,5],[5,5]],
  tumbler:[[1,0],[5,0],[1,1],[5,1],[1,2],[2,2],[4,2],[5,2],[0,3],[2,3],[4,3],[6,3],[0,4],[2,4],[4,4],[6,4],[0,5],[1,5],[5,5],[6,5]],
  thunderbird:[[0,0],[1,0],[2,0],[1,2],[1,3],[1,4]],
  piHept:[[0,0],[1,0],[2,0],[0,1],[2,1],[0,2],[2,2]],
  bhept:[[1,0],[0,1],[1,1],[2,1],[0,2],[2,2],[1,3]],
  copperhead:[[1,0],[2,0],[4,0],[5,0],[3,1],[4,1],[3,2],[4,2],[0,3],[2,3],[5,3],[7,3],[0,4],[7,4],[0,6],[7,6],[1,7],[2,7],[5,7],[6,7],[2,8],[3,8],[4,8],[5,8],[3,10],[4,10],[3,11],[4,11]],
};

// Pattern display names
const PAT_NAMES={
  block:'Block',beehive:'Beehive',loaf:'Loaf',tub:'Tub',boat:'Boat',ship:'Ship',pond:'Pond',
  blinker:'Blinker',toad:'Toad',beacon:'Beacon',clock:'Clock',pulsar:'Pulsar',penta:'Pentadec.',
  figureEight:'Fig.Eight',tumbler:'Tumbler',
  glider:'Glider',lwss:'LWSS',mwss:'MWSS',hwss:'HWSS',copperhead:'Copperhead',
  gosper:'Gosper Gun',rpent:'R-Pento',acorn:'Acorn',diehard:'Diehard',
  thunderbird:'Thunder',piHept:'\u03C0-Hept',bhept:'B-Hept',
  inf1:'Inf.I',inf2:'Inf.II',
};

// Pattern metadata for context menu
const PAT_MENU=[
  {cat:'Still Lifes',items:[['block','Block'],['beehive','Beehive'],['loaf','Loaf'],['tub','Tub'],['boat','Boat'],['ship','Ship'],['pond','Pond']]},
  {cat:'Oscillators',items:[['blinker','Blinker (p2)'],['toad','Toad (p2)'],['beacon','Beacon (p2)'],['clock','Clock (p2)'],['pulsar','Pulsar (p3)'],['penta','Pentadecathlon (p15)'],['figureEight','Figure Eight (p8)'],['tumbler','Tumbler (p14)']]},
  {cat:'Spaceships',items:[['glider','Glider'],['lwss','LWSS'],['mwss','MWSS'],['hwss','HWSS'],['copperhead','Copperhead (c/10)']]},
  {cat:'Guns',items:[['gosper','Gosper Glider Gun']]},
  {cat:'Methuselahs',items:[['rpent','R-Pentomino'],['acorn','Acorn'],['diehard','Diehard'],['thunderbird','Thunderbird'],['piHept','\u03C0-Heptomino'],['bhept','B-Heptomino']]},
  {cat:'Infinite Growth',items:[['inf1','Infinite I'],['inf2','Infinite II']]},
];

function place(k,cx,cy){const p=PAT[k];if(!p)return;p.forEach(([dx,dy])=>{const i=ix(cx+dx,cy+dy);grid[i]=1;age[i]=0})}
function applyPat(){
  const v=$('selPat').value, sc=+$('rScat').value;
  clear();
  if(v.startsWith('rnd-')){const d=parseInt(v.split('-')[1])/100;for(let i=0;i<TOTAL;i++){grid[i]=Math.random()<d?1:0;age[i]=grid[i]?Math.random()*40:-15}}
  else{for(let s=0;s<sc;s++)place(v,Math.floor(Math.random()*W),Math.floor(Math.random()*H))}
  cntPop();updTex();updStats();
}
function randomize(){clear();const d=.12+Math.random()*.28;for(let i=0;i<TOTAL;i++){grid[i]=Math.random()<d?1:0;age[i]=grid[i]?Math.random()*40:-15}cntPop();updTex();updStats()}
function cntPop(){pop=0;for(let i=0;i<TOTAL;i++)if(grid[i])pop++}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// COLOR SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function hex2rgb(h){const r=parseInt(h.slice(1,3),16),g=parseInt(h.slice(3,5),16),b=parseInt(h.slice(5,7),16);return[r,g,b]}
function rgb2hex(r,g,b){return'#'+[r,g,b].map(v=>Math.round(v).toString(16).padStart(2,'0')).join('')}
function clamp(v,min,max){return Math.max(min,Math.min(max,v))}

function getImpactColorData(){
  const rgb=hex2rgb($('cImpact').value);
  const intensity=+$('iImpact').value/100;
  const r=clamp(rgb[0]*intensity,0,255);
  const g=clamp(rgb[1]*intensity,0,255);
  const b=clamp(rgb[2]*intensity,0,255);
  return{
    rgb,intensity,r,g,b,
    three:new THREE.Color(r/255,g/255,b/255),
    css:'rgb('+Math.round(r)+','+Math.round(g)+','+Math.round(b)+')'
  };
}

function getColors(){
  return{
    alive: hex2rgb($('cAlive').value),
    born:  hex2rgb($('cBorn').value),
    dead:  hex2rgb($('cDead').value),
    dots:  hex2rgb($('cDots').value),
    iAlive:+$('iAlive').value/100,
    iBorn: +$('iBorn').value/100,
    iDead: +$('iDead').value/100,
    iDots: +$('iDots').value/100,
  };
}

const PRESETS={
  cm:{alive:'#00ffc8',born:'#ff00aa',dead:'#0a0a14',dots:'#0066ff'},
  go:{alive:'#39ff14',born:'#ff6a00',dead:'#0a100a',dots:'#0044ff'},
  by:{alive:'#00aaff',born:'#ffd500',dead:'#0a0a14',dots:'#0055ff'},
  pg:{alive:'#bf00ff',born:'#39ff14',dead:'#100a14',dots:'#0066ff'},
  fi:{alive:'#ff5000',born:'#ffdc00',dead:'#140804',dots:'#0044cc'},
  oc:{alive:'#00c8ff',born:'#00ffb4',dead:'#040814',dots:'#0055ff'},
  mx:{alive:'#00ff41',born:'#96ff96',dead:'#000800',dots:'#003388'},
};

function applyPreset(key){
  const p=PRESETS[key]; if(!p)return;
  $('cAlive').value=p.alive;
  $('cBorn').value=p.born;
  $('cDead').value=p.dead;
  $('cDots').value=p.dots;
  updTex(); save();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// THREE.JS SCENE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(50,innerWidth/innerHeight,0.1,100);
camera.position.set(0,0,3);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setClearColor(0x0a0a0f);
document.body.appendChild(renderer.domElement);
renderer.domElement.style.cssText='position:fixed;top:0;left:0;z-index:0';

// Mystical skull cursor for wipe mode (canvas-rendered with arcane glow)
const _skullCvs=document.createElement('canvas');_skullCvs.width=40;_skullCvs.height=40;
const _skullCtx=_skullCvs.getContext('2d');
_skullCtx.textAlign='center';_skullCtx.textBaseline='middle';
// Outer mystical aura
_skullCtx.shadowColor='rgba(160,0,255,0.9)';_skullCtx.shadowBlur=12;
_skullCtx.font='26px serif';
_skullCtx.fillStyle='rgba(200,160,255,0.4)';_skullCtx.fillText('\u2620',20,19);
// Inner skull with hot glow
_skullCtx.shadowColor='rgba(255,50,200,0.8)';_skullCtx.shadowBlur=6;
_skullCtx.fillStyle='rgba(240,220,255,0.95)';_skullCtx.fillText('\u2620',20,19);
// Final crisp pass
_skullCtx.shadowBlur=0;_skullCtx.fillStyle='rgba(255,245,255,0.85)';_skullCtx.fillText('\u2620',20,19);
const wipeCursor='url('+_skullCvs.toDataURL()+') 20 20, crosshair';

// Dynamic centering: offset projection so sphere is centered in visible area
let _rw=0,_rh=0;
function updateCameraCenter(){
  // Sync renderer size if viewport changed (handles deferred layout/scrollbar shifts)
  const w=innerWidth,h=innerHeight;
  if(w!==_rw||h!==_rh){_rw=w;_rh=h;renderer.setSize(w,h)}
  camera.aspect=w/h;
  camera.updateProjectionMatrix();

  const topbar=document.getElementById('topbar');
  const panel=document.getElementById('panel');
  const topInset=topbar?topbar.getBoundingClientRect().height:0;
  let leftInset=0,bottomInset=0;

  if(panel){
    const pr=panel.getBoundingClientRect();
    if(innerWidth>768){
      leftInset=Math.max(0,pr.right);
    }else{
      const panelFromBottom=Math.max(0,innerHeight-pr.top);
      bottomInset=Math.max(0,Math.min(innerHeight*0.5,panelFromBottom));
    }
  }

  const usableW=Math.max(1,innerWidth-leftInset);
  const usableH=Math.max(1,innerHeight-topInset-bottomInset);
  const centerX=leftInset+usableW*0.5;
  const centerY=topInset+usableH*0.5;
  const targetNdcX=(centerX/innerWidth)*2-1;
  const targetNdcY=1-(centerY/innerHeight)*2;

  camera.projectionMatrix.elements[8]=-targetNdcX;
  camera.projectionMatrix.elements[9]=-targetNdcY;
  camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
}

let zoom=4;

// Main texture canvas (upscaled for pole distortion correction)
const tc=document.createElement('canvas');tc.width=TW;tc.height=TH;
const tx=tc.getContext('2d');

// Glow source + destination canvases
const glowSrc=document.createElement('canvas');glowSrc.width=W;glowSrc.height=H;
const gsx=glowSrc.getContext('2d');
const glowDst=document.createElement('canvas');glowDst.width=W;glowDst.height=H;
const gdx=glowDst.getContext('2d');

const lifeTex=new THREE.CanvasTexture(tc);
lifeTex.wrapS=THREE.RepeatWrapping;lifeTex.wrapT=THREE.ClampToEdgeWrapping;
lifeTex.minFilter=THREE.LinearFilter;lifeTex.magFilter=THREE.LinearFilter;lifeTex.generateMipmaps=false;

const sphGeo=new THREE.SphereGeometry(1,64,32);

const sphMat=new THREE.MeshStandardMaterial({map:lifeTex,emissiveMap:lifeTex,emissive:new THREE.Color(1,1,1),emissiveIntensity:1.0,roughness:.55,metalness:.15,transparent:true,opacity:.84,depthWrite:false});
const sph=new THREE.Mesh(sphGeo,sphMat);
scene.add(sph);

// Back-face sphere: BasicMaterial (no scene lighting), additive blend glows through front
const sphBackMat=new THREE.MeshBasicMaterial({map:lifeTex,transparent:true,opacity:.15,side:THREE.BackSide,depthWrite:false,blending:THREE.AdditiveBlending});
const sphBack=new THREE.Mesh(sphGeo,sphBackMat);
scene.add(sphBack);
sph.renderOrder=1;
sphBack.renderOrder=2;

// Wireframe grid (no diagonals): only latitude + longitude lines
{var _wSegsW=48,_wSegsH=24,_wR=1.003;
const verts=[],norms=[];
// Build vertex grid [y][x]
const grid2=[];
for(let iy=0;iy<=_wSegsH;iy++){
  const row=[];
  const v=iy/_wSegsH, th=v*Math.PI;
  const sinTh=Math.sin(th), cosTh=Math.cos(th);
  for(let ix=0;ix<=_wSegsW;ix++){
    const u=ix/_wSegsW, ph=u*Math.PI*2;
    const x=-_wR*Math.cos(ph)*sinTh, y=_wR*cosTh, z=_wR*Math.sin(ph)*sinTh;
    row.push([x,y,z]);
  }
  grid2.push(row);
}
const pos=[],nor=[];
function addSeg(a,b){
  pos.push(a[0],a[1],a[2],b[0],b[1],b[2]);
  const na=[a[0]/_wR,a[1]/_wR,a[2]/_wR], nb=[b[0]/_wR,b[1]/_wR,b[2]/_wR];
  nor.push(na[0],na[1],na[2],nb[0],nb[1],nb[2]);
}
// Latitude lines (horizontal rings)
for(let iy=0;iy<=_wSegsH;iy++)
  for(let ix=0;ix<_wSegsW;ix++) addSeg(grid2[iy][ix],grid2[iy][ix+1]);
// Longitude lines (vertical arcs)
for(let ix=0;ix<=_wSegsW;ix++)
  for(let iy=0;iy<_wSegsH;iy++) addSeg(grid2[iy][ix],grid2[iy+1][ix]);
var _wGeo=new THREE.BufferGeometry();
_wGeo.setAttribute('position',new THREE.Float32BufferAttribute(pos,3));
_wGeo.setAttribute('normal',new THREE.Float32BufferAttribute(nor,3));
}
const wireShaderMat=new THREE.ShaderMaterial({
  uniforms:{wColor:{value:new THREE.Color(0x00ffc8)},wOpacity:{value:0.30}},
  vertexShader:`
    varying float vFade;
    void main(){
      vec3 wNorm=normalize(normalMatrix*normal);
      vec3 vDir=normalize(cameraPosition-(modelMatrix*vec4(position,1.0)).xyz);
      vFade=max(0.0,dot(wNorm,vDir));
      gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);
    }`,
  fragmentShader:`
    uniform vec3 wColor;
    uniform float wOpacity;
    varying float vFade;
    void main(){
      float a=wOpacity*mix(0.28,1.0,pow(vFade,1.2));
      gl_FragColor=vec4(wColor,a);
    }`,
  transparent:true,depthWrite:false
});
const wire=new THREE.LineSegments(_wGeo,wireShaderMat);
wire.visible=true;scene.add(wire);
wire.renderOrder=3;

// Lights
scene.add(new THREE.AmbientLight(0x222233,.4));
const l1=new THREE.PointLight(0x00ffc8,.7,12);l1.position.set(3,2,3);scene.add(l1);
const l2=new THREE.PointLight(0xff00aa,.4,12);l2.position.set(-3,-1,2);scene.add(l2);
const l3=new THREE.PointLight(0x4444ff,.3,12);l3.position.set(0,3,-2);scene.add(l3);

// Background stars
const stGeo=new THREE.BufferGeometry();const stPos=new Float32Array(4500);for(let i=0;i<4500;i++)stPos[i]=(Math.random()-.5)*60;
stGeo.setAttribute('position',new THREE.BufferAttribute(stPos,3));
scene.add(new THREE.Points(stGeo,new THREE.PointsMaterial({color:0x334455,size:.04})));

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ROTATION & ZOOM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let dragging=false,pmx=0,pmy=0;
let axisDrag=false,axmx=0,axmy=0;
let rotQ=new THREE.Quaternion();
let autoRot=true,rotSpd=.1;
let rotAxis=new THREE.Vector3(0,1,.3).normalize();
let rotTarget=new THREE.Vector3(0,1,0).normalize();
let axisTimer=0;

renderer.domElement.addEventListener('contextmenu',e=>e.preventDefault());
renderer.domElement.addEventListener('pointerdown',e=>{
  if(e.button===0){
    if(wipeMode){wiping=true;doWipe(e.clientX,e.clientY)}
    else{dragging=true;pmx=e.clientX;pmy=e.clientY}
  } else if(e.button===2){
    axisDrag=true;axmx=e.clientX;axmy=e.clientY;
  }
});
window.addEventListener('pointermove',e=>{
  if(wiping){doWipe(e.clientX,e.clientY);return}
  if(axisDrag){
    const dx=(e.clientX-axmx)*.004,dy=(e.clientY-axmy)*.004;
    const q=new THREE.Quaternion();
    q.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1),dx));
    q.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0),dy));
    rotAxis.applyQuaternion(q).normalize();
    rotTarget.copy(rotAxis);
    axmx=e.clientX;axmy=e.clientY;
    return;
  }
  if(!dragging)return;
  const dx=(e.clientX-pmx)*.006,dy=(e.clientY-pmy)*.006;
  rotQ.premultiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0),dx));
  rotQ.premultiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0),dy));
  pmx=e.clientX;pmy=e.clientY;
});
window.addEventListener('pointerup',()=>{dragging=false;axisDrag=false;wiping=false});

// Wipe: erase cells in radius at raycasted sphere position
function doWipe(cx,cy){
  rcMouse.x=(cx/innerWidth)*2-1;
  rcMouse.y=-(cy/innerHeight)*2+1;
  raycaster.setFromCamera(rcMouse,camera);
  const hits=raycaster.intersectObject(sph);
  if(hits.length>0&&hits[0].uv){
    const g=uvToGrid(hits[0].uv);
    const r2=wipeRadius*wipeRadius;
    for(let dy=-wipeRadius;dy<=wipeRadius;dy++){
      for(let dx=-wipeRadius;dx<=wipeRadius;dx++){
        if(dx*dx+dy*dy<=r2){
          const i=ix(g.x+dx,g.y+dy);
          grid[i]=0;age[i]=Math.min(age[i],-1);meteorAge[i]=0;
        }
      }
    }
    cntPop();updTex();updStats();
  }
}

let pinchD=0;
renderer.domElement.addEventListener('touchstart',e=>{if(e.touches.length===2)pinchD=Math.hypot(e.touches[0].clientX-e.touches[1].clientX,e.touches[0].clientY-e.touches[1].clientY)},{passive:true});
renderer.domElement.addEventListener('touchmove',e=>{if(e.touches.length===2){const d=Math.hypot(e.touches[0].clientX-e.touches[1].clientX,e.touches[0].clientY-e.touches[1].clientY);zoom+=(pinchD-d)*.01;zoom=Math.max(1.5,Math.min(8,zoom));pinchD=d;$('rZoom').value=zoom*10;$('vZoom').textContent=zoom.toFixed(1)}},{passive:true});
renderer.domElement.addEventListener('wheel',e=>{zoom+=e.deltaY*.002;zoom=Math.max(1.5,Math.min(8,zoom));$('rZoom').value=zoom*10;$('vZoom').textContent=zoom.toFixed(1);save()},{passive:true});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RIGHT-CLICK CONTEXT MENU
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const raycaster=new THREE.Raycaster();
const rcMouse=new THREE.Vector2();
let ctxTarget={x:0,y:0};

function showCtxMenu(ex,ey){
  const m=document.getElementById('ctxMenu');
  let html='';
  PAT_MENU.forEach(g=>{
    html+='<div class="ctx-cat">'+g.cat+'</div>';
    g.items.forEach(([k,label])=>{html+='<div class="ctx-item" data-pat="'+k+'">'+label+'</div>'});
  });
  m.innerHTML=html;
  m.style.display='block';
  const mw=m.offsetWidth,mh=m.offsetHeight;
  m.style.left=Math.min(ex,innerWidth-mw-8)+'px';
  m.style.top=Math.min(ey,innerHeight-mh-8)+'px';
  m.querySelectorAll('.ctx-item').forEach(el=>{
    el.onclick=()=>{
      const k=el.dataset.pat;
      place(k,ctxTarget.x,ctxTarget.y);
      cntPop();updTex();updStats();
      hideCtxMenu();
    };
  });
}
function hideCtxMenu(){document.getElementById('ctxMenu').style.display='none'}

function uvToGrid(uv){
  return{
    x:Math.floor(uv.x*W)%W,
    y:Math.floor((1-uv.y)*H)%H
  };
}

renderer.domElement.addEventListener('contextmenu',e=>{
  e.preventDefault();
  rcMouse.x=(e.clientX/innerWidth)*2-1;
  rcMouse.y=-(e.clientY/innerHeight)*2+1;
  raycaster.setFromCamera(rcMouse,camera);
  const hits=raycaster.intersectObject(sph);
  if(hits.length>0&&hits[0].uv){
    const g=uvToGrid(hits[0].uv);
    ctxTarget.x=g.x;ctxTarget.y=g.y;
    showCtxMenu(e.clientX,e.clientY);
  }
});
window.addEventListener('pointerdown',e=>{
  if(!document.getElementById('ctxMenu').contains(e.target))hideCtxMenu();
});
window.addEventListener('keydown',e=>{if(e.key==='Escape')hideCtxMenu()});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// METEOR SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const METEOR_PATS=['glider','blinker','toad','beacon','clock','lwss','rpent','acorn','thunderbird','piHept','bhept','boat','ship','block','beehive','pulsar','figureEight'];

// Glow sprite texture for meteor head (created once, shared)
const meteorGlowCvs=document.createElement('canvas');meteorGlowCvs.width=meteorGlowCvs.height=64;
const _mgx=meteorGlowCvs.getContext('2d');
const _mgg=_mgx.createRadialGradient(32,32,0,32,32,32);
_mgg.addColorStop(0,'rgba(255,255,255,1)');_mgg.addColorStop(0.1,'rgba(230,240,255,0.9)');
_mgg.addColorStop(0.3,'rgba(120,170,255,0.35)');_mgg.addColorStop(0.6,'rgba(50,100,255,0.08)');
_mgg.addColorStop(1,'rgba(0,0,0,0)');
_mgx.fillStyle=_mgg;_mgx.fillRect(0,0,64,64);
const meteorGlowTex=new THREE.CanvasTexture(meteorGlowCvs);

function gridToSurface(gx,gy){
  const u=((gx+0.5)/W)%1, v=clamp((gy+0.5)/H,0,1);
  const theta=v*Math.PI;
  const phi=u*Math.PI*2;
  // Match Three.js SphereGeometry UV convention
  const pt=new THREE.Vector3(
    -Math.cos(phi)*Math.sin(theta),
    Math.cos(theta),
    Math.sin(phi)*Math.sin(theta)
  );
  pt.applyQuaternion(rotQ);
  return pt;
}

// Inverse: world-space point on sphere ‚Üí grid coordinates (matches Three.js UV mapping)
function surfaceToGrid(worldPt){
  const p=worldPt.clone().normalize().applyQuaternion(rotQ.clone().invert());
  const theta=Math.acos(Math.max(-1,Math.min(1,p.y)));
  const phi=Math.atan2(p.z,-p.x);
  const v=theta/Math.PI;
  let u=phi/(Math.PI*2);if(u<0)u+=1;
  return{x:Math.floor(u*W)%W,y:Math.min(H-1,Math.floor(v*H))};
}

function findEmptySpot(){
  let bestX=0,bestY=0,bestScore=Infinity;
  for(let t=0;t<15;t++){
    const tx=Math.floor(Math.random()*W),ty=Math.floor(Math.random()*H);
    let score=0;
    for(let dy=-8;dy<=8;dy++)for(let dx=-8;dx<=8;dx++){
      if(grid[ix(tx+dx,ty+dy)])score++;
    }
    if(score<bestScore){bestScore=score;bestX=tx;bestY=ty}
  }
  return{x:bestX,y:bestY};
}

function scheduleNextMeteor(){
  const minI=Math.max(0.25,meteorInterval*0.45);
  const maxI=Math.max(minI+0.2,meteorInterval*1.55);
  nextMeteorTime=minI+Math.random()*(maxI-minI);
}

function syncActiveMeteorColors(){
  const imp=getImpactColorData();
  const ir=imp.r/255,ig=imp.g/255,ib=imp.b/255;
  for(const m of activeMeteors){
    m.glowMat.color.copy(imp.three);
    m.light.color.copy(imp.three);
    for(let i=0;i<m.trailLen;i++){
      const hm=Math.max(0,1-i/6);
      m.trailColors[i*3]=hm+(1-hm)*ir;
      m.trailColors[i*3+1]=hm+(1-hm)*ig;
      m.trailColors[i*3+2]=hm+(1-hm)*ib;
    }
    m.trailGeo.attributes.color.needsUpdate=true;
  }
}

function spawnMeteor(){
  const patKey=METEOR_PATS[Math.floor(Math.random()*METEOR_PATS.length)];
  const imp=getImpactColorData();

  // Bias 70% of meteors toward camera-visible hemisphere
  const camDir=camera.position.clone().normalize();
  let originDir;
  do{
    const rTh=Math.acos(2*Math.random()-1),rPh=Math.random()*Math.PI*2;
    originDir=new THREE.Vector3(Math.sin(rTh)*Math.cos(rPh),Math.cos(rTh),Math.sin(rTh)*Math.sin(rPh));
  }while(originDir.dot(camDir)<0&&Math.random()<0.6);
  const originDist=3.5+Math.random()*2.0;
  const origin=originDir.clone().multiplyScalar(originDist);

  // Initial velocity: toward sphere center (gravity), small perpendicular deviation
  const toCenter=origin.clone().negate().normalize();
  const baseSpeed=Math.sqrt(2.5/originDist)*0.8; // below escape velocity ‚Üí always captured
  const dev=new THREE.Vector3(Math.random()-.5,Math.random()-.5,Math.random()-.5);
  dev.sub(toCenter.clone().multiplyScalar(dev.dot(toCenter))).normalize();
  const vel=toCenter.clone().multiplyScalar(baseSpeed).add(dev.multiplyScalar(baseSpeed*0.1));

  // White-hot core
  const headGeo=new THREE.SphereGeometry(0.008,6,4);
  const headMat=new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:1.0,depthWrite:false});
  const head=new THREE.Mesh(headGeo,headMat);
  head.position.copy(origin);
  head.renderOrder=8;
  scene.add(head);

  // Bright tip point (small intense white sprite)
  const tipMat=new THREE.SpriteMaterial({map:meteorGlowTex,color:0xffffff,transparent:true,opacity:1.0,depthWrite:false});
  const tip=new THREE.Sprite(tipMat);
  tip.scale.set(0.03,0.03,1);
  tip.renderOrder=9;
  head.add(tip);

  // Soft radial glow sprite (NormalBlending: consistent against any background)
  const glowMat=new THREE.SpriteMaterial({map:meteorGlowTex,color:imp.three,transparent:true,opacity:0.7,depthWrite:false});
  const glow=new THREE.Sprite(glowMat);
  glow.scale.set(0.3,0.3,1);
  glow.renderOrder=7;
  head.add(glow);

  // Trail with per-vertex alpha shader (NormalBlending: no washout against bright sphere)
  const trailLen=80;
  const trailPositions=new Float32Array(trailLen*3);
  for(let i=0;i<trailLen;i++){trailPositions[i*3]=origin.x;trailPositions[i*3+1]=origin.y;trailPositions[i*3+2]=origin.z}
  const trailGeo=new THREE.BufferGeometry();
  trailGeo.setAttribute('position',new THREE.BufferAttribute(trailPositions,3));
  const trailColors=new Float32Array(trailLen*3);
  const trailAlphas=new Float32Array(trailLen);
  const ir=imp.r/255,ig=imp.g/255,ib=imp.b/255;
  for(let i=0;i<trailLen;i++){
    const f=1-i/trailLen,hm=Math.max(0,1-i/6);
    trailColors[i*3]=hm+(1-hm)*ir;
    trailColors[i*3+1]=hm+(1-hm)*ig;
    trailColors[i*3+2]=hm+(1-hm)*ib;
    trailAlphas[i]=Math.pow(f,1.1);
  }
  trailGeo.setAttribute('color',new THREE.BufferAttribute(trailColors,3));
  trailGeo.setAttribute('alpha',new THREE.BufferAttribute(trailAlphas,1));
  const trailMat=new THREE.ShaderMaterial({
    uniforms:{map:{value:meteorGlowTex},uOpacity:{value:1.0}},
    vertexShader:'attribute vec3 color;attribute float alpha;varying vec3 vC;varying float vA;void main(){vC=color;vA=alpha;vec4 mv=modelViewMatrix*vec4(position,1.0);gl_PointSize=max(1.0,50.0/ -mv.z);gl_Position=projectionMatrix*mv;}',
    fragmentShader:'uniform sampler2D map;uniform float uOpacity;varying vec3 vC;varying float vA;void main(){vec4 t=texture2D(map,gl_PointCoord);float a=t.a*vA*uOpacity;if(a<0.01)discard;gl_FragColor=vec4(vC*t.rgb,a);}',
    transparent:true,depthWrite:false
  });
  const trail=new THREE.Points(trailGeo,trailMat);
  trail.renderOrder=5;
  trail.frustumCulled=false; // bounding sphere is stale after spawn ‚Äî never cull trails
  scene.add(trail);

  const light=new THREE.PointLight(imp.three,2.0,6);
  light.position.copy(origin);
  scene.add(light);

  activeMeteors.push({
    head,tip,tipMat,trail,glow,glowMat,trailGeo,trailPositions,trailColors,trailLen,light,
    pos:origin.clone(),vel:vel.clone(),
    patKey, age:0,
    history:[origin.clone()]
  });
}

function updateMeteors(dt){
  const G=2.5; // gravitational constant
  for(let mi=activeMeteors.length-1;mi>=0;mi--){
    const m=activeMeteors[mi];
    const sDt=dt*meteorSpeed*3.0;
    m.age+=dt;

    // Gravitational acceleration toward sphere center
    const rGrav=Math.max(0.1,m.pos.length());
    const prevPos=m.pos.clone();
    const acc=m.pos.clone().normalize().multiplyScalar(-G/(rGrav*rGrav));
    // Symplectic Euler: update velocity, then position
    m.vel.add(acc.multiplyScalar(sDt));
    m.pos.add(m.vel.clone().multiplyScalar(sDt));
    const r=m.pos.length(); // post-update distance for impact check

    m.head.position.copy(m.pos);
    m.light.position.copy(m.pos);

    // Update trail from position history
    m.history.unshift(m.pos.clone());
    if(m.history.length>m.trailLen)m.history.length=m.trailLen;
    for(let i=0;i<m.trailLen;i++){
      const p=i<m.history.length?m.history[i]:m.history[m.history.length-1];
      m.trailPositions[i*3]=p.x;m.trailPositions[i*3+1]=p.y;m.trailPositions[i*3+2]=p.z;
    }
    m.trailGeo.attributes.position.needsUpdate=true;

    // Front/back fade: meteors behind the sphere are drawn much fainter
    const camDir=camera.position.clone().normalize();
    const mDir=m.pos.clone().normalize();
    const facing=camDir.dot(mDir); // +1=facing camera, -1=behind sphere
    const visFactor=facing>0?1.0:Math.max(0.08,0.3+facing*0.5); // behind: 8%-30%
    m.glow.scale.set(0.3,0.3,1);
    m.glowMat.opacity=0.85*visFactor;
    m.head.material.opacity=1.0*visFactor;
    m.tipMat.opacity=1.0*visFactor;
    m.trail.material.uniforms.uOpacity.value=visFactor;
    m.light.intensity=2.0*visFactor;

    // Impact: meteor reached sphere surface (or timeout safety)
    if(r<=1.005||m.age>15){
      // Interpolate to find exact surface crossing point
      const rPrev=prevPos.length();
      let impactPt;
      if(rPrev>1.0&&r<1.0){
        const t=(rPrev-1.0)/(rPrev-r);
        impactPt=prevPos.clone().lerp(m.pos,t).normalize();
      }else{
        impactPt=m.pos.clone().normalize();
      }
      const grid=surfaceToGrid(impactPt);
      place(m.patKey,grid.x,grid.y);
      const pat=PAT[m.patKey];
      if(pat)pat.forEach(([dx,dy])=>{const i=ix(grid.x+dx,grid.y+dy);meteorAge[i]=1.0});
      cntPop();updTex();updStats();
      impactRings.push({cx:grid.x,cy:grid.y,t:0});
      meteorStats[m.patKey]=(meteorStats[m.patKey]||0)+1;
      updMeteorStats();
      showImpactOverlay(m.patKey);
      // Cleanup
      scene.remove(m.head);scene.remove(m.trail);scene.remove(m.light);
      m.head.geometry.dispose();m.head.material.dispose();
      m.tipMat.dispose();
      m.glowMat.dispose();
      m.trailGeo.dispose();m.trail.material.dispose();
      activeMeteors.splice(mi,1);
    }
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// IMPACT OVERLAY ‚Äî multi-frame with per-slot fade
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let impactSlots=[]; // each: {patKey,timer,num,el} or null
let impactNum=0;

// Precompute fixed canvas size from largest meteor pattern (all frames same size)
let _impMaxW=0,_impMaxH=0;
METEOR_PATS.forEach(k=>{const p=PAT[k];if(!p)return;let x0=Infinity,y0=Infinity,x1=-Infinity,y1=-Infinity;p.forEach(([x,y])=>{if(x<x0)x0=x;if(y<y0)y0=y;if(x>x1)x1=x;if(y>y1)y1=y});_impMaxW=Math.max(_impMaxW,x1-x0+1);_impMaxH=Math.max(_impMaxH,y1-y0+1)});
const IMP_CELL=6,IMP_PAD=2,IMP_CVS_W=(_impMaxW+IMP_PAD*2)*IMP_CELL,IMP_CVS_H=(_impMaxH+IMP_PAD*2)*IMP_CELL;

function worldToScreen(v){
  const p=v.clone().project(camera);
  return{
    x:(p.x*0.5+0.5)*innerWidth,
    y:(-p.y*0.5+0.5)*innerHeight
  };
}

function positionImpactOverlay(){
  const overlay=document.getElementById('impactOverlay');
  if(!overlay)return;
  const c=worldToScreen(new THREE.Vector3(0,0,0));
  const e=worldToScreen(new THREE.Vector3(1,0,0));
  const r=Math.max(80,Math.hypot(e.x-c.x,e.y-c.y));
  const gap=Math.max(60,Math.min(140,r*0.5));
  let x=c.x+r+gap;
  let y=c.y-overlay.offsetHeight*0.5;
  x=Math.min(innerWidth-overlay.offsetWidth-10,Math.max(10,x));
  y=Math.min(innerHeight-overlay.offsetHeight-10,Math.max(10,y));
  overlay.style.left=Math.round(x)+'px';
  overlay.style.top=Math.round(y)+'px';
}

function makeImpactCard(patKey,num){
  const imp=getImpactColorData();
  const icR=imp.r,icG=imp.g,icB=imp.b;
  const colStr='rgb('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+')';
  const glowStr='rgba('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+',0.6)';
  const pat=PAT[patKey];if(!pat)return null;
  const card=document.createElement('div');card.className='imp-card';
  const numEl=document.createElement('div');numEl.className='imp-num';numEl.textContent=''+num;numEl.style.color=colStr;
  card.appendChild(numEl);
  const cvs=document.createElement('canvas');cvs.width=IMP_CVS_W;cvs.height=IMP_CVS_H;
  const ctx=cvs.getContext('2d');
  let x0=Infinity,y0=Infinity,x1=-Infinity,y1=-Infinity;
  pat.forEach(([x,y])=>{if(x<x0)x0=x;if(y<y0)y0=y;if(x>x1)x1=x;if(y>y1)y1=y});
  const offX=Math.floor((IMP_CVS_W-(x1-x0+1)*IMP_CELL)/2),offY=Math.floor((IMP_CVS_H-(y1-y0+1)*IMP_CELL)/2);
  pat.forEach(([x,y])=>{
    const px=offX+(x-x0)*IMP_CELL,py=offY+(y-y0)*IMP_CELL;
    ctx.fillStyle='rgba('+Math.round(icR*0.4)+','+Math.round(icG*0.4)+','+Math.round(icB*0.4)+',0.5)';
    ctx.fillRect(px-1,py-1,IMP_CELL+2,IMP_CELL+2);
    ctx.fillStyle='rgba('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+',0.95)';
    ctx.fillRect(px+1,py+1,IMP_CELL-2,IMP_CELL-2);
  });
  card.appendChild(cvs);
  const lbl=document.createElement('div');lbl.className='imp-label';
  lbl.textContent=(PAT_NAMES[patKey]||patKey).toUpperCase();
  lbl.style.color=colStr;lbl.style.textShadow='0 0 10px '+glowStr;
  card.appendChild(lbl);
  card.style.borderColor='rgba('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+',0.35)';
  card.style.boxShadow='0 0 15px rgba('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+',0.15)';
  return card;
}

function syncOverlayChild(idx){
  // Sync one grid cell: show card or invisible placeholder
  const overlay=document.getElementById('impactOverlay');
  const s=impactSlots[idx];
  const child=overlay.children[idx];
  if(s){
    if(child)overlay.replaceChild(s.el,child); else overlay.appendChild(s.el);
  }else{
    const ph=document.createElement('div');ph.className='imp-card';ph.style.visibility='hidden';
    if(child)overlay.replaceChild(ph,child); else overlay.appendChild(ph);
  }
}

function trimOverlay(){
  // Remove trailing empty placeholders + hide overlay if nothing left
  const overlay=document.getElementById('impactOverlay');
  while(impactSlots.length>0&&!impactSlots[impactSlots.length-1]){
    impactSlots.pop();
    if(overlay.lastChild)overlay.removeChild(overlay.lastChild);
  }
  overlay.style.display=impactSlots.length>0?'grid':'none';
}

function showImpactOverlay(patKey,keepTimer=false){
  const overlay=document.getElementById('impactOverlay');
  if(keepTimer){
    // Recolor existing cards in-place (e.g. when impact color changes)
    for(let i=0;i<impactSlots.length;i++){
      const s=impactSlots[i];if(!s)continue;
      const newEl=makeImpactCard(s.patKey,s.num);
      if(newEl){newEl.style.opacity=s.el.style.opacity||'1';s.el=newEl;syncOverlayChild(i)}
    }
    return;
  }
  impactNum++;
  let idx=impactSlots.findIndex(s=>!s);
  if(idx<0)idx=impactSlots.length;
  const el=makeImpactCard(patKey,impactNum);
  if(!el)return;
  impactSlots[idx]={patKey,timer:7.0,num:impactNum,el};
  syncOverlayChild(idx);
  overlay.style.display='grid';
  positionImpactOverlay();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// METEOR STATS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function updMeteorStats(){
  const el=document.getElementById('mStats');
  const entries=Object.entries(meteorStats).sort((a,b)=>b[1]-a[1]);
  if(entries.length===0){el.innerHTML='';return}
  const total=entries.reduce((s,e)=>s+e[1],0);
  const imp=getImpactColorData();
  const soft='rgba('+Math.round(imp.r)+','+Math.round(imp.g)+','+Math.round(imp.b)+',0.72)';
  el.innerHTML='<span style="color:'+soft+'" title="Total meteor impacts since last clear"><span class="ml">Impacts:</span> <span class="mc" style="color:'+imp.css+'">'+total+'</span></span> '+
    entries.slice(0,6).map(([k,v])=>'<span style="color:'+soft+'" title="Number of '+((PAT_NAMES[k]||k))+' patterns delivered by meteor"><span class="ml">'+(PAT_NAMES[k]||k)+':</span> <span class="mc" style="color:'+imp.css+'">'+v+'</span></span>').join(' ');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TEXTURE RENDERING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


function updTex(){
  const c=getColors();
  const img=tx.createImageData(TW,TH);
  const d=img.data;
  const gridOn=$('tGrid').checked;

  const aR=c.alive[0]*c.iAlive, aG=c.alive[1]*c.iAlive, aB=c.alive[2]*c.iAlive;
  const bR=c.born[0]*c.iBorn, bG=c.born[1]*c.iBorn, bB=c.born[2]*c.iBorn;
  const dR=c.dead[0]*c.iDead, dG=c.dead[1]*c.iDead, dB=c.dead[2]*c.iDead;
  const gR=c.dots[0]*c.iDots, gG=c.dots[1]*c.iDots, gB=c.dots[2]*c.iDots;
  // Block-paint with pole correction (reduced height near poles for square cells)
  for(let y=0;y<H;y++){
    const cellH=poleCellH[y];
    const yOff=(TEX_SCALE-cellH)>>1;
    for(let x=0;x<W;x++){
      const i=y*W+x;
      const alive=grid[i];
      let cr,cg,cb;
      if(alive){
        if(age[i]===0){cr=bR;cg=bG;cb=bB}
        else{cr=aR;cg=aG;cb=aB}
        if(cellExposure!==0){
          let L=(cr+cg+cb)/3;
          if(L>0.5){
            let Ln=Math.max(0,L*Math.pow(2,cellExposure));
            Ln=Math.min(255,Ln);
            let s=Ln/L;
            const mx=Math.max(cr,cg,cb)*s;
            if(mx>255)s=255/Math.max(cr,cg,cb);
            cr=Math.max(0,cr*s);cg=Math.max(0,cg*s);cb=Math.max(0,cb*s);
          }
        }
        if(cellSaturation!==0){
          const L=0.299*cr+0.587*cg+0.114*cb;
          const f=1+cellSaturation;
          cr=Math.max(0,Math.min(255,L+(cr-L)*f));
          cg=Math.max(0,Math.min(255,L+(cg-L)*f));
          cb=Math.max(0,Math.min(255,L+(cb-L)*f));
        }
      } else {
        cr=dR;cg=dG;cb=dB;
      }
      const txL=x*TEX_SCALE;
      const tyT=y*TEX_SCALE+yOff;
      if(alive){
        const br=Math.min(255,cr+35),bgr=Math.min(255,cg+35),bbr=Math.min(255,cb+35);
        for(let py=0;py<cellH;py++){
          const rowOff=(tyT+py)*TW;
          const borderY=(py===0||py===cellH-1);
          for(let px=0;px<TEX_SCALE;px++){
            const tp=(rowOff+((txL+px)%TW+TW)%TW)<<2;
            const border=borderY||(px===0||px===TEX_SCALE-1);
            if(border){d[tp]=br;d[tp+1]=bgr;d[tp+2]=bbr}
            else{d[tp]=cr;d[tp+1]=cg;d[tp+2]=cb}
            d[tp+3]=255;
          }
        }
      } else {
        for(let py=0;py<cellH;py++){
          const rowOff=(tyT+py)*TW;
          for(let px=0;px<TEX_SCALE;px++){
            const tp=(rowOff+((txL+px)%TW+TW)%TW)<<2;
            d[tp]=cr;d[tp+1]=cg;d[tp+2]=cb;d[tp+3]=0;
          }
        }
      }
    }
  }
  tx.putImageData(img,0,0);

  // Cell glow aura: computed at base res, scaled up for composite
  if(cellGlow){
    const gi=gsx.createImageData(W,H);
    const gd=gi.data;
    for(let i=0;i<TOTAL;i++){
      const p=i*4;
      if(grid[i]){
        gd[p]=aR;gd[p+1]=aG;gd[p+2]=aB;
        gd[p+3]=255;
      }else{
        gd[p]=0;gd[p+1]=0;gd[p+2]=0;gd[p+3]=0;
      }
    }
    gsx.putImageData(gi,0,0);
    gdx.clearRect(0,0,W,H);
    const blurPx=Math.max(0.6,glowRadius*3.0);
    gdx.filter='blur('+blurPx+'px)';
    gdx.drawImage(glowSrc,0,0);
    gdx.filter='none';
    // Compensate blur energy loss: additive self-compositing restores brightness
    const boostPasses=Math.max(0,Math.ceil(blurPx/6)-1);
    if(boostPasses>0){
      gdx.globalCompositeOperation='lighter';
      for(let bp=0;bp<boostPasses;bp++)gdx.drawImage(glowDst,0,0);
      gdx.globalCompositeOperation='source-over';
    }
    tx.globalCompositeOperation='lighter';
    tx.globalAlpha=Math.min(1.0,glowIntensity*2.0);
    tx.drawImage(glowDst,0,0,TW,TH);
    tx.globalAlpha=1;
    tx.globalCompositeOperation='source-over';
  }

  // Impact shockwave rings (scaled to TW√óTH texture)
  if(impactRings.length>0){
    const impC=hex2rgb($('cImpact').value);
    const impI=+$('iImpact').value/100;
    const S=TEX_SCALE;
    for(const ring of impactRings){
      const r=ring.t*40*S;
      const rcx=(ring.cx+0.5)*S, rcy=(ring.cy+0.5)*S;
      const opacity=Math.max(0,1-ring.t/1.5)*impI;
      if(ring.t<0.6){
        const f=1-ring.t/0.6;
        const flashR=Math.max(3,ring.t*22)*S;
        tx.fillStyle='rgba(255,255,255,'+(f*f*impI).toFixed(3)+')';
        for(const ox of[-TW,0,TW]){tx.beginPath();tx.arc(rcx+ox,rcy,flashR*0.4,0,Math.PI*2);tx.fill()}
        tx.fillStyle='rgba('+impC[0]+','+impC[1]+','+impC[2]+','+(f*impI*0.7).toFixed(3)+')';
        for(const ox of[-TW,0,TW]){tx.beginPath();tx.arc(rcx+ox,rcy,flashR,0,Math.PI*2);tx.fill()}
      }
      const w=Math.max(1,4.5-ring.t*2.5)*S;
      tx.strokeStyle='rgba('+Math.round(impC[0]*opacity)+','+Math.round(impC[1]*opacity)+','+Math.round(impC[2]*opacity)+','+opacity.toFixed(3)+')';
      tx.lineWidth=w;
      for(const ox of[-TW,0,TW]){tx.beginPath();tx.arc(rcx+ox,rcy,r,0,Math.PI*2);tx.stroke()}
      if(ring.t>0.12){
        const r2=(ring.t-0.12)*34*S;
        const op2=Math.max(0,1-(ring.t-0.12)/1.3)*impI*0.45;
        tx.strokeStyle='rgba('+Math.round(impC[0]*op2)+','+Math.round(impC[1]*op2)+','+Math.round(impC[2]*op2)+','+op2.toFixed(3)+')';
        tx.lineWidth=Math.max(0.5,2.5-ring.t*1.5)*S;
        for(const ox of[-TW,0,TW]){tx.beginPath();tx.arc(rcx+ox,rcy,r2,0,Math.PI*2);tx.stroke()}
      }
    }
  }

  // Cross markers at wireframe intersections (fade out from center + bright center dot)
  if(gridOn && c.iDots>0.01){
    const armLen=Math.max(2,dotRadius*TEX_SCALE);
    const steps=Math.ceil(armLen);
    for(let iy=1;iy<_wSegsH;iy++){
      const v=iy/_wSegsH;
      const tyPx=v*TH;
      const th=v*Math.PI;
      const sinTh=Math.max(0.06,Math.sin(th));
      const stretchX=Math.max(1,Math.min(12,1/sinTh)*0.7);
      const cellY=Math.min(H-1,Math.round(v*H));
      for(let ix=0;ix<_wSegsW;ix++){
        const u=ix/_wSegsW;
        const txPx=u*TW;
        const cellX=Math.round(u*W)%W;
        if(!grid[cellY*W+cellX]){
          // Cross arms (solid, fade only at tips)
          const fadePx=Math.min(3,steps);
          for(let s=1;s<=steps;s++){
            const tip=steps-s;
            const a=tip<fadePx?((tip+1)/fadePx*0.7).toFixed(3):'0.700';
            tx.fillStyle='rgba('+Math.round(gR)+','+Math.round(gG)+','+Math.round(gB)+','+a+')';
            const dx=s*stretchX, dy=s;
            tx.fillRect(txPx+dx-0.5,tyPx-0.5,1,1);
            tx.fillRect(txPx-dx-0.5,tyPx-0.5,1,1);
            tx.fillRect(txPx-0.5,tyPx+dy-0.5,1,1);
            tx.fillRect(txPx-0.5,tyPx-dy-0.5,1,1);
          }
          // Bright center dot
          tx.fillStyle='rgba(255,255,255,0.85)';
          tx.beginPath();
          tx.arc(txPx,tyPx,Math.max(0.8,armLen*0.15),0,Math.PI*2);
          tx.fill();
        }
      }
    }
  }

  lifeTex.needsUpdate=true;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// UI WIRING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function $(id){return document.getElementById(id)}
function updPlayBtn(){const b=$('bPlay');b.textContent=running?'‚è∏ Pause':'‚ñ∂ Play';b.classList.toggle('on',running)}
function fmtNum(n){
  if(n<1e6)return n.toLocaleString();
  if(n<1e9)return(n/1e6).toFixed(2)+'M';
  if(n<1e12)return(n/1e9).toFixed(2)+'B';
  return(n/1e12).toFixed(2)+'T';
}
function updStats(){$('sGen').textContent=fmtNum(gen);$('sPop').textContent=fmtNum(pop);$('sPct').textContent=((pop/TOTAL)*100).toFixed(1)+'%'}

$('bPlay').onclick=()=>{running=!running;updPlayBtn();save()};
$('bStep').onclick=()=>{step();updTex();updStats()};
$('bClear').onclick=()=>{clear();meteorStats={};updMeteorStats();updTex();updStats();save()};
$('bApply').onclick=()=>{applyPat();save()};
$('bRand').onclick=()=>{randomize();save()};

$('bWipe').onclick=()=>{wipeMode=!wipeMode;$('bWipe').classList.toggle('on',wipeMode);renderer.domElement.style.cursor=wipeMode?wipeCursor:'';save()};
$('rWipeR').oninput=e=>{wipeRadius=+e.target.value;$('vWipeR').textContent=e.target.value;save()};
$('rSpd').oninput=e=>{speed=+e.target.value;$('vSpd').textContent=speed+' gen/s';save()};
$('tMeteor').onchange=e=>{meteorMode=e.target.checked;meteorTimer=0;scheduleNextMeteor();save()};
$('rMInt').oninput=e=>{meteorInterval=+e.target.value;$('vMInt').textContent=e.target.value+'s';scheduleNextMeteor();save()};
$('rMSpd').oninput=e=>{meteorSpeed=+e.target.value/100;$('vMSpd').textContent=meteorSpeed.toFixed(1);save()};
$('rScat').oninput=e=>{$('vScat').textContent=e.target.value;save()};
$('rZoom').oninput=e=>{zoom=+e.target.value/10;$('vZoom').textContent=zoom.toFixed(1);save()};
$('tRot').onchange=e=>{autoRot=e.target.checked;save()};
$('rRSpd').oninput=e=>{rotSpd=+e.target.value/10;$('vRSpd').textContent=rotSpd.toFixed(1);save()};
$('rGlow').oninput=e=>{const v=+e.target.value/100;sphMat.emissiveIntensity=v;$('vGlow').textContent=v.toFixed(1);save()};
// Grid Dots toggle: always NearestFilter, just controls dot visibility
$('tGrid').onchange=e=>{updTex();save()};
$('tWire').onchange=e=>{wire.visible=e.target.checked;save()};
$('rWireExp').oninput=e=>{const v=+e.target.value/100;wireShaderMat.uniforms.wOpacity.value=v;$('vWireExp').textContent=e.target.value;save()};
// Dot size
$('rDotR').oninput=e=>{dotRadius=+e.target.value/10;$('vDotR').textContent=dotRadius.toFixed(1);updTex();save()};
// Cell glow controls
$('rExposure').oninput=e=>{cellExposure=+e.target.value/6.25;$('vExposure').textContent=e.target.value>0?'+'+e.target.value:e.target.value;updTex();save()};
$('rSaturation').oninput=e=>{cellSaturation=+e.target.value/100;$('vSaturation').textContent=e.target.value>0?'+'+e.target.value:e.target.value;updTex();save()};
$('tCGlow').onchange=e=>{cellGlow=e.target.checked;updTex();save()};
$('rCGR').oninput=e=>{glowRadius=+e.target.value;$('vCGR').textContent=e.target.value;updTex();save()};
$('rCGI').oninput=e=>{glowIntensity=+e.target.value/100;$('vCGI').textContent=glowIntensity.toFixed(1);updTex();save()};


// Theme preset dropdown
$('selTheme').onchange=e=>{applyPreset(e.target.value)};

// Color pickers & intensity sliders ‚Üí live update
['Alive','Born','Dead','Dots','Impact'].forEach(name=>{
  const cEl=$('c'+name), iEl=$('i'+name), ivEl=$('iv'+name);
  const handler=()=>{
    ivEl.textContent=iEl.value+'%';
    if(name==='Impact'){
      syncActiveMeteorColors();
      updMeteorStats();
      if(impactSlots.some(s=>s))showImpactOverlay(null,true);
    }
    updTex();
    save();
  };
  cEl.addEventListener('input',handler);
  iEl.addEventListener('input',handler);
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// LOCAL STORAGE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function save(){
  try{localStorage.setItem('cl-gol2',JSON.stringify({
    speed,zoom,autoRot,rotSpd,meteorMode,meteorInterval,
    grid:$('tGrid').checked,wireframe:$('tWire').checked,wireExp:wireShaderMat.uniforms.wOpacity.value,
    glow:sphMat.emissiveIntensity,
    pat:$('selPat').value,scat:$('rScat').value,
    thm:$('selTheme').value,
    cAlive:$('cAlive').value,cBorn:$('cBorn').value,
    cDead:$('cDead').value,cDots:$('cDots').value,cImpact:$('cImpact').value,
    iAlive:$('iAlive').value,iBorn:$('iBorn').value,
    iDead:$('iDead').value,iDots:$('iDots').value,iImpact:$('iImpact').value,
    dotRadius,cellGlow,glowRadius,glowIntensity,cellExposure,cellSaturation,wipeRadius,meteorSpeed,
  }))}catch(e){}
}

function load(){
  try{
    const r=localStorage.getItem('cl-gol2');if(!r)return;
    const s=JSON.parse(r);
    if(s.speed){speed=s.speed;$('rSpd').value=speed;$('vSpd').textContent=speed+' gen/s'}
    if(s.zoom){zoom=s.zoom;$('rZoom').value=zoom*10;$('vZoom').textContent=zoom.toFixed(1)}
    if(s.autoRot!==undefined){autoRot=s.autoRot;$('tRot').checked=autoRot}
    if(s.rotSpd){rotSpd=s.rotSpd;$('rRSpd').value=rotSpd*10;$('vRSpd').textContent=rotSpd.toFixed(1)}
    if(s.meteorMode!==undefined){meteorMode=s.meteorMode;$('tMeteor').checked=meteorMode}
    if(s.meteorInterval){meteorInterval=s.meteorInterval;$('rMInt').value=meteorInterval;$('vMInt').textContent=meteorInterval+'s'}
    if(s.grid!==undefined){$('tGrid').checked=s.grid}
    if(s.wireframe!==undefined){$('tWire').checked=s.wireframe;wire.visible=s.wireframe}
    if(s.wireExp!==undefined){wireShaderMat.uniforms.wOpacity.value=s.wireExp;$('rWireExp').value=s.wireExp*100;$('vWireExp').textContent=Math.round(s.wireExp*100)}
    if(s.glow!==undefined){sphMat.emissiveIntensity=s.glow;$('rGlow').value=s.glow*100;$('vGlow').textContent=s.glow.toFixed(1)}
    if(s.pat)$('selPat').value=s.pat;
    if(s.scat){$('rScat').value=s.scat;$('vScat').textContent=s.scat}
    if(s.thm)$('selTheme').value=s.thm;
    if(s.cAlive)$('cAlive').value=s.cAlive;
    if(s.cBorn)$('cBorn').value=s.cBorn;
    if(s.cDead)$('cDead').value=s.cDead;
    if(s.cDots)$('cDots').value=s.cDots;
    if(s.cImpact)$('cImpact').value=s.cImpact;
    if(s.iAlive){$('iAlive').value=s.iAlive;$('ivAlive').textContent=s.iAlive+'%'}
    if(s.iBorn){$('iBorn').value=s.iBorn;$('ivBorn').textContent=s.iBorn+'%'}
    if(s.iDead){$('iDead').value=s.iDead;$('ivDead').textContent=s.iDead+'%'}
    if(s.iDots){$('iDots').value=s.iDots;$('ivDots').textContent=s.iDots+'%'}
    if(s.iImpact){$('iImpact').value=s.iImpact;$('ivImpact').textContent=s.iImpact+'%'}
    // New settings
    if(s.dotRadius!==undefined){dotRadius=s.dotRadius;$('rDotR').value=dotRadius*10;$('vDotR').textContent=dotRadius.toFixed(1)}
    if(s.cellGlow!==undefined){cellGlow=s.cellGlow;$('tCGlow').checked=cellGlow}
    if(s.glowRadius!==undefined){glowRadius=s.glowRadius;$('rCGR').value=glowRadius;$('vCGR').textContent=glowRadius}
    if(s.glowIntensity!==undefined){glowIntensity=s.glowIntensity;$('rCGI').value=glowIntensity*100;$('vCGI').textContent=glowIntensity.toFixed(1)}

    if(s.cellExposure!==undefined){cellExposure=s.cellExposure;$('rExposure').value=cellExposure*6.25;const ev=Math.round(cellExposure*6.25);$('vExposure').textContent=ev>0?'+'+ev:''+ev}
    if(s.cellSaturation!==undefined){cellSaturation=s.cellSaturation;$('rSaturation').value=cellSaturation*100;const cv=Math.round(cellSaturation*100);$('vSaturation').textContent=cv>0?'+'+cv:''+cv}
    if(s.wipeRadius!==undefined){wipeRadius=s.wipeRadius;$('rWipeR').value=wipeRadius;$('vWipeR').textContent=wipeRadius}
    if(s.meteorSpeed!==undefined){meteorSpeed=s.meteorSpeed;$('rMSpd').value=meteorSpeed*100;$('vMSpd').textContent=meteorSpeed.toFixed(1)}
    scheduleNextMeteor();
  }catch(e){}
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN LOOP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let lastFrame=0;
const RENDER_INTERVAL=1000/15; // cap GPU rendering at 15 fps
let lastRender=0;
function animate(t){
  requestAnimationFrame(animate);
  const dt=(t-lastFrame)/1000||.016;lastFrame=t;

  if(running&&t-lastTick>=1000/speed){step();updTex();updStats();lastTick=t}

  // Meteor rain (randomized interval)
  if(meteorMode){
    meteorTimer+=dt;
    if(meteorTimer>=nextMeteorTime){meteorTimer=0;scheduleNextMeteor();spawnMeteor()}
  }
  if(activeMeteors.length>0)updateMeteors(dt);
  // Decay meteor flash
  let hasMeteorFlash=false;
  for(let i=0;i<TOTAL;i++){if(meteorAge[i]>0){meteorAge[i]-=dt*0.7;if(meteorAge[i]<0)meteorAge[i]=0;hasMeteorFlash=true}}
  if(hasMeteorFlash&&!running)updTex();
  // Advance and cull impact shockwave rings
  let hasRings=false;
  for(let ri=impactRings.length-1;ri>=0;ri--){
    impactRings[ri].t+=dt;
    if(impactRings[ri].t>1.6)impactRings.splice(ri,1);
    else hasRings=true;
  }
  if(hasRings||hasMeteorFlash)updTex();

  // Impact overlay per-slot fade (1s fade-out)
  {let _impTrim=false;
  for(let i=0;i<impactSlots.length;i++){
    const s=impactSlots[i];if(!s)continue;
    s.timer-=dt;
    if(s.timer<=0){
      impactSlots[i]=null;
      syncOverlayChild(i);
      _impTrim=true;
    }else if(s.timer<=1.0){
      s.el.style.opacity=Math.max(0,s.timer/1.0).toString();
    }
  }
  if(_impTrim)trimOverlay();
  else if(impactSlots.some(s=>s))positionImpactOverlay();}

  if(autoRot&&!dragging){
    axisTimer+=dt;
    if(axisTimer>2+Math.random()*6){rotTarget.set((Math.random()-.5)*2,(Math.random()-.5)*2,(Math.random()-.5)*2).normalize();axisTimer=0}
    rotAxis.lerp(rotTarget,.008).normalize();
    rotQ.premultiply(new THREE.Quaternion().setFromAxisAngle(rotAxis,rotSpd*dt*.4));
  }

  sph.quaternion.copy(rotQ);sphBack.quaternion.copy(rotQ);wire.quaternion.copy(rotQ);
  camera.position.z+=(zoom-camera.position.z)*.1;

  // Only render to GPU at capped framerate
  if(t-lastRender>=RENDER_INTERVAL){
    lastRender=t;
    updateCameraCenter();
    if(impactSlots.some(s=>s))positionImpactOverlay();
    renderer.render(scene,camera);
  }
}

window.addEventListener('resize',()=>{renderer.setSize(innerWidth,innerHeight);updateCameraCenter();positionImpactOverlay()});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// INIT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
load();
scheduleNextMeteor();
randomize();
updStats();
animate(0);

</script>
</body>
</html>
