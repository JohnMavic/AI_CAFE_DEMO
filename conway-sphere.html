<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1.0, user-scalable=no">
<title>Conway's Game of Life &mdash; Sphere Edition</title>
<link rel="icon" href="data:,">
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap');

*{margin:0;padding:0;box-sizing:border-box}
:root{--bg:#0a0a0f;--panel:rgba(12,12,22,0.30);--bdr:rgba(0,255,200,0.22);--cyan:#00ffc8;--mag:#ff00aa;--yel:#e6ff00;--txt:#d8e4f0;--txt2:#92a4b8;--gcyan:0 0 10px rgba(0,255,200,0.35)}
html,body{width:100%;height:100dvh;background:var(--bg);color:var(--txt);font-family:'Rajdhani',sans-serif;overflow:hidden;user-select:none;-webkit-user-select:none}
canvas{display:block;touch-action:none}

#topbar{position:fixed;top:0;left:0;right:0;height:78px;background:var(--panel);backdrop-filter:blur(16px);border-bottom:1px solid var(--bdr);display:flex;align-items:center;justify-content:space-between;padding:0 20px;z-index:100}
#topbar h1{font-family:'Orbitron',sans-serif;font-size:24px;font-weight:700;letter-spacing:3px;background:linear-gradient(90deg,var(--cyan),var(--mag));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
#stats{display:flex;gap:18px;font-size:18px;font-weight:500;color:var(--txt2)}
#stats div{white-space:nowrap;display:flex;align-items:center;gap:2px}
#stats .stat-label{min-width:57px;text-align:right}
#stats em{font-style:normal;color:var(--cyan);font-weight:700;display:inline-block;min-width:93px;text-align:right;font-variant-numeric:tabular-nums;font-feature-settings:'tnum' 1}
#mStats{display:flex;gap:12px;font-size:16.5px;font-weight:500;color:#4488ff;flex-wrap:wrap;max-width:45vw;justify-content:flex-end}
#mStats span{white-space:nowrap;display:inline-flex;align-items:baseline;gap:2px}
#mStats .ml{min-width:78px;text-align:right}
#mStats .mc{color:#66aaff;font-weight:700;min-width:36px;display:inline-block;text-align:right;font-variant-numeric:tabular-nums}

#panel{position:fixed;top:88px;left:10px;width:272px;max-height:calc(100dvh - 102px);overflow-y:auto;overflow-x:hidden;background:var(--panel);backdrop-filter:blur(16px);border:1px solid var(--bdr);border-radius:10px;padding:14px;z-index:100;display:flex;flex-direction:column;gap:12px}
#panel::-webkit-scrollbar{width:3px}
#panel::-webkit-scrollbar-track{background:transparent}
#panel::-webkit-scrollbar-thumb{background:var(--bdr);border-radius:2px}

.sec{border-bottom:1px solid var(--bdr);padding-bottom:12px}
.sec:last-child{border-bottom:none;padding-bottom:0}
.sec-t{font-family:'Orbitron',sans-serif;font-size:9px;font-weight:700;letter-spacing:2px;text-transform:uppercase;color:var(--cyan);margin-bottom:8px}

.row{display:flex;gap:5px;flex-wrap:wrap}
.btn{display:inline-flex;align-items:center;justify-content:center;gap:5px;padding:7px 12px;border:1px solid var(--bdr);border-radius:5px;background:rgba(0,255,200,0.04);color:var(--txt);font-family:'Rajdhani',sans-serif;font-size:12px;font-weight:600;cursor:pointer;transition:all .2s;white-space:nowrap}
.btn:hover{background:rgba(0,255,200,0.1);border-color:var(--cyan);box-shadow:var(--gcyan)}
.btn.on{background:rgba(0,255,200,0.15);border-color:var(--cyan);color:var(--cyan);box-shadow:var(--gcyan)}
.btn.p{background:rgba(0,255,200,0.1);border-color:var(--cyan);color:var(--cyan)}
.btn.p:hover{background:rgba(0,255,200,0.2);box-shadow:0 0 16px rgba(0,255,200,0.4)}
.btn.d{border-color:rgba(255,0,170,0.2);color:var(--mag);background:rgba(255,0,170,0.04)}
.btn.d:hover{background:rgba(255,0,170,0.12);border-color:var(--mag)}
.sim-actions{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:5px}
.sim-actions .btn{min-width:0;padding:6px 8px;font-size:11px;line-height:1.1}

select{width:100%;padding:7px 30px 7px 10px;border:1px solid var(--bdr);border-radius:5px;background:rgba(0,255,200,0.04);color:var(--txt);font-family:'Rajdhani',sans-serif;font-size:12px;font-weight:500;cursor:pointer;outline:none;-webkit-appearance:none;appearance:none;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 5 5-5' stroke='%2300ffc8' stroke-width='1.5' fill='none'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:right 10px center}
select:hover{border-color:var(--cyan)}
select option{background:#151528;color:var(--txt)}
select optgroup{background:#0c0c20;color:var(--cyan);font-style:normal;font-weight:600}

.sg{display:flex;flex-direction:column;gap:3px}
.sl{display:flex;justify-content:space-between;font-size:11px;color:var(--txt2)}
.sl .v{color:var(--yel);font-weight:700}

input[type=range]{-webkit-appearance:none;width:100%;height:3px;border-radius:2px;background:rgba(0,255,200,0.12);outline:none}
input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:14px;height:14px;border-radius:50%;background:var(--cyan);cursor:pointer;box-shadow:0 0 6px rgba(0,255,200,0.5)}
input[type=range]::-moz-range-thumb{width:14px;height:14px;border-radius:50%;background:var(--cyan);cursor:pointer;border:none}

.trow{display:flex;justify-content:space-between;align-items:center;font-size:12px}
.tog{position:relative;width:36px;height:20px;cursor:pointer}
.tog input{opacity:0;width:0;height:0}
.tog-s{position:absolute;inset:0;background:rgba(255,255,255,0.08);border-radius:10px;transition:.3s}
.tog-s::before{content:'';position:absolute;width:14px;height:14px;left:3px;bottom:3px;background:var(--txt2);border-radius:50%;transition:.3s}
.tog input:checked+.tog-s{background:rgba(0,255,200,0.25)}
.tog input:checked+.tog-s::before{transform:translateX(16px);background:var(--cyan);box-shadow:0 0 5px var(--cyan)}

/* Color picker row */
.cpr{display:flex;align-items:center;gap:8px;margin-bottom:6px}
.cpr label{font-size:11px;color:var(--txt2);min-width:80px}
.cpr input[type=color]{-webkit-appearance:none;border:1px solid var(--bdr);border-radius:4px;width:32px;height:22px;padding:0;cursor:pointer;background:transparent}
.cpr input[type=color]::-webkit-color-swatch-wrapper{padding:1px}
.cpr input[type=color]::-webkit-color-swatch{border:none;border-radius:3px}
.cpr input[type=range]{flex:1}
.cpr .iv{font-size:10px;color:var(--yel);font-weight:700;min-width:28px;text-align:right}

#foot{position:fixed;bottom:8px;left:50%;transform:translateX(-50%);background:var(--panel);backdrop-filter:blur(16px);border:1px solid var(--bdr);border-radius:6px;padding:6px 14px;font-size:15px;color:var(--txt2);z-index:100;text-align:center}
#foot kbd{background:rgba(0,255,200,0.08);border:1px solid var(--bdr);border-radius:2px;padding:1px 4px;font-family:'Rajdhani',sans-serif;color:var(--cyan);font-size:15px}

/* Context menu */
#ctxMenu{position:fixed;z-index:200;background:var(--panel);backdrop-filter:blur(20px);border:1px solid var(--cyan);border-radius:8px;padding:6px 0;min-width:180px;max-height:70vh;overflow-y:auto;box-shadow:0 0 20px rgba(0,255,200,0.15),0 8px 32px rgba(0,0,0,0.6)}
#ctxMenu::-webkit-scrollbar{width:3px}
#ctxMenu::-webkit-scrollbar-thumb{background:var(--bdr);border-radius:2px}
.ctx-cat{font-family:'Orbitron',sans-serif;font-size:8px;font-weight:700;letter-spacing:2px;text-transform:uppercase;color:var(--cyan);padding:6px 14px 3px;opacity:.7}
.ctx-item{padding:5px 14px;font-size:12px;font-weight:500;cursor:pointer;transition:all .15s;color:var(--txt)}
.ctx-item:hover{background:rgba(0,255,200,0.12);color:var(--cyan);padding-left:18px}
.ctx-sym{font-size:13px;letter-spacing:1px;opacity:0.8;vertical-align:middle;margin-right:3px}
.imp-sym{font-size:11px;letter-spacing:1px;opacity:0.7;margin-left:4px}

/* Impact overlay &mdash; fixed position right side */
#impactOverlay{position:fixed;right:10px;z-index:150;pointer-events:none;display:none;grid-template-columns:repeat(4,auto);gap:8px}
.imp-card{display:flex;flex-direction:column;align-items:center;gap:4px;background:rgba(8,12,28,0.30);border:1px solid rgba(68,102,255,0.36);border-radius:8px;padding:8px 10px;backdrop-filter:blur(14px)}
.imp-card canvas{image-rendering:pixelated;border-radius:4px}
.imp-num{font-family:'Orbitron',sans-serif;font-size:10px;opacity:0.5;letter-spacing:1px}
.imp-label{font-family:'Orbitron',sans-serif;font-size:10px;letter-spacing:1.5px;text-transform:uppercase;font-weight:700;white-space:nowrap}
#golRules{position:fixed;right:10px;bottom:10px;z-index:149;pointer-events:none;max-width:520px;padding:10px 16px;background:rgba(8,12,28,0.30);border:1px solid var(--bdr);border-radius:8px;backdrop-filter:blur(14px);font-family:'Rajdhani',sans-serif;font-size:16.5px;color:var(--txt2);line-height:1.5;opacity:0;visibility:hidden}
#golRules .rules-title{font-family:'Orbitron',sans-serif;font-size:13.5px;font-weight:700;letter-spacing:2px;color:var(--cyan);opacity:0.7;margin-bottom:5px}
#golRules .rule{margin-bottom:3px}
#golRules .rule em{font-style:normal;color:var(--cyan);font-weight:600}

@media(max-width:768px){
  #panel{width:calc(100% - 20px);max-height:40dvh;top:auto;bottom:10px;left:10px;right:10px}
  #foot{display:none}
  #topbar h1{font-size:18px;letter-spacing:1px}
  #stats{gap:10px;font-size:16.5px}
  #mStats{display:none}
}
</style>
</head>
<body>

<div id="topbar">
  <h1>CONWAY'S LIFE &middot; SPHERE</h1>
  <div id="mStats" title="Meteor impact history &mdash; shows total impacts and per-pattern breakdown of all meteor strikes on the sphere"></div>
  <div id="stats">
    <div title="Generation counter &mdash; the number of simulation steps (ticks) that have been computed since the last reset"><span class="stat-label">Gen:</span> <em id="sGen">0</em></div>
    <div title="Population &mdash; total count of currently living cells on the sphere surface"><span class="stat-label">Pop:</span> <em id="sPop">0</em></div>
    <div title="Alive percentage &mdash; fraction of all cells on the sphere that are currently alive"><span class="stat-label">Alive:</span> <em id="sPct">0%</em></div>
  </div>
</div>

<div id="panel">

  <!-- SIMULATION -->
  <div class="sec">
    <div class="sec-t">Simulation</div>
    <div class="row sim-actions">
      <button class="btn p" id="bPlay" title="Play / Pause &mdash; start or pause the cellular automaton simulation. Each tick computes one generation using Conway's B3/S23 rules on the sphere">&#9654; Play</button>
      <button class="btn" id="bStep" title="Step &mdash; advance the simulation by exactly one generation. Useful for observing how patterns evolve frame by frame">&#9197; Step</button>
      <button class="btn d" id="bClear" title="Clear &mdash; kill all living cells, reset the generation counter to zero, and stop the simulation">&#10005; Clear</button>
      <button class="btn" id="bWipe" title="Wipe mode &mdash; toggle eraser brush. While active, click-drag on the sphere surface to erase cells within the wipe radius">&#9711; Wipe</button>
    </div>
    <div style="height:5px"></div>
    <div class="sg">
      <div class="sl"><span title="Wipe Radius &mdash; diameter of the circular eraser brush used in wipe mode. Larger values erase bigger areas per stroke">Wipe Radius</span><span class="v" id="vWipeR">10</span></div>
      <input type="range" id="rWipeR" min="3" max="40" value="10">
    </div>
    <div style="height:8px"></div>
    <div class="sg">
      <div class="sl"><span title="Speed &mdash; how many generations per second the simulation computes when playing. Higher values make evolution faster">Speed</span><span class="v" id="vSpd">5 gen/s</span></div>
      <input type="range" id="rSpd" min="1" max="60" value="5">
    </div>
    <div style="height:8px"></div>
    <div class="trow">
      <span title="Meteor Rain &mdash; when enabled, random Game of Life patterns are launched as meteors from deep space toward the sphere at randomised intervals, impacting the surface and seeding new life">Meteor Rain</span>
      <label class="tog"><input type="checkbox" id="tMeteor" checked><span class="tog-s"></span></label>
    </div>
    <div style="height:5px"></div>
    <div class="sg">
      <div class="sl"><span title="Meteor Interval &mdash; average time in seconds between meteor spawns. The actual timing is randomised around this value for organic variety">Meteor Interval</span><span class="v" id="vMInt">1s</span></div>
      <input type="range" id="rMInt" min="1" max="15" value="1">
    </div>
    <div style="height:5px"></div>
    <div class="sg">
      <div class="sl"><span title="Meteor Speed &mdash; controls how fast meteors travel through space toward the sphere. Higher values make them arrive more quickly">Meteor Speed</span><span class="v" id="vMSpd">0.1</span></div>
      <input type="range" id="rMSpd" min="10" max="150" value="10">
    </div>
  </div>

  <!-- PATTERNS -->
  <div class="sec">
    <div class="sec-t">Initial State</div>
    <select id="selPat" title="Pattern selector &mdash; choose a Game of Life pattern to place on the sphere. Random seeds fill the entire surface; named patterns are placed at random positions based on the Pattern Copies count">
      <optgroup label="--- Random Seeds ---">
        <option value="rnd-15">Random Sparse (15%)</option>
        <option value="rnd-30">Random Medium (30%)</option>
        <option value="rnd-50">Random Dense (50%)</option>
      </optgroup>
      <optgroup label="--- Still Lifes ---">
        <option value="block">Block</option>
        <option value="beehive">Beehive</option>
        <option value="loaf">Loaf</option>
        <option value="tub">Tub</option>
        <option value="boat">Boat</option>
        <option value="ship">Ship</option>
        <option value="pond">Pond</option>
      </optgroup>
      <optgroup label="--- Oscillators ---">
        <option value="blinker">Blinker (p2)</option>
        <option value="toad">Toad (p2)</option>
        <option value="beacon">Beacon (p2)</option>
        <option value="clock">Clock (p2)</option>
        <option value="pulsar">Pulsar (p3)</option>
        <option value="penta">Pentadecathlon (p15)</option>
        <option value="figureEight">Figure Eight (p8)</option>
        <option value="tumbler">Tumbler (p14)</option>
      </optgroup>
      <optgroup label="--- Spaceships ---">
        <option value="glider">Glider (c/4 diagonal)</option>
        <option value="lwss">Lightweight Spaceship</option>
        <option value="mwss">Middleweight Spaceship</option>
        <option value="hwss">Heavyweight Spaceship</option>
        <option value="copperhead">Copperhead (c/10)</option>
      </optgroup>
      <optgroup label="--- Guns / Factories ---">
        <option value="gosper">Gosper Glider Gun (Factory)</option>
      </optgroup>
      <optgroup label="--- Methuselahs ---">
        <option value="rpent">R-Pentomino (1103 gen)</option>
        <option value="acorn">Acorn (5206 gen)</option>
        <option value="diehard">Diehard (130 gen)</option>
        <option value="thunderbird">Thunderbird</option>
        <option value="piHept">&pi;-Heptomino</option>
        <option value="bhept">B-Heptomino</option>
      </optgroup>
      <optgroup label="--- Infinite Growth ---">
        <option value="inf1">Infinite Growth I</option>
        <option value="inf2">Infinite Growth II</option>
      </optgroup>
    </select>
    <div style="height:6px"></div>
    <div class="row">
      <button class="btn p" id="bApply" title="Apply &mdash; clear the sphere and place the selected pattern. Random seeds fill the whole surface; named patterns are scattered as copies at random locations">Apply</button>
      <button class="btn" id="bRand" title="Randomize &mdash; clear the sphere and fill it with a random density of living cells (12&ndash;40%). Quick way to get unpredictable starting conditions">&#127922; Randomize</button>
    </div>
    <div style="height:6px"></div>
    <div class="sg">
      <div class="sl"><span title="Pattern Copies &mdash; how many copies of the selected pattern are scattered across the sphere when Apply is pressed. Only used for named patterns, not for random seeds">Pattern Copies</span><span class="v" id="vScat">8</span></div>
      <input type="range" id="rScat" min="1" max="40" value="8">
    </div>
  </div>

  <!-- CAMERA -->
  <div class="sec">
    <div class="sec-t">Camera</div>
    <div class="sg">
      <div class="sl"><span title="Zoom Distance &mdash; how far the camera is from the sphere. Lower values zoom in closer, higher values zoom out for a wider field of view">Zoom Distance</span><span class="v" id="vZoom">4.0</span></div>
      <input type="range" id="rZoom" min="15" max="80" value="40">
    </div>
    <div style="height:8px"></div>
    <div class="trow">
      <span title="Auto-Rotate &mdash; slowly and randomly rotate the sphere so all areas are visible over time. The rotation axis drifts organically for a cinematic effect">Auto-Rotate</span>
      <label class="tog"><input type="checkbox" id="tRot" checked><span class="tog-s"></span></label>
    </div>
    <div style="height:5px"></div>
    <div class="sg">
      <div class="sl"><span title="Rotation Speed &mdash; how fast the sphere auto-rotates. Higher values spin the sphere faster">Rotation Speed</span><span class="v" id="vRSpd">0.1</span></div>
      <input type="range" id="rRSpd" min="1" max="30" value="1">
    </div>
  </div>

  <!-- APPEARANCE -->
  <div class="sec">
    <div class="sec-t">Appearance</div>
    <div class="sg">
      <div class="sl"><span title="Emissive Glow &mdash; overall self-illumination intensity of the sphere. At 0 the sphere is only lit by scene lights; at max it glows brightly from within">Emissive Glow</span><span class="v" id="vGlow">1.0</span></div>
      <input type="range" id="rGlow" min="0" max="100" value="100">
    </div>
    <div style="height:6px"></div>
    <div class="trow">
      <span title="Grid Dots &mdash; toggle small circular reference dots on the sphere surface. These dots show the underlying cell grid structure on dead cells">Grid Dots</span>
      <label class="tog"><input type="checkbox" id="tGrid" checked><span class="tog-s"></span></label>
    </div>
    <div style="height:5px"></div>
    <div class="sg">
      <div class="sl"><span title="Dot Size &mdash; radius of the grid reference dots on the sphere. Larger dots make the grid structure more visible">Dot Size</span><span class="v" id="vDotR">0.8</span></div>
      <input type="range" id="rDotR" min="3" max="25" value="8">
    </div>
    <div style="height:6px"></div>
    <div class="sg">
      <div class="sl"><span title="Cell Exposure &mdash; brightens or darkens living cells. Positive values boost brightness and contrast, negative values dim them. Works like camera exposure compensation">Cell Exposure</span><span class="v" id="vExposure">+100</span></div>
      <input type="range" id="rExposure" min="-100" max="100" value="100">
    </div>
    <div style="height:4px"></div>
    <div class="sg">
      <div class="sl"><span title="Cell Saturation &mdash; adjusts colour richness of living cells. Positive values make colours more vivid, negative values desaturate toward greyscale">Cell Saturation</span><span class="v" id="vSaturation">+100</span></div>
      <input type="range" id="rSaturation" min="-100" max="100" value="100">
    </div>
    <div style="height:4px"></div>
    <div class="sg">
      <div class="sl"><span title="Day/Night Strength &mdash; controls the invisible top-right side light. 0 disables hemisphere shading, higher values increase bright-side milkiness and dark-side shading">Day/Night Strength</span><span class="v" id="vDayNight">50%</span></div>
      <input type="range" id="rDayNight" min="0" max="200" value="100">
    </div>
    <div style="height:6px"></div>
    <div class="trow">
      <span title="Cell Glow &mdash; adds a soft bloom aura around living cells. Creates a neon-like glow effect whose radius and intensity can be fine-tuned below">Cell Glow</span>
      <label class="tog"><input type="checkbox" id="tCGlow" checked><span class="tog-s"></span></label>
    </div>
    <div style="height:5px"></div>
    <div class="sg">
      <div class="sl"><span title="Glow Radius &mdash; blur radius of the cell glow aura. Larger values create a wider, softer bloom around living cells">Glow Radius</span><span class="v" id="vCGR">5</span></div>
      <input type="range" id="rCGR" min="1" max="20" value="5">
    </div>
    <div style="height:3px"></div>
    <div class="sg">
      <div class="sl"><span title="Glow Intensity &mdash; brightness of the cell glow aura. Higher values produce a more visible bloom effect">Glow Intensity</span><span class="v" id="vCGI">0.1</span></div>
      <input type="range" id="rCGI" min="10" max="100" value="10">
    </div>
    <div style="height:6px"></div>
    <div class="trow">
      <span title="Wireframe &mdash; overlay a geometric wireframe grid on the sphere surface. Fades based on viewing angle: bright on front-facing areas, transparent on edges">Wireframe</span>
      <label class="tog"><input type="checkbox" id="tWire" checked><span class="tog-s"></span></label>
    </div>
    <div style="height:4px"></div>
    <div class="sg">
      <div class="sl"><span title="Wire Exposure &mdash; brightness of the wireframe overlay. Higher values make the wireframe more visible against the sphere texture">Wire Exposure</span><span class="v" id="vWireExp">30</span></div>
      <input type="range" id="rWireExp" min="1" max="80" value="30">
    </div>
  </div>

  <!-- COLORS -->
  <div class="sec">
    <div class="sec-t">Colors</div>

    <div class="cpr" title="Alive colour &mdash; the base colour and brightness of living cells that have survived at least a few generations. This is the dominant colour visible on the sphere">
      <label>Alive</label>
      <input type="color" id="cAlive" value="#00ffc8">
      <input type="range" id="iAlive" min="10" max="100" value="100">
      <span class="iv" id="ivAlive">100%</span>
    </div>

    <div class="cpr" title="Born colour &mdash; the flash colour of cells in their first few generations of life. They transition from this colour to the Alive colour over ~3 ticks">
      <label>Born</label>
      <input type="color" id="cBorn" value="#ff00aa">
      <input type="range" id="iBorn" min="10" max="100" value="100">
      <span class="iv" id="ivBorn">100%</span>
    </div>

    <div class="cpr" title="Dead / Background colour &mdash; the colour of cells that are currently dead. Also serves as the sphere's background colour in areas with no activity">
      <label>Dead / BG</label>
      <input type="color" id="cDead" value="#0a0a14">
      <input type="range" id="iDead" min="10" max="100" value="100">
      <span class="iv" id="ivDead">100%</span>
    </div>

    <div class="cpr" title="Grid Dots colour &mdash; the colour and brightness of the small reference dots overlaid on the sphere surface. Only visible when Grid Dots is enabled">
      <label>Grid Dots</label>
      <input type="color" id="cDots" value="#0066ff">
      <input type="range" id="iDots" min="0" max="100" value="60">
      <span class="iv" id="ivDots">60%</span>
    </div>

    <div class="cpr" title="Impact colour &mdash; the colour used for meteor shockwave rings, the impact overlay cards, and the meteor statistics in the top bar">
      <label>Impact</label>
      <input type="color" id="cImpact" value="#4488ff">
      <input type="range" id="iImpact" min="10" max="100" value="100">
      <span class="iv" id="ivImpact">100%</span>
    </div>

    <div style="height:4px"></div>
    <div class="sl" style="margin-bottom:4px"><span title="Preset Themes &mdash; one-click colour schemes that set all five colour channels at once. You can further fine-tune individual colours after selecting a theme">Preset Themes</span></div>
    <select id="selTheme" title="Preset Themes &mdash; load a pre-configured colour scheme. Each preset changes Alive, Born, Dead, Grid Dots colours simultaneously">
      <option value="cm">Cyan & Magenta</option>
      <option value="go">Green & Orange</option>
      <option value="by">Blue & Yellow</option>
      <option value="pg">Purple & Green</option>
      <option value="fi">Fire</option>
      <option value="oc">Ocean</option>
      <option value="mx">Matrix</option>
    </select>
  </div>

</div>

<div id="ctxMenu" style="display:none"></div>
<div id="impactOverlay"></div>
<div id="golRules">
  <div class="rules-title">Conway's Game of Life &mdash; Rules</div>
  <div class="rule"><em>1. Birth:</em> A dead cell with exactly <em>3</em> living neighbours becomes alive.</div>
  <div class="rule"><em>2. Survival:</em> A living cell with <em>2</em> or <em>3</em> living neighbours stays alive.</div>
  <div class="rule"><em>3. Death:</em> All other living cells die &mdash; by underpopulation (&lt;2) or overcrowding (&gt;3).</div>
</div>

<div id="foot">
  <kbd>Drag</kbd> Rotate &middot; <kbd>Scroll</kbd> Zoom &middot; <kbd>Right-click</kbd> Place Pattern &middot; <kbd>Wipe</kbd> Erase Region &middot; Spherical Game of Life
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>

// ========================================
// ENGINE
// ========================================
const W=400, H=200, TOTAL=W*H, HW=W>>1;
let grid=new Uint8Array(TOTAL), buf=new Uint8Array(TOTAL), age=new Float32Array(TOTAL);
let gen=0, pop=0, running=false, speed=5, lastTick=0;
let meteorMode=true, meteorInterval=1, meteorTimer=0, nextMeteorTime=1;
let meteorSpeed=0.1;
let meteorAge=new Float32Array(TOTAL);
const meteorFlashMark=new Uint8Array(TOTAL);
const meteorFlashIdx=[];
let activeMeteors=[];
let meteorStats={};
const MAX_ACTIVE_METEORS=24;
let meteorsSinceLastNuke=100;

// Appearance state
let dotRadius=0.8, cellGlow=true, glowRadius=5, glowIntensity=0.1, cellExposure=16, cellSaturation=1;
let dayNightStrength=1.0;
const CELL_GLOSS_HI_STRENGTH=0.12;  // subtle local glint (not point-like)
const CELL_GLOSS_SH_STRENGTH=0.05;  // subtle opposite-side shading
const cellGlossCache=[];

// Wipe mode
let wipeMode=false, wipeRadius=10, wiping=false;

// Impact shockwave rings
let impactRings=[];

// Texture upscale for pole distortion correction
const TEX_SCALE=10, TW=W*TEX_SCALE, TH=H*TEX_SCALE;
const hemiLightDir={x:0.70,y:0.60,z:0.38}; // invisible light from top-right
const HEMI_MILK_STRENGTH=0.08; // lit hemisphere -> slightly milkier
const HEMI_DARK_STRENGTH=0.06; // opposite hemisphere -> slightly darker
const USE_TEXTURE_HEMI=false; // Day/Night is handled in sphere shader for visible, stable effect.
const poleStretch=new Float32Array(H);
const poleCellH=new Uint8Array(H);
const rowSinTh=new Float32Array(H);
const rowCosTh=new Float32Array(H);
const colCosPh=new Float32Array(W);
const colSinPh=new Float32Array(W);
for(let y=0;y<H;y++){
  const th=(y+0.5)/H*Math.PI;
  const sinRaw=Math.sin(th);
  const sinTh=Math.max(0.06,sinRaw);
  rowSinTh[y]=sinRaw;
  rowCosTh[y]=Math.cos(th);
  poleStretch[y]=Math.min(12,1/sinTh);
  poleCellH[y]=Math.max(1,Math.round(TEX_SCALE*sinTh));
}
for(let x=0;x<W;x++){
  const ph=(x+0.5)/W*Math.PI*2;
  colCosPh[x]=Math.cos(ph);
  colSinPh[x]=Math.sin(ph);
}

function getCellGlossMask(cellH){
  let m=cellGlossCache[cellH];
  if(m)return m;
  const len=TEX_SCALE*cellH;
  const hi=new Float32Array(len);
  const sh=new Float32Array(len);
  for(let py=0;py<cellH;py++){
    const v=(py+0.5)/cellH;
    for(let px=0;px<TEX_SCALE;px++){
      const u=(px+0.5)/TEX_SCALE;
      // Broad top-right highlight, like a soft side light.
      const hdx=(u-0.74)/0.95, hdy=(v-0.30)/0.78;
      let hv=1-(hdx*hdx+hdy*hdy);
      if(hv<0)hv=0;
      // Opposite-side soft shading to preserve spherical depth.
      const sdx=(u-0.28)/0.98, sdy=(v-0.76)/0.88;
      let sv=1-(sdx*sdx+sdy*sdy);
      if(sv<0)sv=0;
      const gi=py*TEX_SCALE+px;
      hi[gi]=hv*hv*hv*CELL_GLOSS_HI_STRENGTH;
      sh[gi]=sv*sv*CELL_GLOSS_SH_STRENGTH;
    }
  }
  m={hi,sh};
  cellGlossCache[cellH]=m;
  return m;
}

// Spherical polar topology: reflect at poles with x+W/2 offset
function ix(x,y){
  if(y<0){y=-y-1;x+=HW}
  else if(y>=H){y=2*H-1-y;x+=HW}
  if(y<0)y=0;if(y>=H)y=H-1;
  return y*W+((x%W+W)%W);
}

function nb(x,y){let n=0;for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){if(!dx&&!dy)continue;if(grid[ix(x+dx,y+dy)])n++}return n}

function step(){
  pop=0;
  for(let y=0;y<H;y++)for(let x=0;x<W;x++){
    const i=y*W+x,n=nb(x,y),alive=grid[i];
    buf[i]=alive?(n===2||n===3?1:0):(n===3?1:0);
    if(buf[i]){age[i]=alive?Math.min(age[i]+1,80):0;pop++}
    else{age[i]=alive?-1:Math.min(age[i],-1)}
  }
  [grid,buf]=[buf,grid]; gen++;
}

function clear(){
  grid.fill(0);buf.fill(0);age.fill(-15);meteorAge.fill(0);
  meteorFlashMark.fill(0);meteorFlashIdx.length=0;
  meteorsSinceLastNuke=100;
  gen=0;pop=0;running=false;updPlayBtn();
}

// Patterns
const PAT={
  block:[[0,0],[1,0],[0,1],[1,1]],
  beehive:[[1,0],[2,0],[0,1],[3,1],[1,2],[2,2]],
  loaf:[[1,0],[2,0],[0,1],[3,1],[1,2],[3,2],[2,3]],
  tub:[[1,0],[0,1],[2,1],[1,2]],
  blinker:[[0,0],[1,0],[2,0]],
  toad:[[1,0],[2,0],[3,0],[0,1],[1,1],[2,1]],
  beacon:[[0,0],[1,0],[0,1],[3,2],[2,3],[3,3]],
  pulsar:(()=>{const c=[];for(const x of[2,3,4,8,9,10])for(const y of[0,5,7,12])c.push([x,y]);for(const y of[2,3,4,8,9,10])for(const x of[0,5,7,12])c.push([x,y]);return c})(),
  penta:[[1,0],[2,0],[3,0],[0,1],[4,1],[0,2],[4,2],[1,3],[2,3],[3,3],[1,6],[2,6],[3,6],[0,7],[4,7],[0,8],[4,8],[1,9],[2,9],[3,9]],
  glider:[[1,0],[2,1],[0,2],[1,2],[2,2]],
  lwss:[[1,0],[4,0],[0,1],[0,2],[4,2],[0,3],[1,3],[2,3],[3,3]],
  mwss:[[2,0],[0,1],[4,1],[5,2],[0,3],[5,3],[1,4],[2,4],[3,4],[4,4],[5,4]],
  hwss:[[2,0],[3,0],[0,1],[5,1],[6,2],[0,3],[6,3],[1,4],[2,4],[3,4],[4,4],[5,4],[6,4]],
  gosper:[[24,0],[22,1],[24,1],[12,2],[13,2],[20,2],[21,2],[34,2],[35,2],[11,3],[15,3],[20,3],[21,3],[34,3],[35,3],[0,4],[1,4],[10,4],[16,4],[20,4],[21,4],[0,5],[1,5],[10,5],[14,5],[16,5],[17,5],[22,5],[24,5],[10,6],[16,6],[24,6],[11,7],[15,7],[12,8],[13,8]],
  rpent:[[1,0],[2,0],[0,1],[1,1],[1,2]],
  acorn:[[1,0],[3,1],[0,2],[1,2],[4,2],[5,2],[6,2]],
  diehard:[[6,0],[0,1],[1,1],[1,2],[5,2],[6,2],[7,2]],
  inf1:[[0,0],[2,0],[2,1],[4,2],[4,3],[4,4],[6,3],[6,4],[6,5],[7,4]],
  inf2:[[0,0],[1,0],[2,0],[4,0],[0,1],[3,2],[4,2],[1,3],[2,3],[0,4],[1,4],[2,4]],
  boat:[[0,0],[1,0],[0,1],[2,1],[1,2]],
  ship:[[0,0],[1,0],[0,1],[2,1],[1,2],[2,2]],
  pond:[[1,0],[2,0],[0,1],[3,1],[0,2],[3,2],[1,3],[2,3]],
  clock:[[2,0],[0,1],[1,1],[2,2],[3,2],[1,3]],
  figureEight:[[0,0],[1,0],[2,0],[0,1],[1,1],[2,1],[0,2],[1,2],[2,2],[3,3],[4,3],[5,3],[3,4],[4,4],[5,4],[3,5],[4,5],[5,5]],
  tumbler:[[1,0],[5,0],[1,1],[5,1],[1,2],[2,2],[4,2],[5,2],[0,3],[2,3],[4,3],[6,3],[0,4],[2,4],[4,4],[6,4],[0,5],[1,5],[5,5],[6,5]],
  thunderbird:[[0,0],[1,0],[2,0],[1,2],[1,3],[1,4]],
  piHept:[[0,0],[1,0],[2,0],[0,1],[2,1],[0,2],[2,2]],
  bhept:[[1,0],[0,1],[1,1],[2,1],[0,2],[2,2],[1,3]],
  copperhead:[[1,0],[2,0],[4,0],[5,0],[3,1],[4,1],[3,2],[4,2],[0,3],[2,3],[5,3],[7,3],[0,4],[7,4],[0,6],[7,6],[1,7],[2,7],[5,7],[6,7],[2,8],[3,8],[4,8],[5,8],[3,10],[4,10],[3,11],[4,11]],
};

// Pattern display names
const PAT_NAMES={
  block:'Block',beehive:'Beehive',loaf:'Loaf',tub:'Tub',boat:'Boat',ship:'Ship',pond:'Pond',
  blinker:'Blinker',toad:'Toad',beacon:'Beacon',clock:'Clock',pulsar:'Pulsar',penta:'Pentadec.',
  figureEight:'Fig.Eight',tumbler:'Tumbler',
  glider:'Glider',lwss:'LWSS',mwss:'MWSS',hwss:'HWSS',copperhead:'Copperhead',
  gosper:'Gosper Gun',rpent:'R-Pento',acorn:'Acorn',diehard:'Diehard',
  thunderbird:'Thunder',piHept:'\u03C0-Hept',bhept:'B-Hept',
  inf1:'Inf.I',inf2:'Inf.II',nuke:'Nuke',
};

// Braille pattern symbol generator (renders pattern as Unicode braille art)
function patternToBraille(patKey){
  const pat=PAT[patKey];
  if(!pat||pat.length===0)return '';
  let x0=Infinity,y0=Infinity,x1=-Infinity,y1=-Infinity;
  pat.forEach(([x,y])=>{x0=Math.min(x0,x);y0=Math.min(y0,y);x1=Math.max(x1,x);y1=Math.max(y1,y)});
  const ow=x1-x0+1,oh=y1-y0+1;
  const maxW=10,maxH=4;
  const sc=Math.max(1,ow/maxW,oh/maxH);
  const ew=Math.min(maxW,Math.ceil(ow/sc)),eh=Math.min(maxH,Math.ceil(oh/sc));
  const cells=new Set();
  pat.forEach(([x,y])=>{cells.add((x-x0)+','+(y-y0))});
  const g=[];
  for(let y=0;y<eh;y++){g[y]=[];for(let x=0;x<ew;x++){
    let found=false;
    const sx=Math.floor(x*sc),sy=Math.floor(y*sc),ex=Math.ceil((x+1)*sc),ey=Math.ceil((y+1)*sc);
    for(let oy=sy;oy<ey&&!found;oy++)for(let ox=sx;ox<ex&&!found;ox++)if(cells.has(ox+','+oy))found=true;
    g[y][x]=found;
  }}
  const cw=Math.ceil(ew/2);
  let r='';
  for(let cx=0;cx<cw;cx++){
    let c=0x2800;
    const bits=[[0,0,0x01],[0,1,0x02],[0,2,0x04],[0,3,0x40],[1,0,0x08],[1,1,0x10],[1,2,0x20],[1,3,0x80]];
    for(const[dx,dy,bit]of bits){
      const gx=cx*2+dx,gy=dy;
      if(gx<ew&&gy<eh&&g[gy][gx])c|=bit;
    }
    r+=String.fromCharCode(c);
  }
  return r;
}
const PAT_BRAILLE={};
Object.keys(PAT).forEach(k=>{PAT_BRAILLE[k]=patternToBraille(k)});
PAT_BRAILLE.nuke='\u2620';

function initPatternSymbols(){
  document.querySelectorAll('#selPat option').forEach(opt=>{
    const k=opt.value;
    if(PAT_BRAILLE[k])opt.textContent=opt.textContent+' '+PAT_BRAILLE[k];
  });
}

// Pattern metadata for context menu
const PAT_MENU=[
  {cat:'Still Lifes',items:[['block','Block'],['beehive','Beehive'],['loaf','Loaf'],['tub','Tub'],['boat','Boat'],['ship','Ship'],['pond','Pond']]},
  {cat:'Oscillators',items:[['blinker','Blinker (p2)'],['toad','Toad (p2)'],['beacon','Beacon (p2)'],['clock','Clock (p2)'],['pulsar','Pulsar (p3)'],['penta','Pentadecathlon (p15)'],['figureEight','Figure Eight (p8)'],['tumbler','Tumbler (p14)']]},
  {cat:'Spaceships',items:[['glider','Glider'],['lwss','LWSS'],['mwss','MWSS'],['hwss','HWSS'],['copperhead','Copperhead (c/10)']]},
  {cat:'Guns',items:[['gosper','Gosper Glider Gun']]},
  {cat:'Methuselahs',items:[['rpent','R-Pentomino'],['acorn','Acorn'],['diehard','Diehard'],['thunderbird','Thunderbird'],['piHept','\u03C0-Heptomino'],['bhept','B-Heptomino']]},
  {cat:'Infinite Growth',items:[['inf1','Infinite I'],['inf2','Infinite II']]},
];

function place(k,cx,cy){const p=PAT[k];if(!p)return;p.forEach(([dx,dy])=>{const i=ix(cx+dx,cy+dy);grid[i]=1;age[i]=0})}
function rotatePatternOffsets(pat,angleRad){
  // Keep canonical pattern integrity by rotating in 90-degree steps,
  // while still drawing a random 0..360-degree start angle per placement.
  const quarter=((Math.round(angleRad/(Math.PI*0.5))%4)+4)%4;
  if(quarter===0)return pat;

  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for(let i=0;i<pat.length;i++){
    const x=pat[i][0],y=pat[i][1];
    if(x<minX)minX=x;if(y<minY)minY=y;
    if(x>maxX)maxX=x;if(y>maxY)maxY=y;
  }
  const cx=(minX+maxX)/2,cy=(minY+maxY)/2;
  const out=[],seen=new Set();
  for(let i=0;i<pat.length;i++){
    const x=pat[i][0]-cx,y=pat[i][1]-cy;
    let rx,ry;
    if(quarter===1){rx=y;ry=-x}
    else if(quarter===2){rx=-x;ry=-y}
    else{rx=-y;ry=x}
    const nx=Math.round(rx+cx),ny=Math.round(ry+cy);
    const key=nx+','+ny;
    if(!seen.has(key)){seen.add(key);out.push([nx,ny])}
  }
  return out;
}
function placeRandomOriented(k,cx,cy,angleRad,spawnAge=0){
  const p=PAT[k];if(!p)return null;
  const a=angleRad===undefined?Math.random()*Math.PI*2:angleRad;
  const rp=rotatePatternOffsets(p,a);
  rp.forEach(([dx,dy])=>{const i=ix(cx+dx,cy+dy);grid[i]=1;age[i]=spawnAge});
  return rp;
}
function applyPat(){
  const v=$('selPat').value, sc=+$('rScat').value;
  clear();
  if(v.startsWith('rnd-')){const d=parseInt(v.split('-')[1])/100;for(let i=0;i<TOTAL;i++){grid[i]=Math.random()<d?1:0;age[i]=grid[i]?Math.random()*40:-15}}
  else{for(let s=0;s<sc;s++)placeRandomOriented(v,Math.floor(Math.random()*W),Math.floor(Math.random()*H))}
  cntPop();updTex();updStats();
}
function randomize(){clear();const d=.12+Math.random()*.28;for(let i=0;i<TOTAL;i++){grid[i]=Math.random()<d?1:0;age[i]=grid[i]?Math.random()*40:-15}cntPop();updTex();updStats()}
function cntPop(){pop=0;for(let i=0;i<TOTAL;i++)if(grid[i])pop++}

// ========================================
// COLOR SYSTEM
// ========================================
function hex2rgb(h){const r=parseInt(h.slice(1,3),16),g=parseInt(h.slice(3,5),16),b=parseInt(h.slice(5,7),16);return[r,g,b]}
function rgb2hex(r,g,b){return'#'+[r,g,b].map(v=>Math.round(v).toString(16).padStart(2,'0')).join('')}
function clamp(v,min,max){return Math.max(min,Math.min(max,v))}

function getImpactColorData(){
  const rgb=hex2rgb($('cImpact').value);
  const intensity=+$('iImpact').value/100;
  const r=clamp(rgb[0]*intensity,0,255);
  const g=clamp(rgb[1]*intensity,0,255);
  const b=clamp(rgb[2]*intensity,0,255);
  return{
    rgb,intensity,r,g,b,
    three:new THREE.Color(r/255,g/255,b/255),
    css:'rgb('+Math.round(r)+','+Math.round(g)+','+Math.round(b)+')'
  };
}

function getBornColorData(){
  const rgb=hex2rgb($('cBorn').value);
  const intensity=+$('iBorn').value/100;
  const r=clamp(rgb[0]*intensity,0,255);
  const g=clamp(rgb[1]*intensity,0,255);
  const b=clamp(rgb[2]*intensity,0,255);
  return{
    rgb,intensity,r,g,b,
    css:'rgb('+Math.round(r)+','+Math.round(g)+','+Math.round(b)+')'
  };
}

function getColors(){
  return{
    alive: hex2rgb($('cAlive').value),
    born:  hex2rgb($('cBorn').value),
    dead:  hex2rgb($('cDead').value),
    dots:  hex2rgb($('cDots').value),
    iAlive:+$('iAlive').value/100,
    iBorn: +$('iBorn').value/100,
    iDead: +$('iDead').value/100,
    iDots: +$('iDots').value/100,
  };
}

const PRESETS={
  cm:{alive:'#00ffc8',born:'#ff00aa',dead:'#0a0a14',dots:'#0066ff'},
  go:{alive:'#39ff14',born:'#ff6a00',dead:'#0a100a',dots:'#0044ff'},
  by:{alive:'#00aaff',born:'#ffd500',dead:'#0a0a14',dots:'#0055ff'},
  pg:{alive:'#bf00ff',born:'#39ff14',dead:'#100a14',dots:'#0066ff'},
  fi:{alive:'#ff5000',born:'#ffdc00',dead:'#140804',dots:'#0044cc'},
  oc:{alive:'#00c8ff',born:'#00ffb4',dead:'#040814',dots:'#0055ff'},
  mx:{alive:'#00ff41',born:'#96ff96',dead:'#000800',dots:'#003388'},
};

function applyPreset(key){
  const p=PRESETS[key]; if(!p)return;
  $('cAlive').value=p.alive;
  $('cBorn').value=p.born;
  $('cDead').value=p.dead;
  $('cDots').value=p.dots;
  updTex(); save();
}

// ========================================
// THREE.JS SCENE
// ========================================
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(50,innerWidth/innerHeight,0.1,100);
camera.position.set(0,0,3);

function createStableRenderer(){
  const attempts=[
    {antialias:true,powerPreference:'high-performance'},
    {antialias:false,powerPreference:'high-performance'},
    {antialias:false,powerPreference:'low-power'}
  ];
  let lastErr=null;
  for(let i=0;i<attempts.length;i++){
    try{return new THREE.WebGLRenderer(attempts[i])}
    catch(err){lastErr=err}
  }
  throw lastErr||new Error('WebGL renderer initialization failed');
}

const renderer=createStableRenderer();
renderer.setSize(innerWidth,innerHeight);
const MAX_PIXEL_RATIO=1.5;
renderer.setPixelRatio(Math.min(devicePixelRatio,MAX_PIXEL_RATIO));
renderer.setClearColor(0x0a0a0f);
document.body.appendChild(renderer.domElement);
renderer.domElement.style.cssText='position:fixed;top:0;left:0;z-index:0';
let glContextLost=false;
let wasRunningBeforeContextLost=false;
let pageVisible=!document.hidden;
let rafId=0;
let disposed=false;
let pendingTexUpdate=false;
const WIPE_VISUAL_INTERVAL=1000/30;
const OVERLAY_LAYOUT_INTERVAL=1000/30;
let lastWipeVisualUpdate=0;
let lastOverlayLayout=0;

// Mystical skull cursor for wipe mode (canvas-rendered with arcane glow)
const _skullCvs=document.createElement('canvas');_skullCvs.width=40;_skullCvs.height=40;
const _skullCtx=_skullCvs.getContext('2d');
_skullCtx.textAlign='center';_skullCtx.textBaseline='middle';
// Outer mystical aura
_skullCtx.shadowColor='rgba(160,0,255,0.9)';_skullCtx.shadowBlur=12;
_skullCtx.font='26px serif';
_skullCtx.fillStyle='rgba(200,160,255,0.4)';_skullCtx.fillText('\u2620',20,19);
// Inner skull with hot glow
_skullCtx.shadowColor='rgba(255,50,200,0.8)';_skullCtx.shadowBlur=6;
_skullCtx.fillStyle='rgba(240,220,255,0.95)';_skullCtx.fillText('\u2620',20,19);
// Final crisp pass
_skullCtx.shadowBlur=0;_skullCtx.fillStyle='rgba(255,245,255,0.85)';_skullCtx.fillText('\u2620',20,19);
const wipeCursor='url('+_skullCvs.toDataURL()+') 20 20, crosshair';

// Dynamic centering: offset projection so sphere is centered in visible area
let _rw=0,_rh=0;
function updateCameraCenter(){
  // Sync renderer size if viewport changed (handles deferred layout/scrollbar shifts)
  const w=innerWidth,h=innerHeight;
  if(w!==_rw||h!==_rh){_rw=w;_rh=h;renderer.setSize(w,h)}
  camera.aspect=w/h;
  camera.updateProjectionMatrix();

  const topbar=document.getElementById('topbar');
  const panel=document.getElementById('panel');
  const overlay=document.getElementById('impactOverlay');
  const rules=document.getElementById('golRules');
  const topInset=topbar?topbar.getBoundingClientRect().height:0;
  let leftBlock=0,rightBlock=0,bottomInset=0;

  if(panel){
    const pr=panel.getBoundingClientRect();
    if(innerWidth>768){
      leftBlock=Math.max(0,pr.right+12);
    }else{
      const panelFromBottom=Math.max(0,innerHeight-pr.top);
      bottomInset=Math.max(0,Math.min(innerHeight*0.5,panelFromBottom));
    }
  }

  if(overlay&&overlay.offsetParent!==null){
    const or=overlay.getBoundingClientRect();
    if(or.width>0&&or.height>0){
      rightBlock=Math.max(rightBlock,Math.max(0,innerWidth-or.left)+12);
    }
  }
  if(rules&&rules.offsetParent!==null){
    const rr=rules.getBoundingClientRect();
    const rs=getComputedStyle(rules);
    const isVisible=rs.visibility!=='hidden'&&parseFloat(rs.opacity||'0')>0.01;
    if(isVisible&&rr.width>0&&rr.height>0){
      rightBlock=Math.max(rightBlock,Math.max(0,innerWidth-rr.left)+12);
    }
  }

  // Keep sphere centered until side UI actually intrudes into the center region.
  const halfW=innerWidth*0.5;
  const leftInset=Math.max(0,leftBlock-halfW);
  const rightInset=Math.max(0,rightBlock-halfW);

  const usableW=Math.max(1,innerWidth-leftInset-rightInset);
  const usableH=Math.max(1,innerHeight-topInset-bottomInset);
  const centerX=leftInset+usableW*0.5;
  const centerY=topInset+usableH*0.5;
  const targetNdcX=(centerX/innerWidth)*2-1;
  const targetNdcY=1-(centerY/innerHeight)*2;

  camera.projectionMatrix.elements[8]=-targetNdcX;
  camera.projectionMatrix.elements[9]=-targetNdcY;
  camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
}

let zoom=4;

// Main texture canvas (upscaled for pole distortion correction)
const tc=document.createElement('canvas');tc.width=TW;tc.height=TH;
const tx=tc.getContext('2d');
const texImg=tx.createImageData(TW,TH);
const texImgData=texImg.data;

// Glow source + destination canvases
const glowSrc=document.createElement('canvas');glowSrc.width=W;glowSrc.height=H;
const gsx=glowSrc.getContext('2d');
const glowDst=document.createElement('canvas');glowDst.width=W;glowDst.height=H;
const gdx=glowDst.getContext('2d');
const glowImg=gsx.createImageData(W,H);
const glowImgData=glowImg.data;

const lifeTex=new THREE.CanvasTexture(tc);
lifeTex.wrapS=THREE.RepeatWrapping;lifeTex.wrapT=THREE.ClampToEdgeWrapping;
lifeTex.minFilter=THREE.LinearFilter;lifeTex.magFilter=THREE.LinearFilter;lifeTex.generateMipmaps=false;

const sphGeo=new THREE.SphereGeometry(1,64,32);

const sphMat=new THREE.MeshStandardMaterial({map:lifeTex,emissiveMap:lifeTex,emissive:new THREE.Color(1,1,1),emissiveIntensity:1.0,roughness:.55,metalness:.15,transparent:true,opacity:.84,depthWrite:false});
const DAY_NIGHT_DAY_GAIN=0.42;
const DAY_NIGHT_NIGHT_GAIN=0.34;
const DAY_LIGHT_VIEW_DIR=new THREE.Vector3(0.62,0.54,0.57).normalize(); // top-right/front in view space
let sphMatShaderRef=null;
sphMat.onBeforeCompile=(shader)=>{
  shader.uniforms.uDayNightStrength={value:dayNightStrength};
  shader.uniforms.uDayLightDir={value:DAY_LIGHT_VIEW_DIR.clone()};
  shader.uniforms.uDayGain={value:DAY_NIGHT_DAY_GAIN};
  shader.uniforms.uNightGain={value:DAY_NIGHT_NIGHT_GAIN};
  shader.fragmentShader=shader.fragmentShader.replace(
    'varying vec3 vViewPosition;',
    'varying vec3 vViewPosition;\nuniform float uDayNightStrength;\nuniform vec3 uDayLightDir;\nuniform float uDayGain;\nuniform float uNightGain;'
  );
  shader.fragmentShader=shader.fragmentShader.replace(
    'gl_FragColor = vec4( outgoingLight, diffuseColor.a );',
    'vec3 _dnColor=outgoingLight;\nfloat _dnH=dot(normalize(normal),normalize(uDayLightDir));\nfloat _dnDay=max(_dnH,0.0)*uDayGain*uDayNightStrength;\nfloat _dnNight=max(-_dnH,0.0)*uNightGain*uDayNightStrength;\n_dnColor=_dnColor*(1.0-_dnNight)+(vec3(1.0)-_dnColor)*_dnDay;\ngl_FragColor = vec4( _dnColor, diffuseColor.a );'
  );
  sphMatShaderRef=shader;
};
function syncDayNightUniform(){
  if(sphMatShaderRef&&sphMatShaderRef.uniforms&&sphMatShaderRef.uniforms.uDayNightStrength){
    sphMatShaderRef.uniforms.uDayNightStrength.value=dayNightStrength;
  }
}
sphMat.needsUpdate=true;
const sph=new THREE.Mesh(sphGeo,sphMat);
scene.add(sph);

// Back-face sphere: BasicMaterial (no scene lighting), additive blend glows through front
const sphBackMat=new THREE.MeshBasicMaterial({map:lifeTex,transparent:true,opacity:.15,side:THREE.BackSide,depthWrite:false,blending:THREE.AdditiveBlending});
const sphBack=new THREE.Mesh(sphGeo,sphBackMat);
scene.add(sphBack);
sph.renderOrder=1;
sphBack.renderOrder=2;

// Wireframe grid (no diagonals): only latitude + longitude lines
{var _wSegsW=48,_wSegsH=24,_wR=1.003;
const verts=[],norms=[];
// Build vertex grid [y][x]
const grid2=[];
for(let iy=0;iy<=_wSegsH;iy++){
  const row=[];
  const v=iy/_wSegsH, th=v*Math.PI;
  const sinTh=Math.sin(th), cosTh=Math.cos(th);
  for(let ix=0;ix<=_wSegsW;ix++){
    const u=ix/_wSegsW, ph=u*Math.PI*2;
    const x=-_wR*Math.cos(ph)*sinTh, y=_wR*cosTh, z=_wR*Math.sin(ph)*sinTh;
    row.push([x,y,z]);
  }
  grid2.push(row);
}
const pos=[],nor=[];
function addSeg(a,b){
  pos.push(a[0],a[1],a[2],b[0],b[1],b[2]);
  const na=[a[0]/_wR,a[1]/_wR,a[2]/_wR], nb=[b[0]/_wR,b[1]/_wR,b[2]/_wR];
  nor.push(na[0],na[1],na[2],nb[0],nb[1],nb[2]);
}
// Latitude lines (horizontal rings)
for(let iy=0;iy<=_wSegsH;iy++)
  for(let ix=0;ix<_wSegsW;ix++) addSeg(grid2[iy][ix],grid2[iy][ix+1]);
// Longitude lines (vertical arcs)
for(let ix=0;ix<=_wSegsW;ix++)
  for(let iy=0;iy<_wSegsH;iy++) addSeg(grid2[iy][ix],grid2[iy+1][ix]);
var _wGeo=new THREE.BufferGeometry();
_wGeo.setAttribute('position',new THREE.Float32BufferAttribute(pos,3));
_wGeo.setAttribute('normal',new THREE.Float32BufferAttribute(nor,3));
}
const wireShaderMat=new THREE.ShaderMaterial({
  uniforms:{wColor:{value:new THREE.Color(0x00ffc8)},wOpacity:{value:0.30}},
  vertexShader:`
    varying float vFade;
    void main(){
      vec3 wNorm=normalize(normalMatrix*normal);
      vec3 vDir=normalize(cameraPosition-(modelMatrix*vec4(position,1.0)).xyz);
      vFade=max(0.0,dot(wNorm,vDir));
      gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);
    }`,
  fragmentShader:`
    uniform vec3 wColor;
    uniform float wOpacity;
    varying float vFade;
    void main(){
      float a=wOpacity*mix(0.28,1.0,pow(vFade,1.2));
      gl_FragColor=vec4(wColor,a);
    }`,
  transparent:true,depthWrite:false
});
const wire=new THREE.LineSegments(_wGeo,wireShaderMat);
wire.visible=true;scene.add(wire);
wire.renderOrder=3;

// Lights
scene.add(new THREE.AmbientLight(0x222233,.4));
const l1=new THREE.PointLight(0x00ffc8,.7,12);l1.position.set(3,2,3);scene.add(l1);
const l2=new THREE.PointLight(0xff00aa,.4,12);l2.position.set(-3,-1,2);scene.add(l2);
const l3=new THREE.PointLight(0x4444ff,.3,12);l3.position.set(0,3,-2);scene.add(l3);

// Background stars
const stGeo=new THREE.BufferGeometry();const stPos=new Float32Array(4500);for(let i=0;i<4500;i++)stPos[i]=(Math.random()-.5)*60;
stGeo.setAttribute('position',new THREE.BufferAttribute(stPos,3));
const stMat=new THREE.PointsMaterial({color:0x334455,size:.04});
const stPts=new THREE.Points(stGeo,stMat);
scene.add(stPts);

// ========================================
// ROTATION & ZOOM
// ========================================
let dragging=false,pmx=0,pmy=0;
let axisDrag=false,axmx=0,axmy=0;
let rotQ=new THREE.Quaternion();
let autoRot=true,rotSpd=.1;
let rotAxis=new THREE.Vector3(0,1,.3).normalize();
let rotTarget=new THREE.Vector3(0,1,0).normalize();
let axisTimer=0;

renderer.domElement.addEventListener('contextmenu',e=>e.preventDefault());
renderer.domElement.addEventListener('pointerdown',e=>{
  if(e.button===0){
    if(wipeMode){wiping=true;doWipe(e.clientX,e.clientY)}
    else{dragging=true;pmx=e.clientX;pmy=e.clientY}
  } else if(e.button===2){
    axisDrag=true;axmx=e.clientX;axmy=e.clientY;
  }
});
window.addEventListener('pointermove',e=>{
  if(wiping){doWipe(e.clientX,e.clientY);return}
  if(axisDrag){
    const dx=(e.clientX-axmx)*.004,dy=(e.clientY-axmy)*.004;
    const q=new THREE.Quaternion();
    q.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1),dx));
    q.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0),dy));
    rotAxis.applyQuaternion(q).normalize();
    rotTarget.copy(rotAxis);
    axmx=e.clientX;axmy=e.clientY;
    return;
  }
  if(!dragging)return;
  const dx=(e.clientX-pmx)*.006,dy=(e.clientY-pmy)*.006;
  rotQ.premultiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0),dx));
  rotQ.premultiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0),dy));
  pmx=e.clientX;pmy=e.clientY;
});
function commitWipeVisuals(now){
  cntPop();updTex();updStats();
  pendingTexUpdate=false;
  lastWipeVisualUpdate=now;
}

window.addEventListener('pointerup',()=>{
  dragging=false;axisDrag=false;
  if(wiping)commitWipeVisuals(performance.now());
  wiping=false;
});

// Wipe: erase cells in radius at raycasted sphere position
function doWipe(cx,cy){
  rcMouse.x=(cx/innerWidth)*2-1;
  rcMouse.y=-(cy/innerHeight)*2+1;
  raycaster.setFromCamera(rcMouse,camera);
  const hits=raycaster.intersectObject(sph);
  if(hits.length>0&&hits[0].uv){
    const g=uvToGrid(hits[0].uv);
    const r2=wipeRadius*wipeRadius;
    for(let dy=-wipeRadius;dy<=wipeRadius;dy++){
      for(let dx=-wipeRadius;dx<=wipeRadius;dx++){
        if(dx*dx+dy*dy<=r2){
          const i=ix(g.x+dx,g.y+dy);
          grid[i]=0;age[i]=Math.min(age[i],-1);meteorAge[i]=0;meteorFlashMark[i]=0;
        }
      }
    }
    pendingTexUpdate=true;
    const now=performance.now();
    if(now-lastWipeVisualUpdate>=WIPE_VISUAL_INTERVAL)commitWipeVisuals(now);
  }
}

let pinchD=0;
renderer.domElement.addEventListener('touchstart',e=>{if(e.touches.length===2)pinchD=Math.hypot(e.touches[0].clientX-e.touches[1].clientX,e.touches[0].clientY-e.touches[1].clientY)},{passive:true});
renderer.domElement.addEventListener('touchmove',e=>{if(e.touches.length===2){const d=Math.hypot(e.touches[0].clientX-e.touches[1].clientX,e.touches[0].clientY-e.touches[1].clientY);zoom+=(pinchD-d)*.01;zoom=Math.max(1.5,Math.min(8,zoom));pinchD=d;$('rZoom').value=zoom*10;$('vZoom').textContent=zoom.toFixed(1)}},{passive:true});
renderer.domElement.addEventListener('wheel',e=>{zoom+=e.deltaY*.002;zoom=Math.max(1.5,Math.min(8,zoom));$('rZoom').value=zoom*10;$('vZoom').textContent=zoom.toFixed(1);save()},{passive:true});

// ========================================
// RIGHT-CLICK CONTEXT MENU
// ========================================
const raycaster=new THREE.Raycaster();
const rcMouse=new THREE.Vector2();
let ctxTarget={x:0,y:0};

function showCtxMenu(ex,ey){
  const m=document.getElementById('ctxMenu');
  let html='';
  PAT_MENU.forEach(g=>{
    html+='<div class="ctx-cat">'+g.cat+'</div>';
    g.items.forEach(([k,label])=>{
      const sym=PAT_BRAILLE[k]||'';
      html+='<div class="ctx-item" data-pat="'+k+'">'+(sym?'<span class="ctx-sym">'+sym+'</span> ':'')+label+'</div>';
    });
  });
  m.innerHTML=html;
  m.style.display='block';
  const mw=m.offsetWidth,mh=m.offsetHeight;
  m.style.left=Math.min(ex,innerWidth-mw-8)+'px';
  m.style.top=Math.min(ey,innerHeight-mh-8)+'px';
  m.querySelectorAll('.ctx-item').forEach(el=>{
    el.onclick=()=>{
      const k=el.dataset.pat;
      placeRandomOriented(k,ctxTarget.x,ctxTarget.y);
      cntPop();updTex();updStats();
      hideCtxMenu();
    };
  });
}
function hideCtxMenu(){document.getElementById('ctxMenu').style.display='none'}

function uvToGrid(uv){
  return{
    x:Math.floor(uv.x*W)%W,
    y:Math.floor((1-uv.y)*H)%H
  };
}

renderer.domElement.addEventListener('contextmenu',e=>{
  e.preventDefault();
  rcMouse.x=(e.clientX/innerWidth)*2-1;
  rcMouse.y=-(e.clientY/innerHeight)*2+1;
  raycaster.setFromCamera(rcMouse,camera);
  const hits=raycaster.intersectObject(sph);
  if(hits.length>0&&hits[0].uv){
    const g=uvToGrid(hits[0].uv);
    ctxTarget.x=g.x;ctxTarget.y=g.y;
    showCtxMenu(e.clientX,e.clientY);
  }
});
window.addEventListener('pointerdown',e=>{
  if(!document.getElementById('ctxMenu').contains(e.target))hideCtxMenu();
});
window.addEventListener('keydown',e=>{if(e.key==='Escape')hideCtxMenu()});

// ========================================
// METEOR SYSTEM
// ========================================
const METEOR_PATS=['glider','blinker','toad','beacon','clock','lwss','rpent','acorn','thunderbird','piHept','bhept','boat','ship','block','beehive','pulsar','figureEight'];
const NUKE_PAT_KEY='nuke';
const NUKE_SPAWN_CHANCE=0.01;
const NUKE_MIN_METEORS_BETWEEN=100;
const NUKE_WIPE_RADIUS=24;
const METEOR_ENABLE_POINT_LIGHT=false; // Keep sphere cell colours independent from Meteor toggle.
const NUKE_COLOR_RGB=[255,56,0];
const NUKE_COLOR_CSS='rgb('+NUKE_COLOR_RGB[0]+','+NUKE_COLOR_RGB[1]+','+NUKE_COLOR_RGB[2]+')';
const NUKE_COLOR_THREE=new THREE.Color(NUKE_COLOR_RGB[0]/255,NUKE_COLOR_RGB[1]/255,NUKE_COLOR_RGB[2]/255);

function getMeteorColorData(isNuke){
  if(isNuke){
    return{
      r:NUKE_COLOR_RGB[0],g:NUKE_COLOR_RGB[1],b:NUKE_COLOR_RGB[2],
      three:NUKE_COLOR_THREE,
      css:NUKE_COLOR_CSS
    };
  }
  return getImpactColorData();
}

function applyNukeWipe(cx,cy,radius){
  const r2=radius*radius;
  for(let dy=-radius;dy<=radius;dy++){
    const y2=dy*dy;
    for(let dx=-radius;dx<=radius;dx++){
      if(dx*dx+y2>r2)continue;
      const i=ix(cx+dx,cy+dy);
      grid[i]=0;
      age[i]=Math.min(age[i],-1);
      meteorAge[i]=0;
      meteorFlashMark[i]=0;
    }
  }
}

// Glow sprite texture for meteor head (created once, shared)
const meteorGlowCvs=document.createElement('canvas');meteorGlowCvs.width=meteorGlowCvs.height=64;
const _mgx=meteorGlowCvs.getContext('2d');
const _mgg=_mgx.createRadialGradient(32,32,0,32,32,32);
_mgg.addColorStop(0,'rgba(255,255,255,1)');_mgg.addColorStop(0.1,'rgba(230,240,255,0.9)');
_mgg.addColorStop(0.3,'rgba(120,170,255,0.35)');_mgg.addColorStop(0.6,'rgba(50,100,255,0.08)');
_mgg.addColorStop(1,'rgba(0,0,0,0)');
_mgx.fillStyle=_mgg;_mgx.fillRect(0,0,64,64);
const meteorGlowTex=new THREE.CanvasTexture(meteorGlowCvs);
const meteorHeadGeo=new THREE.SphereGeometry(0.008,16,12);
const _whiteColor=new THREE.Color(1,1,1);

function getMeteorCoreColor(threeColor){
  // Blend toward white to create a smoother transition from white core to colored glow.
  return threeColor.clone().lerp(_whiteColor,0.42);
}

renderer.domElement.addEventListener('webglcontextlost',e=>{
  e.preventDefault();
  glContextLost=true;
  wasRunningBeforeContextLost=running;
  running=false;
  updPlayBtn();
});
renderer.domElement.addEventListener('webglcontextrestored',()=>{
  glContextLost=false;
  lifeTex.needsUpdate=true;
  meteorGlowTex.needsUpdate=true;
  pendingTexUpdate=true;
  if(wasRunningBeforeContextLost){
    running=true;
    updPlayBtn();
  }
});

function gridToSurface(gx,gy){
  const u=((gx+0.5)/W)%1, v=clamp((gy+0.5)/H,0,1);
  const theta=v*Math.PI;
  const phi=u*Math.PI*2;
  // Match Three.js SphereGeometry UV convention
  const pt=new THREE.Vector3(
    -Math.cos(phi)*Math.sin(theta),
    Math.cos(theta),
    Math.sin(phi)*Math.sin(theta)
  );
  pt.applyQuaternion(rotQ);
  return pt;
}

// Inverse: world-space point on sphere -> grid coordinates (matches Three.js UV mapping)
function surfaceToGrid(worldPt){
  const p=worldPt.clone().normalize().applyQuaternion(rotQ.clone().invert());
  const theta=Math.acos(Math.max(-1,Math.min(1,p.y)));
  const phi=Math.atan2(p.z,-p.x);
  const v=theta/Math.PI;
  let u=phi/(Math.PI*2);if(u<0)u+=1;
  return{x:Math.floor(u*W)%W,y:Math.min(H-1,Math.floor(v*H))};
}

function findEmptySpot(){
  let bestX=0,bestY=0,bestScore=Infinity;
  for(let t=0;t<15;t++){
    const tx=Math.floor(Math.random()*W),ty=Math.floor(Math.random()*H);
    let score=0;
    for(let dy=-8;dy<=8;dy++)for(let dx=-8;dx<=8;dx++){
      if(grid[ix(tx+dx,ty+dy)])score++;
    }
    if(score<bestScore){bestScore=score;bestX=tx;bestY=ty}
  }
  return{x:bestX,y:bestY};
}

function scheduleNextMeteor(){
  const minI=Math.max(0.25,meteorInterval*0.45);
  const maxI=Math.max(minI+0.2,meteorInterval*1.55);
  nextMeteorTime=minI+Math.random()*(maxI-minI);
}

function syncTrailRibbonColor(m,threeColor){
  if(m.trailMat&&m.trailMat.uniforms&&m.trailMat.uniforms.uColor){
    m.trailMat.uniforms.uColor.value.copy(threeColor);
  }
}

function updateTrailRibbon(m,headX,headY,headZ,visFactor,camX,camY,camZ){
  const len=m.trailLen;
  const tp=m.trailPositions;
  const vp=m.trailVerts;
  const offX=headX-m.pos.x,offY=headY-m.pos.y,offZ=headZ-m.pos.z;
  m.trail.position.set(offX,offY,offZ);
  const widthBase=0.052*(0.9+0.2*visFactor);
  let lastSx=1,lastSy=0,lastSz=0;

  for(let i=0;i<len;i++){
    const bi=i*3;
    const px=tp[bi],py=tp[bi+1],pz=tp[bi+2];

    let tx,ty,tz;
    if(i===0){
      tx=tp[0]-tp[3];ty=tp[1]-tp[4];tz=tp[2]-tp[5];
    }else if(i===len-1){
      const pi=(len-2)*3;
      tx=tp[pi]-tp[bi];ty=tp[pi+1]-tp[bi+1];tz=tp[pi+2]-tp[bi+2];
    }else{
      const pi=(i-1)*3,ni=(i+1)*3;
      tx=tp[pi]-tp[ni];ty=tp[pi+1]-tp[ni+1];tz=tp[pi+2]-tp[ni+2];
    }

    let tLen=Math.hypot(tx,ty,tz);
    if(tLen<1e-6){tx=0;ty=0;tz=1;tLen=1;}
    tx/=tLen;ty/=tLen;tz/=tLen;

    const wx=px+offX,wy=py+offY,wz=pz+offZ;
    let vx=camX-wx,vy=camY-wy,vz=camZ-wz;
    let vLen=Math.hypot(vx,vy,vz);
    if(vLen<1e-6){vx=0;vy=0;vz=1;vLen=1;}
    vx/=vLen;vy/=vLen;vz/=vLen;

    let sx=vy*tz-vz*ty;
    let sy=vz*tx-vx*tz;
    let sz=vx*ty-vy*tx;
    let sLen=Math.hypot(sx,sy,sz);
    if(sLen<1e-6){
      sx=lastSx;sy=lastSy;sz=lastSz;
    }else{
      sx/=sLen;sy/=sLen;sz/=sLen;
      lastSx=sx;lastSy=sy;lastSz=sz;
    }

    const f=i/(len-1);
    let w=widthBase*(0.18+0.82*Math.pow(1-f,0.58));
    if(i===0)w*=0.45; // protect bright head core from overbloom
    sx*=w;sy*=w;sz*=w;

    const vi=i*6;
    vp[vi]=px+sx;vp[vi+1]=py+sy;vp[vi+2]=pz+sz;
    vp[vi+3]=px-sx;vp[vi+4]=py-sy;vp[vi+5]=pz-sz;
  }

  m.trailPosAttr.needsUpdate=true;
  m.trailMat.uniforms.uOpacity.value=0.95*Math.max(0,Math.min(1,visFactor));
}

function syncActiveMeteorColors(){
  const imp=getMeteorColorData(false);
  for(const m of activeMeteors){
    const c=m.isNuke?getMeteorColorData(true):imp;
    m.glowMat.color.copy(c.three);
    if(m.coreMat)m.coreMat.color.copy(getMeteorCoreColor(c.three));
    if(m.light)m.light.color.copy(c.three);
    syncTrailRibbonColor(m,c.three);
  }
}

function spawnMeteor(){
  if(activeMeteors.length>=MAX_ACTIVE_METEORS)return;
  const canSpawnNuke=meteorsSinceLastNuke>=NUKE_MIN_METEORS_BETWEEN;
  const isNuke=canSpawnNuke&&Math.random()<NUKE_SPAWN_CHANCE;
  if(isNuke)meteorsSinceLastNuke=0;
  else meteorsSinceLastNuke++;
  const patKey=isNuke?NUKE_PAT_KEY:METEOR_PATS[Math.floor(Math.random()*METEOR_PATS.length)];
  const imp=getMeteorColorData(isNuke);

  // Bias 70% of meteors toward camera-visible hemisphere
  const camDir=camera.position.clone().normalize();
  let originDir;
  do{
    const rTh=Math.acos(2*Math.random()-1),rPh=Math.random()*Math.PI*2;
    originDir=new THREE.Vector3(Math.sin(rTh)*Math.cos(rPh),Math.cos(rTh),Math.sin(rTh)*Math.sin(rPh));
  }while(originDir.dot(camDir)<0&&Math.random()<0.6);
  const originDist=3.5+Math.random()*2.0;
  const origin=originDir.clone().multiplyScalar(originDist);

  // Initial velocity: toward sphere center (gravity), small perpendicular deviation
  const toCenter=origin.clone().negate().normalize();
  const baseSpeed=Math.sqrt(2.5/originDist)*0.8; // below escape velocity -> always captured
  const dev=new THREE.Vector3(Math.random()-.5,Math.random()-.5,Math.random()-.5);
  dev.sub(toCenter.clone().multiplyScalar(dev.dot(toCenter))).normalize();
  const vel=toCenter.clone().multiplyScalar(baseSpeed).add(dev.multiplyScalar(baseSpeed*0.1));

  // White-hot core
  const headMat=new THREE.MeshBasicMaterial({color:0xfcfdff,transparent:true,opacity:0.92,depthWrite:false});
  const head=new THREE.Mesh(meteorHeadGeo,headMat);
  head.position.copy(origin);
  head.renderOrder=8;
  scene.add(head);

  // Bright tip point (small intense white sprite)
  const tipMat=new THREE.SpriteMaterial({map:meteorGlowTex,color:0xffffff,transparent:true,opacity:0.92,depthWrite:false});
  const tip=new THREE.Sprite(tipMat);
  tip.scale.set(0.026,0.026,1);
  tip.renderOrder=9;
  head.add(tip);

  // Mid halo smooths the white-to-color transition around the head core.
  const coreMat=new THREE.SpriteMaterial({
    map:meteorGlowTex,
    color:getMeteorCoreColor(imp.three),
    transparent:true,
    opacity:0.78,
    depthWrite:false,
    blending:THREE.AdditiveBlending
  });
  const core=new THREE.Sprite(coreMat);
  core.scale.set(0.082,0.082,1);
  core.renderOrder=8;
  head.add(core);

  // Soft radial glow sprite (NormalBlending: consistent against any background)
  const glowMat=new THREE.SpriteMaterial({map:meteorGlowTex,color:imp.three,transparent:true,opacity:0.76,depthWrite:false});
  const glow=new THREE.Sprite(glowMat);
  glow.scale.set(0.32,0.32,1);
  glow.renderOrder=7;
  head.add(glow);

  // Continuous ribbon trail: no dotted points, lateral fade via shader
  const trailLen=72;
  const trailPositions=new Float32Array(trailLen*3);
  const trailVerts=new Float32Array(trailLen*6);
  const trailUVs=new Float32Array(trailLen*4);
  const trailIdx=new Uint16Array((trailLen-1)*6);
  for(let i=0;i<trailLen;i++){
    const pi=i*3;
    trailPositions[pi]=origin.x;trailPositions[pi+1]=origin.y;trailPositions[pi+2]=origin.z;
    const vi=i*6;
    trailVerts[vi]=origin.x;trailVerts[vi+1]=origin.y;trailVerts[vi+2]=origin.z;
    trailVerts[vi+3]=origin.x;trailVerts[vi+4]=origin.y;trailVerts[vi+5]=origin.z;
    const ui=i*4;
    const v=i/(trailLen-1);
    trailUVs[ui]=0;trailUVs[ui+1]=v;
    trailUVs[ui+2]=1;trailUVs[ui+3]=v;
    if(i<trailLen-1){
      const ii=i*6,vi2=i*2;
      trailIdx[ii]=vi2;
      trailIdx[ii+1]=vi2+1;
      trailIdx[ii+2]=vi2+2;
      trailIdx[ii+3]=vi2+1;
      trailIdx[ii+4]=vi2+3;
      trailIdx[ii+5]=vi2+2;
    }
  }

  const trailGeo=new THREE.BufferGeometry();
  const trailPosAttr=new THREE.BufferAttribute(trailVerts,3);
  trailPosAttr.setUsage(THREE.DynamicDrawUsage);
  trailGeo.setAttribute('position',trailPosAttr);
  trailGeo.setAttribute('uv',new THREE.BufferAttribute(trailUVs,2));
  trailGeo.setIndex(new THREE.BufferAttribute(trailIdx,1));
  const trailMat=new THREE.ShaderMaterial({
    uniforms:{
      map:{value:meteorGlowTex},
      uColor:{value:imp.three.clone()},
      uOpacity:{value:0.95}
    },
    vertexShader:[
      'varying vec2 vUv;',
      'void main(){',
      '  vUv=uv;',
      '  gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);',
      '}'
    ].join('\n'),
    fragmentShader:[
      'uniform sampler2D map;',
      'uniform vec3 uColor;',
      'uniform float uOpacity;',
      'varying vec2 vUv;',
      'void main(){',
      '  vec4 tex=texture2D(map,vec2(vUv.x,0.5));',
      '  float side=max(0.0,1.0-abs(vUv.x*2.0-1.0));',
      '  float sideFade=pow(side,1.55);',
      '  float along=pow(max(0.0,1.0-vUv.y),1.22);',
      '  float alpha=tex.a*sideFade*along*uOpacity;',
      '  if(alpha<0.003) discard;',
      '  float core=pow(side,4.0)*pow(max(0.0,1.0-vUv.y),1.6);',
      '  vec3 col=mix(uColor,vec3(1.0),0.24*core);',
      '  gl_FragColor=vec4(col*tex.rgb,alpha);',
      '}'
    ].join('\n'),
    transparent:true,
    depthWrite:false,
    side:THREE.DoubleSide,
    blending:THREE.AdditiveBlending
  });
  const trail=new THREE.Mesh(trailGeo,trailMat);
  trail.renderOrder=4;
  trail.frustumCulled=false;
  scene.add(trail);

  let light=null;
  if(METEOR_ENABLE_POINT_LIGHT){
    light=new THREE.PointLight(imp.three,2.0,6);
    light.position.copy(origin);
    scene.add(light);
  }

  const meteor={
    head,tip,tipMat,core,coreMat,trail,trailGeo,trailMat,trailPosAttr,trailVerts,glow,glowMat,trailPositions,trailLen,light,
    pos:origin.clone(),prevPos:origin.clone(),renderPos:origin.clone(),vel:vel.clone(),
    patKey,isNuke, age:0
  };
  syncTrailRibbonColor(meteor,imp.three);
  updateTrailRibbon(meteor,origin.x,origin.y,origin.z,1.0,camera.position.x,camera.position.y,camera.position.z);
  activeMeteors.push(meteor);
}

function disposeMeteorVisuals(m){
  if(!m)return;
  scene.remove(m.head);
  if(m.light)scene.remove(m.light);
  if(m.trail)scene.remove(m.trail);
  if(m.head&&m.head.material)m.head.material.dispose();
  if(m.tipMat)m.tipMat.dispose();
  if(m.coreMat)m.coreMat.dispose();
  if(m.glowMat)m.glowMat.dispose();
  if(m.trailGeo)m.trailGeo.dispose();
  if(m.trailMat)m.trailMat.dispose();
}

const _impactWorldPt=new THREE.Vector3();
const METEOR_TRAIL_POINT_STEP=0.01;
const METEOR_TRAIL_MAX_INSERTS=12;

function updateMeteorVisuals(interp,frameDt){
  const a=Math.max(0,Math.min(1,interp));
  const camX=camera.position.x,camY=camera.position.y,camZ=camera.position.z;
  const camLen=Math.hypot(camX,camY,camZ)||1;
  const camNx=camX/camLen,camNy=camY/camLen,camNz=camZ/camLen;

  for(let i=0;i<activeMeteors.length;i++){
    const m=activeMeteors[i];
    const tx=m.prevPos.x+(m.pos.x-m.prevPos.x)*a;
    const ty=m.prevPos.y+(m.pos.y-m.prevPos.y)*a;
    const tz=m.prevPos.z+(m.pos.z-m.prevPos.z)*a;
    m.renderPos.x=tx;
    m.renderPos.y=ty;
    m.renderPos.z=tz;
    const px=m.renderPos.x,py=m.renderPos.y,pz=m.renderPos.z;
    m.head.position.set(px,py,pz);
    if(m.light)m.light.position.set(px,py,pz);

    const r=Math.hypot(px,py,pz)||1;
    const facing=camNx*(px/r)+camNy*(py/r)+camNz*(pz/r); // +1=facing camera, -1=behind sphere
    const visFactor=facing>0?1.0:Math.max(0.08,0.3+facing*0.5); // behind: 8%-30%
    m.glow.scale.set(0.32,0.32,1);
    m.glowMat.opacity=0.78*visFactor;
    m.head.material.opacity=0.92*visFactor;
    m.tipMat.opacity=0.88*visFactor;
    if(m.core){
      m.core.scale.set(0.082,0.082,1);
      m.coreMat.opacity=0.74*visFactor;
    }
    updateTrailRibbon(m,px,py,pz,visFactor,camX,camY,camZ);
    if(m.light)m.light.intensity=2.0*visFactor;
  }
}

function updateMeteors(dt){
  const G=2.5; // gravitational constant
  const sDt=dt*meteorSpeed*3.0;

  for(let mi=activeMeteors.length-1;mi>=0;mi--){
    const m=activeMeteors[mi];
    const pos=m.pos,prevPos=m.prevPos,vel=m.vel;
    m.age+=dt;

    // Gravitational acceleration toward sphere center
    prevPos.copy(pos);
    const prevX=prevPos.x,prevY=prevPos.y,prevZ=prevPos.z;
    const rPrev=Math.hypot(prevX,prevY,prevZ);
    const rGrav=Math.max(0.1,rPrev);
    const invR=1/rGrav;
    const accScale=-G/(rGrav*rGrav);
    // Symplectic Euler: update velocity, then position
    vel.x+=prevX*invR*accScale*sDt;
    vel.y+=prevY*invR*accScale*sDt;
    vel.z+=prevZ*invR*accScale*sDt;
    pos.x+=vel.x*sDt;
    pos.y+=vel.y*sDt;
    pos.z+=vel.z*sDt;
    const r=Math.hypot(pos.x,pos.y,pos.z); // post-update distance for impact check

    // Densify trail samples to avoid dotted look at higher meteor speeds
    const dx=pos.x-prevX,dy=pos.y-prevY,dz=pos.z-prevZ;
    const travel=Math.hypot(dx,dy,dz);
    let inserts=Math.ceil(travel/METEOR_TRAIL_POINT_STEP);
    if(!Number.isFinite(inserts)||inserts<1)inserts=1;
    if(inserts>METEOR_TRAIL_MAX_INSERTS)inserts=METEOR_TRAIL_MAX_INSERTS;
    const shift=inserts*3;
    for(let ti=m.trailLen*3-1;ti>=shift;ti--)m.trailPositions[ti]=m.trailPositions[ti-shift];
    if(inserts===1){
      m.trailPositions[0]=pos.x;
      m.trailPositions[1]=pos.y;
      m.trailPositions[2]=pos.z;
    }else{
      for(let j=0;j<inserts;j++){
        const f=1-j/(inserts-1);
        const bi=j*3;
        m.trailPositions[bi]=prevX+dx*f;
        m.trailPositions[bi+1]=prevY+dy*f;
        m.trailPositions[bi+2]=prevZ+dz*f;
      }
    }
    // Impact: meteor reached sphere surface (or timeout safety)
    if(r<=1.005||m.age>15){
      // Interpolate to find exact surface crossing point
      let ipx,ipy,ipz;
      if(rPrev>1.0&&r<1.0&&rPrev!==r){
        const t=(rPrev-1.0)/(rPrev-r);
        ipx=prevX+(pos.x-prevX)*t;
        ipy=prevY+(pos.y-prevY)*t;
        ipz=prevZ+(pos.z-prevZ)*t;
      }else{
        ipx=pos.x;ipy=pos.y;ipz=pos.z;
      }
      const il=Math.hypot(ipx,ipy,ipz)||1;
      _impactWorldPt.set(ipx/il,ipy/il,ipz/il);
      const grid=surfaceToGrid(_impactWorldPt);
      if(m.isNuke){
        applyNukeWipe(grid.x,grid.y,NUKE_WIPE_RADIUS);
      }else{
        // Keep Alive/Born color settings independent from Meteor toggle:
        // impact-seeded cells start "mature" so they use Alive color immediately.
        const placed=placeRandomOriented(m.patKey,grid.x,grid.y,undefined,4);
        if(placed)placed.forEach(([dx,dy])=>{
          const i=ix(grid.x+dx,grid.y+dy);
          meteorAge[i]=1.0;
          if(!meteorFlashMark[i]){meteorFlashMark[i]=1;meteorFlashIdx.push(i);}
        });
      }
      cntPop();pendingTexUpdate=true;updStats();
      impactRings.push({cx:grid.x,cy:grid.y,t:0,color:m.isNuke?NUKE_COLOR_RGB:null,bornBeat:1});
      meteorStats[m.patKey]=(meteorStats[m.patKey]||0)+1;
      updMeteorStats();
      showImpactOverlay(m.patKey);
      // Cleanup
      disposeMeteorVisuals(m);
      activeMeteors.splice(mi,1);
    }
  }
}

// ========================================
// IMPACT OVERLAY &mdash; multi-frame with per-slot fade
// ========================================
let impactSlots=[]; // each: {patKey,timer,num,el} or null
let impactNum=0;
let _rulesVisible=false, _rulesShowLock=0;
let _rulesOpacity=0; // current animated opacity
let _rulesLastUpdate=performance.now()*0.001;
// Fixed rules box dimensions (known from static content)
const RULES_W=340, RULES_H=90, RULES_MARGIN=10;

function setRulesVisible(nextVisible){
  if(_rulesVisible===nextVisible)return;
  _rulesVisible=nextVisible;
  // Anti-flicker: after every state change, delay next possible show.
  _rulesShowLock=2.0;
}

function tickRulesLock(){
  const now=performance.now()*0.001;
  const dt=Math.max(0,Math.min(0.25,now-_rulesLastUpdate));
  _rulesLastUpdate=now;
  if(_rulesShowLock>0)_rulesShowLock=Math.max(0,_rulesShowLock-dt);
}

function estimateMeteorImpactSeconds(m,maxAhead=2.0){
  // Short forward simulation: enough to decide "impact in < 1.5s?".
  const G=2.5;
  const step=0.05;
  const timeoutLeft=Math.max(0,15-(m.age||0));
  const horizon=Math.min(maxAhead,timeoutLeft);
  if(horizon<=0)return 0.1;
  let px=m.pos.x,py=m.pos.y,pz=m.pos.z;
  let vx=m.vel.x,vy=m.vel.y,vz=m.vel.z;
  const sDt=step*meteorSpeed*3.0;
  for(let t=step;t<=horizon+1e-6;t+=step){
    const rGrav=Math.max(0.1,Math.hypot(px,py,pz));
    const invR=1/rGrav;
    const accScale=-G/(rGrav*rGrav);
    vx+=px*invR*accScale*sDt;
    vy+=py*invR*accScale*sDt;
    vz+=pz*invR*accScale*sDt;
    px+=vx*sDt;
    py+=vy*sDt;
    pz+=vz*sDt;
    if(Math.hypot(px,py,pz)<=1.005)return t;
  }
  return Infinity;
}

let _spacePressureCacheT=0;
let _spacePressureCacheVal=Infinity;
let _spacePressureCacheMeteorCount=-1;
let _spacePressureCacheActiveCount=-1;
function predictSpacePressure(){
  // Predict if incoming meteors will cause overlap with rules box.
  if(!meteorMode||activeMeteors.length===0)return Infinity;
  const activeCount=impactSlots.filter(s=>s).length;
  const now=performance.now();
  if(now-_spacePressureCacheT<180&&
     _spacePressureCacheMeteorCount===activeMeteors.length&&
     _spacePressureCacheActiveCount===activeCount){
    return _spacePressureCacheVal;
  }
  const cap=computeOverlayCapacity();
  if(cap.cols<=0)return Infinity;
  // After each in-flight meteor lands, how many rows?
  const futureRows=Math.ceil((activeCount+activeMeteors.length)/Math.max(1,cap.cols));
  const futureOverlayBottom=cap.topY+(futureRows*(cap.cardH+cap.gridGap)-cap.gridGap)+8;
  const rulesTop=innerHeight-RULES_MARGIN-RULES_H;
  if(futureOverlayBottom<=rulesTop){
    _spacePressureCacheT=now;
    _spacePressureCacheVal=Infinity;
    _spacePressureCacheMeteorCount=activeMeteors.length;
    _spacePressureCacheActiveCount=activeCount;
    return Infinity;
  }
  // Overlap predicted: estimate earliest impact time.
  let soonest=Infinity;
  for(let i=0;i<activeMeteors.length;i++){
    const eta=estimateMeteorImpactSeconds(activeMeteors[i],2.0);
    if(eta<soonest)soonest=eta;
  }
  _spacePressureCacheT=now;
  _spacePressureCacheVal=soonest;
  _spacePressureCacheMeteorCount=activeMeteors.length;
  _spacePressureCacheActiveCount=activeCount;
  return soonest;
}

// Precompute fixed canvas size from largest meteor pattern (all frames same size)
let _impMaxW=0,_impMaxH=0;
METEOR_PATS.forEach(k=>{const p=PAT[k];if(!p)return;let x0=Infinity,y0=Infinity,x1=-Infinity,y1=-Infinity;p.forEach(([x,y])=>{if(x<x0)x0=x;if(y<y0)y0=y;if(x>x1)x1=x;if(y>y1)y1=y});_impMaxW=Math.max(_impMaxW,x1-x0+1);_impMaxH=Math.max(_impMaxH,y1-y0+1)});
const IMP_CELL=6,IMP_PAD=2,IMP_CVS_W=(_impMaxW+IMP_PAD*2)*IMP_CELL,IMP_CVS_H=(_impMaxH+IMP_PAD*2)*IMP_CELL;
const IMPACT_BORN_BEAT_SEC=0.22;
const _w2sOrigin=new THREE.Vector3(0,0,0);
const _w2sX=new THREE.Vector3(1,0,0);
const _w2sTmp=new THREE.Vector3();

function worldToScreen(v){
  const p=_w2sTmp.copy(v).project(camera);
  return{
    x:(p.x*0.5+0.5)*innerWidth,
    y:(-p.y*0.5+0.5)*innerHeight
  };
}

function computeOverlayCapacity(){
  // Collision system: compute how many columns/rows of impact cards fit
  // in the space RIGHT of the sphere, without overlapping anything.
  const overlay=document.getElementById('impactOverlay');
  const topbar=document.getElementById('topbar');
  const foot=document.getElementById('foot');
  const rules=document.getElementById('golRules');
  const margin=10, gridGap=8, gap=16;

  const topY=topbar?(topbar.getBoundingClientRect().bottom+8):60;
  const botY=foot&&foot.offsetParent!==null?(foot.getBoundingClientRect().top-8):(innerHeight-margin);

  // Measure one card size
  let cardW=120, cardH=120;
  if(overlay&&overlay.children.length>0){
    const sample=overlay.children[0];
    if(sample.offsetWidth>0)cardW=sample.offsetWidth;
    if(sample.offsetHeight>0)cardH=sample.offsetHeight;
  }

  // Compute where the sphere's right edge is on screen
  const sc=worldToScreen(_w2sOrigin);
  const se=worldToScreen(_w2sX);
  const sphereR=Math.max(80,Math.hypot(se.x-sc.x,se.y-sc.y));
  const sphereRightEdge=sc.x+sphereR;

  // Available width = from sphere right edge + gap to viewport right - margin
  const availW=Math.max(0,innerWidth-sphereRightEdge-gap-margin);
  const availH=Math.max(0,botY-topY);

  // Determine how many columns fit (4->3->2->1->0)
  let cols=4;
  while(cols>0){
    const neededW=cols*cardW+(cols-1)*gridGap;
    if(neededW<=availW)break;
    cols--;
  }

  // Max rows that fit vertically
  let maxRows=0;
  if(cols>0){
    maxRows=Math.max(0,Math.floor((availH+gridGap)/(cardH+gridGap)));
  }

  const maxSlots=cols*maxRows;

  // Left edge of the overlay (right-aligned within available space)
  const overlayW=cols>0?(cols*cardW+(cols-1)*gridGap):0;
  const overlayLeft=innerWidth-margin-overlayW;

  // Rules height measurement
  let rulesH=0;
  if(rules)rulesH=rules.scrollHeight||50;

  return{topY,botY,cols,maxRows,maxSlots,cardW,cardH,rulesH,overlayW,gridGap};
}

function positionImpactOverlay(){
  const overlay=document.getElementById('impactOverlay');
  if(!overlay)return;
  const activeCount=impactSlots.filter(s=>s).length;
  const rules=document.getElementById('golRules');
  const cap=computeOverlayCapacity();

  // Compute actual overlay height based on real active cards, not maxRows
  const actualRows=cap.cols>0?Math.ceil(activeCount/cap.cols):0;
  const actualOverlayH=actualRows>0?(actualRows*(cap.cardH+cap.gridGap)-cap.gridGap):0;

  // Rules: fixed bottom-right. Check collision with sphere and overlay.
  if(rules){
    // Rules rect (fixed position)
    const rLeft=innerWidth-RULES_MARGIN-RULES_W;
    const rTop=innerHeight-RULES_MARGIN-RULES_H;
    const rRight=innerWidth-RULES_MARGIN;
    const rBottom=innerHeight-RULES_MARGIN;

    // Sphere circle on screen
    const sc=worldToScreen(_w2sOrigin);
    const se=worldToScreen(_w2sX);
    const sphereR=Math.max(80,Math.hypot(se.x-sc.x,se.y-sc.y));
    // Check circle-rect overlap
    const closestX=Math.max(rLeft,Math.min(sc.x,rRight));
    const closestY=Math.max(rTop,Math.min(sc.y,rBottom));
    const distSq=(closestX-sc.x)**2+(closestY-sc.y)**2;
    const sphereOverlap=distSq<(sphereR+8)**2;

    // Overlay cards rect
    const overlayRight=innerWidth-10;
    const overlayLeft=overlayRight-(cap.cols>0?(cap.cols*cap.cardW+(cap.cols-1)*cap.gridGap):0);
    const overlayTop=cap.topY;
    const overlayBot=cap.topY+actualOverlayH;
    // Rect-rect overlap with rules
    const overlayOverlap=actualOverlayH>0&&
      rLeft<overlayRight&&rRight>overlayLeft&&
      rTop<overlayBot&&rBottom>overlayTop;

    // Predictive: fade out if meteors will force overlap soon.
    const pressureFadeOut=predictSpacePressure()<1.5;
    const canShowRules=!sphereOverlap&&!overlayOverlap&&activeCount>0&&cap.cols>0&&!pressureFadeOut;

    tickRulesLock();

    if(canShowRules){
      if(_rulesShowLock<=0)setRulesVisible(true);
    }else{
      // Hide immediately when any prerequisite fails.
      setRulesVisible(false);
    }


    // Animate opacity
    const targetOpacity=_rulesVisible?1:0;
    const fadeSpeed=_rulesVisible?0.025:0.08; // fade in ~0.6s, fade out ~0.2s
    _rulesOpacity+=(_rulesOpacity<targetOpacity?fadeSpeed:-fadeSpeed);
    _rulesOpacity=Math.max(0,Math.min(1,_rulesOpacity));
    rules.style.opacity=_rulesOpacity.toFixed(3);
    rules.style.visibility=_rulesOpacity<=0?'hidden':'visible';
  }

  if(!activeCount||!overlay.children.length){
    if(rules)setRulesVisible(false);
    return;
  }

  // If no space at all, hide overlay and rapidly expire all slots
  if(cap.maxSlots<=0){
    overlay.style.display='none';
    if(rules)setRulesVisible(false);
    // Quickly expire all active slots so they don't pile up
    for(let i=0;i<impactSlots.length;i++){
      if(impactSlots[i]&&impactSlots[i].timer>0.15)impactSlots[i].timer=0.15;
    }
    return;
  }

  // Accelerate fade on excess slots (oldest/shortest-lived first)
  if(activeCount>cap.maxSlots){
    const active=impactSlots.map((s,i)=>s?{s,i}:null).filter(Boolean)
      .sort((a,b)=>a.s.timer-b.s.timer);
    const excess=activeCount-cap.maxSlots;
    for(let i=0;i<excess&&i<active.length;i++){
      if(active[i].s.timer>0.2)active[i].s.timer=0.2;
    }
  }

  // Position: right-aligned, below topbar, never overlapping sphere
  overlay.style.gridTemplateColumns='repeat('+cap.cols+',auto)';
  overlay.style.left='auto';
  overlay.style.right='10px';
  overlay.style.top=Math.round(cap.topY)+'px';
  overlay.style.display='grid';
}

function makeImpactCard(patKey,num,useBorn=false){
  const isNuke=patKey===NUKE_PAT_KEY;
  const imp=isNuke?getMeteorColorData(true):(useBorn?getBornColorData():getImpactColorData());
  const icR=imp.r,icG=imp.g,icB=imp.b;
  const colStr='rgb('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+')';
  const glowStr='rgba('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+',0.6)';
  const pat=PAT[patKey];
  if(!pat&&!isNuke)return null;
  const card=document.createElement('div');card.className='imp-card';
  const numEl=document.createElement('div');numEl.className='imp-num';numEl.textContent=''+num;numEl.style.color=colStr;
  card.appendChild(numEl);
  const cvs=document.createElement('canvas');cvs.width=IMP_CVS_W;cvs.height=IMP_CVS_H;
  const ctx=cvs.getContext('2d');
  if(isNuke){
    ctx.fillStyle='rgba('+Math.round(icR*0.35)+','+Math.round(icG*0.35)+','+Math.round(icB*0.35)+',0.5)';
    ctx.fillRect(2,2,IMP_CVS_W-4,IMP_CVS_H-4);
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.shadowColor='rgba('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+',0.85)';
    ctx.shadowBlur=18;
    ctx.font='700 '+Math.floor(IMP_CVS_H*0.62)+'px Segoe UI Symbol, Noto Sans Symbols, sans-serif';
    ctx.fillStyle='rgba('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+',0.98)';
    ctx.fillText('\u2620',Math.floor(IMP_CVS_W*0.5),Math.floor(IMP_CVS_H*0.56));
    ctx.shadowBlur=0;
  }else{
    let x0=Infinity,y0=Infinity,x1=-Infinity,y1=-Infinity;
    pat.forEach(([x,y])=>{if(x<x0)x0=x;if(y<y0)y0=y;if(x>x1)x1=x;if(y>y1)y1=y});
    const offX=Math.floor((IMP_CVS_W-(x1-x0+1)*IMP_CELL)/2),offY=Math.floor((IMP_CVS_H-(y1-y0+1)*IMP_CELL)/2);
    pat.forEach(([x,y])=>{
      const px=offX+(x-x0)*IMP_CELL,py=offY+(y-y0)*IMP_CELL;
      ctx.fillStyle='rgba('+Math.round(icR*0.4)+','+Math.round(icG*0.4)+','+Math.round(icB*0.4)+',0.5)';
      ctx.fillRect(px-1,py-1,IMP_CELL+2,IMP_CELL+2);
      ctx.fillStyle='rgba('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+',0.95)';
      ctx.fillRect(px+1,py+1,IMP_CELL-2,IMP_CELL-2);
    });
  }
  card.appendChild(cvs);
  const lbl=document.createElement('div');lbl.className='imp-label';
  const _brl=PAT_BRAILLE[patKey]||'';
  lbl.innerHTML=(PAT_NAMES[patKey]||patKey).toUpperCase()+(_brl?' <span class="imp-sym">'+_brl+'</span>':'');
  lbl.style.color=colStr;lbl.style.textShadow='0 0 10px '+glowStr;
  card.appendChild(lbl);
  card.style.borderColor='rgba('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+',0.35)';
  card.style.boxShadow='0 0 15px rgba('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+',0.15)';
  return card;
}

function syncOverlayChild(idx){
  // Sync one grid cell: show card or invisible placeholder
  const overlay=document.getElementById('impactOverlay');
  const s=impactSlots[idx];
  const child=overlay.children[idx];
  if(s){
    if(child)overlay.replaceChild(s.el,child); else overlay.appendChild(s.el);
  }else{
    const ph=document.createElement('div');ph.className='imp-card';ph.style.visibility='hidden';
    if(child)overlay.replaceChild(ph,child); else overlay.appendChild(ph);
  }
}

function trimOverlay(){
  // Remove trailing empty placeholders + hide overlay if nothing left
  const overlay=document.getElementById('impactOverlay');
  while(impactSlots.length>0&&!impactSlots[impactSlots.length-1]){
    impactSlots.pop();
    if(overlay.lastChild)overlay.removeChild(overlay.lastChild);
  }
  if(impactSlots.length>0){
    overlay.style.display='grid';
  }else{
    overlay.style.display='none';
  }
}

function showImpactOverlay(patKey,keepTimer=false){
  const overlay=document.getElementById('impactOverlay');
  if(keepTimer){
    // Recolor existing cards in-place (e.g. when impact color changes)
    for(let i=0;i<impactSlots.length;i++){
      const s=impactSlots[i];if(!s)continue;
      const newEl=makeImpactCard(s.patKey,s.num,s.bornBeat>0);
      if(newEl){newEl.style.opacity=s.el.style.opacity||'1';s.el=newEl;syncOverlayChild(i)}
    }
    return;
  }
  // Check if there's any space at all before creating a new card
  const cap=computeOverlayCapacity();
  if(cap.maxSlots<=0){
    // No space &mdash; don't create the card, just count the stat
    return;
  }
  impactNum++;
  let idx=impactSlots.findIndex(s=>!s);
  if(idx<0)idx=impactSlots.length;
  const bornBeat=IMPACT_BORN_BEAT_SEC;
  const el=makeImpactCard(patKey,impactNum,bornBeat>0);
  if(!el)return;
  // Adapt timer: shorter lifetime when space is tight
  const activeCount=impactSlots.filter(s=>s).length;
  const slotsLeft=cap.maxSlots-activeCount;
  const timer=slotsLeft>2?7.0:slotsLeft>0?4.0:2.0;
  impactSlots[idx]={patKey,timer:timer,num:impactNum,el,bornBeat};
  syncOverlayChild(idx);
  overlay.style.display='grid';
  positionImpactOverlay();
}

// ========================================
// METEOR STATS
// ========================================
function updMeteorStats(){
  const el=document.getElementById('mStats');
  const entries=Object.entries(meteorStats).sort((a,b)=>b[1]-a[1]);
  if(entries.length===0){el.innerHTML='';return}
  const total=entries.reduce((s,e)=>s+e[1],0);
  const nukeEntry=entries.find(([k])=>k===NUKE_PAT_KEY);
  const displayEntries=nukeEntry
    ? [nukeEntry,...entries.filter(([k])=>k!==NUKE_PAT_KEY).slice(0,5)]
    : entries.slice(0,6);
  const imp=getImpactColorData();
  const soft='rgba('+Math.round(imp.r)+','+Math.round(imp.g)+','+Math.round(imp.b)+',0.72)';
  el.innerHTML='<span style="color:'+soft+'" title="Total meteor impacts since last clear"><span class="ml">Impacts:</span> <span class="mc" style="color:'+imp.css+'">'+total+'</span></span> '+
    displayEntries.map(([k,v])=>{
      const isNuke=k===NUKE_PAT_KEY;
      const kSoft=isNuke?'rgba('+NUKE_COLOR_RGB[0]+','+NUKE_COLOR_RGB[1]+','+NUKE_COLOR_RGB[2]+',0.82)':soft;
      const kColor=isNuke?NUKE_COLOR_CSS:imp.css;
      return '<span style="color:'+kSoft+'" title="Number of '+((PAT_NAMES[k]||k))+' impacts delivered by meteor"><span class="ml">'+(PAT_BRAILLE[k]||'')+' '+(PAT_NAMES[k]||k)+':</span> <span class="mc" style="color:'+kColor+'">'+v+'</span></span>';
    }).join(' ');
}

// ========================================
// TEXTURE RENDERING
// ========================================


function updTex(){
  const c=getColors();
  const d=texImgData;
  d.fill(0);
  const gridOn=$('tGrid').checked;

  const aR=c.alive[0]*c.iAlive, aG=c.alive[1]*c.iAlive, aB=c.alive[2]*c.iAlive;
  const bR=c.born[0]*c.iBorn, bG=c.born[1]*c.iBorn, bB=c.born[2]*c.iBorn;
  const dR=c.dead[0]*c.iDead, dG=c.dead[1]*c.iDead, dB=c.dead[2]*c.iDead;
  const gR=c.dots[0]*c.iDots, gG=c.dots[1]*c.iDots, gB=c.dots[2]*c.iDots;
  // Block-paint with pole correction (reduced height near poles for square cells)
  for(let y=0;y<H;y++){
    const sinTh=rowSinTh[y], cosTh=rowCosTh[y];
    const cellH=poleCellH[y];
    const glossMask=getCellGlossMask(cellH);
    const glossHi=glossMask.hi, glossSh=glossMask.sh;
    const yOff=(TEX_SCALE-cellH)>>1;
    for(let x=0;x<W;x++){
      const i=y*W+x;
      const alive=grid[i];
      let cr,cg,cb;
      if(alive){
        if(age[i]===0){cr=bR;cg=bG;cb=bB}
        else{cr=aR;cg=aG;cb=aB}
        // Meteor impact flash: spawned impact cells start in Born tint, then fade to Alive.
        if(meteorAge[i]>0){
          const mf=Math.min(1,meteorAge[i]);
          const inv=1-mf;
          cr=cr*inv+bR*mf;
          cg=cg*inv+bG*mf;
          cb=cb*inv+bB*mf;
        }
        if(cellExposure!==0){
          let L=(cr+cg+cb)/3;
          if(L>0.5){
            let Ln=Math.max(0,L*Math.pow(2,cellExposure));
            Ln=Math.min(255,Ln);
            let s=Ln/L;
            const mx=Math.max(cr,cg,cb)*s;
            if(mx>255)s=255/Math.max(cr,cg,cb);
            cr=Math.max(0,cr*s);cg=Math.max(0,cg*s);cb=Math.max(0,cb*s);
          }
        }
        if(cellSaturation!==0){
          const L=0.299*cr+0.587*cg+0.114*cb;
          const f=1+cellSaturation;
          cr=Math.max(0,Math.min(255,L+(cr-L)*f));
          cg=Math.max(0,Math.min(255,L+(cg-L)*f));
          cb=Math.max(0,Math.min(255,L+(cb-L)*f));
        }
        // Hemisphere side-light: top-right side looks slightly milkier,
        // opposite side slightly darker. Independent from meteor system.
        const nx=-colCosPh[x]*sinTh, ny=cosTh, nz=colSinPh[x]*sinTh;
        const hemi=nx*hemiLightDir.x+ny*hemiLightDir.y+nz*hemiLightDir.z;
        if(USE_TEXTURE_HEMI&&hemi!==0&&dayNightStrength>0){
          const milk=hemi>0?hemi*HEMI_MILK_STRENGTH*dayNightStrength:0;
          const dark=hemi<0?-hemi*HEMI_DARK_STRENGTH*dayNightStrength:0;
          const keep=1-dark;
          cr=cr*keep+(255-cr)*milk;
          cg=cg*keep+(255-cg)*milk;
          cb=cb*keep+(255-cb)*milk;
        }
      } else {
        cr=dR;cg=dG;cb=dB;
      }
      const txL=x*TEX_SCALE;
      const tyT=y*TEX_SCALE+yOff;
      if(alive){
        const br=Math.min(255,cr+35),bgr=Math.min(255,cg+35),bbr=Math.min(255,cb+35);
        for(let py=0;py<cellH;py++){
          const rowOff=(tyT+py)*TW;
          const glossOff=py*TEX_SCALE;
          const borderY=(py===0||py===cellH-1);
          for(let px=0;px<TEX_SCALE;px++){
            const tp=(rowOff+((txL+px)%TW+TW)%TW)<<2;
            const border=borderY||(px===0||px===TEX_SCALE-1);
            let pr,pg,pb;
            if(border){pr=br;pg=bgr;pb=bbr}
            else{pr=cr;pg=cg;pb=cb}
            let sh=glossSh[glossOff+px], hi=glossHi[glossOff+px];
            if(border){sh*=0.72;hi*=0.70}
            pr*=1-sh;pg*=1-sh;pb*=1-sh;
            pr=pr+(255-pr)*hi;pg=pg+(255-pg)*hi;pb=pb+(255-pb)*hi;
            d[tp]=pr;d[tp+1]=pg;d[tp+2]=pb;
            d[tp+3]=255;
          }
        }
      } else {
        for(let py=0;py<cellH;py++){
          const rowOff=(tyT+py)*TW;
          for(let px=0;px<TEX_SCALE;px++){
            const tp=(rowOff+((txL+px)%TW+TW)%TW)<<2;
            d[tp]=cr;d[tp+1]=cg;d[tp+2]=cb;d[tp+3]=0;
          }
        }
      }
    }
  }
  tx.putImageData(texImg,0,0);

  // Cell glow aura: computed at base res, scaled up for composite
  if(cellGlow){
    const gd=glowImgData;
    for(let i=0;i<TOTAL;i++){
      const p=i*4;
      if(grid[i]){
        gd[p]=aR;gd[p+1]=aG;gd[p+2]=aB;
        gd[p+3]=255;
      }else{
        gd[p]=0;gd[p+1]=0;gd[p+2]=0;gd[p+3]=0;
      }
    }
    gsx.putImageData(glowImg,0,0);
    gdx.clearRect(0,0,W,H);
    const blurPx=Math.max(0.6,glowRadius*3.0);
    gdx.filter='blur('+blurPx+'px)';
    gdx.drawImage(glowSrc,0,0);
    gdx.filter='none';
    // Compensate blur energy loss: additive self-compositing restores brightness
    const boostPasses=Math.max(0,Math.ceil(blurPx/6)-1);
    if(boostPasses>0){
      gdx.globalCompositeOperation='lighter';
      for(let bp=0;bp<boostPasses;bp++)gdx.drawImage(glowDst,0,0);
      gdx.globalCompositeOperation='source-over';
    }
    tx.globalCompositeOperation='lighter';
    tx.globalAlpha=Math.min(1.0,glowIntensity*2.0);
    tx.drawImage(glowDst,0,0,TW,TH);
    tx.globalAlpha=1;
    tx.globalCompositeOperation='source-over';
  }

  // Impact shockwave rings (scaled to TWxTH texture)
  if(impactRings.length>0){
    const bornC=hex2rgb($('cBorn').value);
    const bornI=+$('iBorn').value/100;
    const impC=hex2rgb($('cImpact').value);
    const impI=+$('iImpact').value/100;
    const S=TEX_SCALE;
    for(const ring of impactRings){
      const firstBeat=(ring.bornBeat===1)||ring.t<0.12;
      const ringC=firstBeat?bornC:(ring.color||impC);
      const ringI=firstBeat?bornI:(ring.color?1.0:impI);
      const r=ring.t*40*S;
      const rcx=(ring.cx+0.5)*S, rcy=(ring.cy+0.5)*S;
      const opacity=Math.max(0,1-ring.t/1.5)*ringI;
      if(ring.t<0.6){
        const f=1-ring.t/0.6;
        const flashR=Math.max(3,ring.t*22)*S;
        tx.fillStyle='rgba(255,255,255,'+(f*f*ringI).toFixed(3)+')';
        for(const ox of[-TW,0,TW]){tx.beginPath();tx.arc(rcx+ox,rcy,flashR*0.4,0,Math.PI*2);tx.fill()}
        tx.fillStyle='rgba('+ringC[0]+','+ringC[1]+','+ringC[2]+','+(f*ringI*0.7).toFixed(3)+')';
        for(const ox of[-TW,0,TW]){tx.beginPath();tx.arc(rcx+ox,rcy,flashR,0,Math.PI*2);tx.fill()}
      }
      const w=Math.max(1,4.5-ring.t*2.5)*S;
      tx.strokeStyle='rgba('+Math.round(ringC[0]*opacity)+','+Math.round(ringC[1]*opacity)+','+Math.round(ringC[2]*opacity)+','+opacity.toFixed(3)+')';
      tx.lineWidth=w;
      for(const ox of[-TW,0,TW]){tx.beginPath();tx.arc(rcx+ox,rcy,r,0,Math.PI*2);tx.stroke()}
      if(ring.t>0.12){
        const r2=(ring.t-0.12)*34*S;
        const op2=Math.max(0,1-(ring.t-0.12)/1.3)*ringI*0.45;
        tx.strokeStyle='rgba('+Math.round(ringC[0]*op2)+','+Math.round(ringC[1]*op2)+','+Math.round(ringC[2]*op2)+','+op2.toFixed(3)+')';
        tx.lineWidth=Math.max(0.5,2.5-ring.t*1.5)*S;
        for(const ox of[-TW,0,TW]){tx.beginPath();tx.arc(rcx+ox,rcy,r2,0,Math.PI*2);tx.stroke()}
      }
      if(firstBeat)ring.bornBeat=0;
    }
  }

  // Cross markers at wireframe intersections (fade out from center + bright center dot)
  if(gridOn && c.iDots>0.01){
    const prevComp=tx.globalCompositeOperation;
    tx.globalCompositeOperation='destination-over';
    const armLen=Math.max(2,dotRadius*TEX_SCALE);
    const steps=Math.ceil(armLen);
    for(let iy=1;iy<_wSegsH;iy++){
      const v=iy/_wSegsH;
      const tyPx=v*TH;
      const th=v*Math.PI;
      const sinTh=Math.max(0.06,Math.sin(th));
      const stretchX=Math.max(1,Math.min(12,1/sinTh)*0.7);
      const cellY=Math.min(H-1,Math.round(v*H));
      for(let ix=0;ix<_wSegsW;ix++){
        const u=ix/_wSegsW;
        const txPx=u*TW;
        const cellX=Math.round(u*W)%W;
        if(!grid[cellY*W+cellX]){
          // Cross arms (solid, fade only at tips)
          const fadePx=Math.min(3,steps);
          for(let s=1;s<=steps;s++){
            const tip=steps-s;
            const a=tip<fadePx?((tip+1)/fadePx*0.7).toFixed(3):'0.700';
            tx.fillStyle='rgba('+Math.round(gR)+','+Math.round(gG)+','+Math.round(gB)+','+a+')';
            const dx=s*stretchX, dy=s;
            tx.fillRect(txPx+dx-0.5,tyPx-0.5,1,1);
            tx.fillRect(txPx-dx-0.5,tyPx-0.5,1,1);
            tx.fillRect(txPx-0.5,tyPx+dy-0.5,1,1);
            tx.fillRect(txPx-0.5,tyPx-dy-0.5,1,1);
          }
          // Bright center dot
          tx.fillStyle='rgba(255,255,255,0.85)';
          tx.beginPath();
          tx.arc(txPx,tyPx,Math.max(0.8,armLen*0.15),0,Math.PI*2);
          tx.fill();
        }
      }
    }
    tx.globalCompositeOperation=prevComp;
  }

  lifeTex.needsUpdate=true;
  lastTexUpdate=performance.now();
}

// ========================================
// UI WIRING
// ========================================
function $(id){return document.getElementById(id)}
function updPlayBtn(){const b=$('bPlay');b.innerHTML=running?'&#9208; Pause':'&#9654; Play';b.classList.toggle('on',running)}
function fmtNum(n){
  if(n<1e6)return n.toLocaleString();
  if(n<1e9)return(n/1e6).toFixed(2)+'M';
  if(n<1e12)return(n/1e9).toFixed(2)+'B';
  return(n/1e12).toFixed(2)+'T';
}
function updStats(){$('sGen').textContent=fmtNum(gen);$('sPop').textContent=fmtNum(pop);$('sPct').textContent=((pop/TOTAL)*100).toFixed(1)+'%'}

$('bPlay').onclick=()=>{running=!running;updPlayBtn();save()};
$('bStep').onclick=()=>{step();updTex();updStats()};
$('bClear').onclick=()=>{clear();meteorStats={};updMeteorStats();updTex();updStats();save()};
$('bApply').onclick=()=>{applyPat();save()};
$('bRand').onclick=()=>{randomize();save()};

$('bWipe').onclick=()=>{wipeMode=!wipeMode;$('bWipe').classList.toggle('on',wipeMode);renderer.domElement.style.cursor=wipeMode?wipeCursor:'';save()};
$('rWipeR').oninput=e=>{wipeRadius=+e.target.value;$('vWipeR').textContent=e.target.value;save()};
$('rSpd').oninput=e=>{speed=+e.target.value;$('vSpd').textContent=speed+' gen/s';save()};
$('tMeteor').onchange=e=>{meteorMode=e.target.checked;meteorTimer=0;scheduleNextMeteor();save()};
$('rMInt').oninput=e=>{meteorInterval=+e.target.value;$('vMInt').textContent=e.target.value+'s';scheduleNextMeteor();save()};
$('rMSpd').oninput=e=>{meteorSpeed=+e.target.value/100;$('vMSpd').textContent=meteorSpeed.toFixed(1);save()};
$('rScat').oninput=e=>{$('vScat').textContent=e.target.value;save()};
$('rZoom').oninput=e=>{zoom=+e.target.value/10;$('vZoom').textContent=zoom.toFixed(1);save()};
$('tRot').onchange=e=>{autoRot=e.target.checked;save()};
$('rRSpd').oninput=e=>{rotSpd=+e.target.value/10;$('vRSpd').textContent=rotSpd.toFixed(1);save()};
$('rGlow').oninput=e=>{const v=+e.target.value/100;sphMat.emissiveIntensity=v;$('vGlow').textContent=v.toFixed(1);save()};
// Grid Dots toggle: always NearestFilter, just controls dot visibility
$('tGrid').onchange=e=>{updTex();save()};
$('tWire').onchange=e=>{wire.visible=e.target.checked;save()};
$('rWireExp').oninput=e=>{const v=+e.target.value/100;wireShaderMat.uniforms.wOpacity.value=v;$('vWireExp').textContent=e.target.value;save()};
// Dot size
$('rDotR').oninput=e=>{dotRadius=+e.target.value/10;$('vDotR').textContent=dotRadius.toFixed(1);updTex();save()};
// Cell glow controls
$('rExposure').oninput=e=>{cellExposure=+e.target.value/6.25;$('vExposure').textContent=e.target.value>0?'+'+e.target.value:e.target.value;updTex();save()};
$('rSaturation').oninput=e=>{cellSaturation=+e.target.value/100;$('vSaturation').textContent=e.target.value>0?'+'+e.target.value:e.target.value;updTex();save()};
$('rDayNight').oninput=e=>{dayNightStrength=+e.target.value/100;$('vDayNight').textContent=Math.round((+e.target.value)/2)+'%';syncDayNightUniform();updTex();save()};
$('tCGlow').onchange=e=>{cellGlow=e.target.checked;updTex();save()};
$('rCGR').oninput=e=>{glowRadius=+e.target.value;$('vCGR').textContent=e.target.value;updTex();save()};
$('rCGI').oninput=e=>{glowIntensity=+e.target.value/100;$('vCGI').textContent=glowIntensity.toFixed(1);updTex();save()};


// Theme preset dropdown
$('selTheme').onchange=e=>{applyPreset(e.target.value)};

// Color pickers & intensity sliders -> live update
['Alive','Born','Dead','Dots','Impact'].forEach(name=>{
  const cEl=$('c'+name), iEl=$('i'+name), ivEl=$('iv'+name);
  const handler=()=>{
    ivEl.textContent=iEl.value+'%';
    if(name==='Impact'){
      syncActiveMeteorColors();
      updMeteorStats();
      if(impactSlots.some(s=>s))showImpactOverlay(null,true);
    }
    updTex();
    save();
  };
  cEl.addEventListener('input',handler);
  iEl.addEventListener('input',handler);
});

// ========================================
// LOCAL STORAGE
// ========================================
function save(){
  try{localStorage.setItem('cl-gol2',JSON.stringify({
    speed,zoom,autoRot,rotSpd,meteorMode,meteorInterval,
    grid:$('tGrid').checked,wireframe:$('tWire').checked,wireExp:wireShaderMat.uniforms.wOpacity.value,
    glow:sphMat.emissiveIntensity,
    pat:$('selPat').value,scat:$('rScat').value,
    thm:$('selTheme').value,
    cAlive:$('cAlive').value,cBorn:$('cBorn').value,
    cDead:$('cDead').value,cDots:$('cDots').value,cImpact:$('cImpact').value,
    iAlive:$('iAlive').value,iBorn:$('iBorn').value,
    iDead:$('iDead').value,iDots:$('iDots').value,iImpact:$('iImpact').value,
    dotRadius,cellGlow,glowRadius,glowIntensity,cellExposure,cellSaturation,dayNightStrength,wipeRadius,meteorSpeed,
  }))}catch(e){}
}

function load(){
  try{
    const r=localStorage.getItem('cl-gol2');if(!r)return;
    const s=JSON.parse(r);
    if(s.speed){speed=s.speed;$('rSpd').value=speed;$('vSpd').textContent=speed+' gen/s'}
    if(s.zoom){zoom=s.zoom;$('rZoom').value=zoom*10;$('vZoom').textContent=zoom.toFixed(1)}
    if(s.autoRot!==undefined){autoRot=s.autoRot;$('tRot').checked=autoRot}
    if(s.rotSpd){rotSpd=s.rotSpd;$('rRSpd').value=rotSpd*10;$('vRSpd').textContent=rotSpd.toFixed(1)}
    if(s.meteorMode!==undefined){meteorMode=s.meteorMode;$('tMeteor').checked=meteorMode}
    if(s.meteorInterval){meteorInterval=s.meteorInterval;$('rMInt').value=meteorInterval;$('vMInt').textContent=meteorInterval+'s'}
    if(s.grid!==undefined){$('tGrid').checked=s.grid}
    if(s.wireframe!==undefined){$('tWire').checked=s.wireframe;wire.visible=s.wireframe}
    if(s.wireExp!==undefined){wireShaderMat.uniforms.wOpacity.value=s.wireExp;$('rWireExp').value=s.wireExp*100;$('vWireExp').textContent=Math.round(s.wireExp*100)}
    if(s.glow!==undefined){sphMat.emissiveIntensity=s.glow;$('rGlow').value=s.glow*100;$('vGlow').textContent=s.glow.toFixed(1)}
    if(s.pat)$('selPat').value=s.pat;
    if(s.scat){$('rScat').value=s.scat;$('vScat').textContent=s.scat}
    if(s.thm)$('selTheme').value=s.thm;
    if(s.cAlive)$('cAlive').value=s.cAlive;
    if(s.cBorn)$('cBorn').value=s.cBorn;
    if(s.cDead)$('cDead').value=s.cDead;
    if(s.cDots)$('cDots').value=s.cDots;
    if(s.cImpact)$('cImpact').value=s.cImpact;
    if(s.iAlive){$('iAlive').value=s.iAlive;$('ivAlive').textContent=s.iAlive+'%'}
    if(s.iBorn){$('iBorn').value=s.iBorn;$('ivBorn').textContent=s.iBorn+'%'}
    if(s.iDead){$('iDead').value=s.iDead;$('ivDead').textContent=s.iDead+'%'}
    if(s.iDots){$('iDots').value=s.iDots;$('ivDots').textContent=s.iDots+'%'}
    if(s.iImpact){$('iImpact').value=s.iImpact;$('ivImpact').textContent=s.iImpact+'%'}
    // New settings
    if(s.dotRadius!==undefined){dotRadius=s.dotRadius;$('rDotR').value=dotRadius*10;$('vDotR').textContent=dotRadius.toFixed(1)}
    if(s.cellGlow!==undefined){cellGlow=s.cellGlow;$('tCGlow').checked=cellGlow}
    if(s.glowRadius!==undefined){glowRadius=s.glowRadius;$('rCGR').value=glowRadius;$('vCGR').textContent=glowRadius}
    if(s.glowIntensity!==undefined){glowIntensity=s.glowIntensity;$('rCGI').value=glowIntensity*100;$('vCGI').textContent=glowIntensity.toFixed(1)}

    if(s.cellExposure!==undefined){cellExposure=s.cellExposure;$('rExposure').value=cellExposure*6.25;const ev=Math.round(cellExposure*6.25);$('vExposure').textContent=ev>0?'+'+ev:''+ev}
    if(s.cellSaturation!==undefined){cellSaturation=s.cellSaturation;$('rSaturation').value=cellSaturation*100;const cv=Math.round(cellSaturation*100);$('vSaturation').textContent=cv>0?'+'+cv:''+cv}
    if(s.dayNightStrength!==undefined){dayNightStrength=s.dayNightStrength;$('rDayNight').value=Math.round(dayNightStrength*100);$('vDayNight').textContent=Math.round(dayNightStrength*50)+'%';syncDayNightUniform()}
    if(s.wipeRadius!==undefined){wipeRadius=s.wipeRadius;$('rWipeR').value=wipeRadius;$('vWipeR').textContent=wipeRadius}
    if(s.meteorSpeed!==undefined){meteorSpeed=s.meteorSpeed;$('rMSpd').value=meteorSpeed*100;$('vMSpd').textContent=meteorSpeed.toFixed(1)}
    scheduleNextMeteor();
  }catch(e){}
}

// ========================================
// MAIN LOOP
// ========================================
let lastFrame=0;
const RENDER_INTERVAL_IDLE=1000/30; // base GPU cap when no meteors are active
const RENDER_INTERVAL_METEOR=1000/60; // smoother meteor heads while meteors are in flight
const TEX_UPDATE_INTERVAL=1000/15; // keep heavy texture rebuilds capped at 15 fps
const METEOR_UPDATE_INTERVAL=1/60; // meteor physics at fixed 60 Hz
let lastRender=0;
let lastTexUpdate=0;
let meteorAccum=0;
function animate(t){
  if(disposed)return;
  rafId=requestAnimationFrame(animate);
  if(!pageVisible||glContextLost){lastFrame=t;return}
  const dtRaw=(t-lastFrame)/1000||.016;
  const dt=Math.min(0.1,dtRaw); // clamp long stalls to avoid visible jumps
  lastFrame=t;

  if(running&&t-lastTick>=1000/speed){step();pendingTexUpdate=true;updStats();lastTick=t}

  // Meteor rain (randomized interval)
  if(meteorMode){
    meteorTimer+=dt;
    if(meteorTimer>=nextMeteorTime){meteorTimer=0;scheduleNextMeteor();spawnMeteor()}
  }
  if(activeMeteors.length>0){
    meteorAccum=Math.min(0.25,meteorAccum+dt);
    while(meteorAccum>=METEOR_UPDATE_INTERVAL){
      updateMeteors(METEOR_UPDATE_INTERVAL);
      meteorAccum-=METEOR_UPDATE_INTERVAL;
    }
  }else{
    meteorAccum=0;
  }

  // Decay meteor flash
  let hasMeteorFlash=false;
  if(meteorFlashIdx.length>0){
    for(let fi=meteorFlashIdx.length-1;fi>=0;fi--){
      const i=meteorFlashIdx[fi];
      meteorAge[i]-=dt*0.7;
      if(meteorAge[i]<=0){
        meteorAge[i]=0;
        meteorFlashMark[i]=0;
        const tail=meteorFlashIdx.length-1;
        meteorFlashIdx[fi]=meteorFlashIdx[tail];
        meteorFlashIdx.pop();
      }else{
        hasMeteorFlash=true;
      }
    }
  }
  if(hasMeteorFlash&&!running)pendingTexUpdate=true;

  // Advance and cull impact shockwave rings
  let hasRings=false;
  for(let ri=impactRings.length-1;ri>=0;ri--){
    impactRings[ri].t+=dt;
    if(impactRings[ri].t>1.6)impactRings.splice(ri,1);
    else hasRings=true;
  }
  if(hasRings||hasMeteorFlash)pendingTexUpdate=true;

  // Impact overlay per-slot fade (1s fade-out)
  {let _impTrim=false;
  for(let i=0;i<impactSlots.length;i++){
    const s=impactSlots[i];if(!s)continue;
    s.timer-=dt;
    if(s.bornBeat>0){
      s.bornBeat=Math.max(0,s.bornBeat-dt);
      if(s.bornBeat<=0){
        const newEl=makeImpactCard(s.patKey,s.num,false);
        if(newEl){
          newEl.style.opacity=s.el.style.opacity||'1';
          s.el=newEl;
          syncOverlayChild(i);
        }
      }
    }
    if(s.timer<=0){
      impactSlots[i]=null;
      syncOverlayChild(i);
      _impTrim=true;
    }else if(s.timer<=1.0){
      s.el.style.opacity=Math.max(0,s.timer/1.0).toString();
    }
  }
  if(_impTrim)trimOverlay();
  const overlayActive=impactSlots.some(s=>s)||_rulesVisible||_rulesOpacity>0;
  if(overlayActive&&t-lastOverlayLayout>=OVERLAY_LAYOUT_INTERVAL){
    positionImpactOverlay();
    lastOverlayLayout=t;
  }}

  if(autoRot&&!dragging){
    axisTimer+=dt;
    if(axisTimer>2+Math.random()*6){rotTarget.set((Math.random()-.5)*2,(Math.random()-.5)*2,(Math.random()-.5)*2).normalize();axisTimer=0}
    rotAxis.lerp(rotTarget,.008).normalize();
    rotQ.premultiply(new THREE.Quaternion().setFromAxisAngle(rotAxis,rotSpd*dt*.4));
  }

  sph.quaternion.copy(rotQ);sphBack.quaternion.copy(rotQ);wire.quaternion.copy(rotQ);
  camera.position.z+=(zoom-camera.position.z)*.1;

  // Only render to GPU at capped framerate with stable pacing
  const renderInterval=(activeMeteors.length>0)?RENDER_INTERVAL_METEOR:RENDER_INTERVAL_IDLE;
  const renderElapsed=t-lastRender;
  if(renderElapsed>=renderInterval){
    lastRender=t-(renderElapsed%renderInterval);
    updateCameraCenter();
    if(activeMeteors.length>0){
      updateMeteorVisuals(meteorAccum/METEOR_UPDATE_INTERVAL,dt);
    }
    const overlayActive=impactSlots.some(s=>s)||_rulesVisible||_rulesOpacity>0;
    if(overlayActive&&t-lastOverlayLayout>=OVERLAY_LAYOUT_INTERVAL){
      positionImpactOverlay();
      lastOverlayLayout=t;
    }
    if(pendingTexUpdate&&t-lastTexUpdate>=TEX_UPDATE_INTERVAL){
      updTex();
      pendingTexUpdate=false;
    }
    renderer.render(scene,camera);
  }
}

window.addEventListener('resize',()=>{
  if(disposed)return;
  renderer.setPixelRatio(Math.min(devicePixelRatio,MAX_PIXEL_RATIO));
  renderer.setSize(innerWidth,innerHeight);
  updateCameraCenter();
  positionImpactOverlay();
});

document.addEventListener('visibilitychange',()=>{
  pageVisible=!document.hidden;
  if(pageVisible){
    lastFrame=performance.now();
    lastRender=0;
    lastOverlayLayout=0;
    updateCameraCenter();
  }
});

function disposeScene(){
  if(disposed)return;
  disposed=true;
  running=false;
  if(rafId)cancelAnimationFrame(rafId);

  for(let i=activeMeteors.length-1;i>=0;i--){
    disposeMeteorVisuals(activeMeteors[i]);
  }
  activeMeteors.length=0;
  impactRings.length=0;
  impactSlots.length=0;
  meteorFlashIdx.length=0;
  meteorFlashMark.fill(0);

  meteorHeadGeo.dispose();
  meteorGlowTex.dispose();
  lifeTex.dispose();
  sphGeo.dispose();
  sphMat.dispose();
  sphBackMat.dispose();
  _wGeo.dispose();
  wireShaderMat.dispose();
  stGeo.dispose();
  stMat.dispose();

  if(renderer.forceContextLoss)renderer.forceContextLoss();
  renderer.dispose();
}

window.addEventListener('pagehide',disposeScene,{once:true});
window.addEventListener('beforeunload',disposeScene,{once:true});

// ========================================
// INIT
// ========================================
load();
initPatternSymbols();
scheduleNextMeteor();
randomize();
updStats();
animate(0);



</script>
</body>
</html>
