<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1.0, user-scalable=no">
<title>Conway's Game of Life &mdash; Sphere Edition</title>
<link rel="icon" href="data:,">
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap');

*{margin:0;padding:0;box-sizing:border-box}
:root{--bg:#0a0a0f;--panel:rgba(12,12,22,0.30);--bdr:rgba(0,255,200,0.22);--cyan:#00ffc8;--mag:#ff00aa;--yel:#e6ff00;--txt:#d8e4f0;--txt2:#92a4b8;--gcyan:0 0 10px rgba(0,255,200,0.35)}
html,body{width:100%;height:100dvh;background:var(--bg);color:var(--txt);font-family:'Rajdhani',sans-serif;overflow:hidden;user-select:none;-webkit-user-select:none}
canvas{display:block;touch-action:none}

#topbar{position:fixed;top:0;left:0;right:0;height:78px;background:var(--panel);backdrop-filter:blur(16px);border-bottom:1px solid var(--bdr);display:flex;align-items:center;justify-content:space-between;padding:0 20px;z-index:100}
#topbar h1{font-family:'Orbitron',sans-serif;font-size:24px;font-weight:700;letter-spacing:3px;background:linear-gradient(90deg,var(--cyan),var(--mag));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
#stats{display:flex;gap:18px;font-size:18px;font-weight:500;color:var(--txt2)}
#stats div{white-space:nowrap;display:flex;align-items:center;gap:2px}
#stats .stat-label{min-width:57px;text-align:right}
#stats em{font-style:normal;color:var(--cyan);font-weight:700;display:inline-block;min-width:93px;text-align:right;font-variant-numeric:tabular-nums;font-feature-settings:'tnum' 1}
#mStats{display:flex;gap:12px;font-size:16.5px;font-weight:500;color:#4488ff;flex-wrap:wrap;max-width:45vw;justify-content:flex-end}
#mStats span{white-space:nowrap;display:inline-flex;align-items:baseline;gap:2px}
#mStats .ml{min-width:78px;text-align:right}
#mStats .mc{color:#66aaff;font-weight:700;min-width:36px;display:inline-block;text-align:right;font-variant-numeric:tabular-nums}

#panel{position:fixed;top:88px;left:10px;width:272px;max-height:calc(100dvh - 102px);overflow-y:auto;overflow-x:hidden;background:var(--panel);backdrop-filter:blur(16px);border:1px solid var(--bdr);border-radius:10px;padding:14px;z-index:100;display:flex;flex-direction:column;gap:12px}
#panel::-webkit-scrollbar{width:3px}
#panel::-webkit-scrollbar-track{background:transparent}
#panel::-webkit-scrollbar-thumb{background:var(--bdr);border-radius:2px}

.sec{border-bottom:1px solid var(--bdr);padding-bottom:12px}
.sec:last-child{border-bottom:none;padding-bottom:0}
.sec-t{font-family:'Orbitron',sans-serif;font-size:9px;font-weight:700;letter-spacing:2px;text-transform:uppercase;color:var(--cyan);margin-bottom:8px}

.row{display:flex;gap:5px;flex-wrap:wrap}
.btn{display:inline-flex;align-items:center;justify-content:center;gap:5px;padding:7px 12px;border:1px solid var(--bdr);border-radius:5px;background:rgba(0,255,200,0.04);color:var(--txt);font-family:'Rajdhani',sans-serif;font-size:12px;font-weight:600;cursor:pointer;transition:all .2s;white-space:nowrap}
.btn:hover{background:rgba(0,255,200,0.1);border-color:var(--cyan);box-shadow:var(--gcyan)}
.btn.on{background:rgba(0,255,200,0.15);border-color:var(--cyan);color:var(--cyan);box-shadow:var(--gcyan)}
.btn.p{background:rgba(0,255,200,0.1);border-color:var(--cyan);color:var(--cyan)}
.btn.p:hover{background:rgba(0,255,200,0.2);box-shadow:0 0 16px rgba(0,255,200,0.4)}
.btn.d{border-color:rgba(255,0,170,0.2);color:var(--mag);background:rgba(255,0,170,0.04)}
.btn.d:hover{background:rgba(255,0,170,0.12);border-color:var(--mag)}
.sim-actions{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:5px}
.sim-actions .btn{min-width:0;padding:6px 8px;font-size:11px;line-height:1.1}

select{width:100%;padding:7px 30px 7px 10px;border:1px solid var(--bdr);border-radius:5px;background:rgba(0,255,200,0.04);color:var(--txt);font-family:'Rajdhani',sans-serif;font-size:12px;font-weight:500;cursor:pointer;outline:none;-webkit-appearance:none;appearance:none;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 5 5-5' stroke='%2300ffc8' stroke-width='1.5' fill='none'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:right 10px center}
select:hover{border-color:var(--cyan)}
select option{background:#151528;color:var(--txt)}
select optgroup{background:#0c0c20;color:var(--cyan);font-style:normal;font-weight:600}

.sg{display:flex;flex-direction:column;gap:3px}
.sl{display:flex;justify-content:space-between;font-size:11px;color:var(--txt2)}
.sl .v{color:var(--yel);font-weight:700}

input[type=range]{-webkit-appearance:none;width:100%;height:3px;border-radius:2px;background:rgba(0,255,200,0.12);outline:none}
input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:14px;height:14px;border-radius:50%;background:var(--cyan);cursor:pointer;box-shadow:0 0 6px rgba(0,255,200,0.5)}
input[type=range]::-moz-range-thumb{width:14px;height:14px;border-radius:50%;background:var(--cyan);cursor:pointer;border:none}

.trow{display:flex;justify-content:space-between;align-items:center;font-size:12px}
.tog{position:relative;width:36px;height:20px;cursor:pointer}
.tog input{opacity:0;width:0;height:0}
.tog-s{position:absolute;inset:0;background:rgba(255,255,255,0.08);border-radius:10px;transition:.3s}
.tog-s::before{content:'';position:absolute;width:14px;height:14px;left:3px;bottom:3px;background:var(--txt2);border-radius:50%;transition:.3s}
.tog input:checked+.tog-s{background:rgba(0,255,200,0.25)}
.tog input:checked+.tog-s::before{transform:translateX(16px);background:var(--cyan);box-shadow:0 0 5px var(--cyan)}

/* Color picker row */
.cpr{display:flex;align-items:center;gap:8px;margin-bottom:6px}
.cpr label{font-size:11px;color:var(--txt2);min-width:80px}
.cpr input[type=color]{-webkit-appearance:none;border:1px solid var(--bdr);border-radius:4px;width:32px;height:22px;padding:0;cursor:pointer;background:transparent}
.cpr input[type=color]::-webkit-color-swatch-wrapper{padding:1px}
.cpr input[type=color]::-webkit-color-swatch{border:none;border-radius:3px}
.cpr input[type=range]{flex:1}
.cpr .iv{font-size:10px;color:var(--yel);font-weight:700;min-width:28px;text-align:right}

#foot{position:fixed;bottom:8px;left:50%;transform:translateX(-50%);background:var(--panel);backdrop-filter:blur(16px);border:1px solid var(--bdr);border-radius:6px;padding:6px 14px;font-size:15px;color:var(--txt2);z-index:100;text-align:center}
#foot kbd{background:rgba(0,255,200,0.08);border:1px solid var(--bdr);border-radius:2px;padding:1px 4px;font-family:'Rajdhani',sans-serif;color:var(--cyan);font-size:15px}

/* Context menu */
#ctxMenu{position:fixed;z-index:200;background:var(--panel);backdrop-filter:blur(20px);border:1px solid var(--cyan);border-radius:8px;padding:6px 0;min-width:180px;max-height:70vh;overflow-y:auto;box-shadow:0 0 20px rgba(0,255,200,0.15),0 8px 32px rgba(0,0,0,0.6)}
#ctxMenu::-webkit-scrollbar{width:3px}
#ctxMenu::-webkit-scrollbar-thumb{background:var(--bdr);border-radius:2px}
.ctx-cat{font-family:'Orbitron',sans-serif;font-size:8px;font-weight:700;letter-spacing:2px;text-transform:uppercase;color:var(--cyan);padding:6px 14px 3px;opacity:.7}
.ctx-item{padding:5px 14px;font-size:12px;font-weight:500;cursor:pointer;transition:all .15s;color:var(--txt)}
.ctx-item:hover{background:rgba(0,255,200,0.12);color:var(--cyan);padding-left:18px}
.ctx-sym{font-size:13px;letter-spacing:1px;opacity:0.8;vertical-align:middle;margin-right:3px}
.imp-sym{font-size:11px;letter-spacing:1px;opacity:0.7;margin-left:4px}

/* Impact overlay &mdash; fixed position right side */
#impactOverlay{position:fixed;right:10px;right:max(10px,env(safe-area-inset-right));z-index:150;pointer-events:none;display:none;grid-template-columns:repeat(4,auto);gap:8px}
.imp-card{display:flex;flex-direction:column;align-items:center;gap:4px;background:rgba(8,12,28,0.30);border:1px solid rgba(68,102,255,0.36);border-radius:8px;padding:8px 10px;backdrop-filter:blur(14px)}
.imp-card canvas{image-rendering:pixelated;border-radius:4px}
.imp-num{font-family:'Orbitron',sans-serif;font-size:10px;opacity:0.5;letter-spacing:1px}
.imp-label{font-family:'Orbitron',sans-serif;font-size:10px;letter-spacing:1.5px;text-transform:uppercase;font-weight:700;white-space:nowrap}
#golRules{position:fixed;right:10px;right:max(10px,env(safe-area-inset-right));bottom:10px;bottom:max(10px,env(safe-area-inset-bottom));z-index:149;pointer-events:none;max-width:520px;padding:10px 16px;background:rgba(8,12,28,0.30);border:1px solid var(--bdr);border-radius:8px;backdrop-filter:blur(14px);font-family:'Rajdhani',sans-serif;font-size:16.5px;color:var(--txt2);line-height:1.5;opacity:0;visibility:hidden}
#golRules .rules-title{font-family:'Orbitron',sans-serif;font-size:13.5px;font-weight:700;letter-spacing:2px;color:var(--cyan);opacity:0.7;margin-bottom:5px}
#golRules .rule{margin-bottom:3px}
#golRules .rule em{font-style:normal;color:var(--cyan);font-weight:600}

@media(max-width:768px){
  #panel{width:calc(100% - 20px);max-height:40dvh;top:auto;bottom:10px;left:10px;right:10px}
  #foot{display:none}
  #topbar h1{font-size:18px;letter-spacing:1px}
  #stats{gap:10px;font-size:16.5px}
  #mStats{display:none}
}
</style>
</head>
<body>

<div id="topbar">
  <h1>CONWAY'S LIFE &middot; SPHERE</h1>
  <div id="mStats" title="Meteor impact history &mdash; shows total impacts and per-pattern breakdown of all meteor strikes on the sphere"></div>
  <div id="stats">
    <div title="Generation counter &mdash; the number of simulation steps (ticks) that have been computed since the last reset"><span class="stat-label">Gen:</span> <em id="sGen">0</em></div>
    <div title="Population &mdash; total count of currently living cells on the sphere surface"><span class="stat-label">Pop:</span> <em id="sPop">0</em></div>
    <div title="Alive percentage &mdash; fraction of all cells on the sphere that are currently alive"><span class="stat-label">Alive:</span> <em id="sPct">0%</em></div>
  </div>
</div>

<div id="panel">

  <!-- SIMULATION -->
  <div class="sec">
    <div class="sec-t">Simulation</div>
    <div class="row sim-actions">
      <button class="btn p" id="bPlay" title="Play / Pause &mdash; start or pause the cellular automaton simulation. Each tick computes one generation using Conway's B3/S23 rules on the sphere">&#9654; Play</button>
      <button class="btn" id="bStep" title="Step &mdash; advance the simulation by exactly one generation. Useful for observing how patterns evolve frame by frame">&#9197; Step</button>
      <button class="btn d" id="bClear" title="Clear &mdash; kill all living cells, reset the generation counter to zero, and stop the simulation">&#10005; Clear</button>
      <button class="btn" id="bWipe" title="Wipe mode &mdash; toggle eraser brush. While active, click-drag on the sphere surface to erase cells within the wipe radius">&#9711; Wipe</button>
    </div>
    <div style="height:5px"></div>
    <div class="row">
      <button class="btn" id="bExpCrashLog" title="Export Crash Log &mdash; download recent runtime diagnostics (WebGL context events, JS errors, and state snapshots) as JSON for analysis">&#8681; Export Crash Log</button>
      <button class="btn d" id="bClrCrashLog" title="Clear Crash Log &mdash; remove stored runtime diagnostics from local storage">&#128465; Clear Crash Log</button>
    </div>
    <div style="height:5px"></div>
    <div class="sg">
      <div class="sl"><span title="Wipe Radius &mdash; diameter of the circular eraser brush used in wipe mode. Larger values erase bigger areas per stroke">Wipe Radius</span><span class="v" id="vWipeR">10</span></div>
      <input type="range" id="rWipeR" min="3" max="40" value="10">
    </div>
    <div style="height:8px"></div>
    <div class="sg">
      <div class="sl"><span title="Speed &mdash; how many generations per second the simulation computes when playing. Higher values make evolution faster">Speed</span><span class="v" id="vSpd">2 gen/s</span></div>
      <input type="range" id="rSpd" min="1" max="60" value="2">
    </div>
    <div style="height:8px"></div>
    <div class="trow">
      <span title="Meteor Rain &mdash; when enabled, random Game of Life patterns are launched as meteors from deep space toward the sphere at randomised intervals, impacting the surface and seeding new life">Meteor Rain</span>
      <label class="tog"><input type="checkbox" id="tMeteor" checked><span class="tog-s"></span></label>
    </div>
    <div style="height:5px"></div>
    <div class="sg">
      <div class="sl"><span title="Meteor Interval &mdash; average time in seconds between meteor spawns. The actual timing is randomised around this value for organic variety">Meteor Interval</span><span class="v" id="vMInt">3s</span></div>
      <input type="range" id="rMInt" min="2" max="15" value="14">
    </div>
    <div style="height:5px"></div>
    <div class="sg">
      <div class="sl"><span title="Meteor Speed &mdash; controls how fast meteors travel through space toward the sphere. Higher values make them arrive more quickly">Meteor Speed</span><span class="v" id="vMSpd">0.1</span></div>
      <input type="range" id="rMSpd" min="10" max="150" value="10">
    </div>
  </div>

  <!-- PATTERNS -->
  <div class="sec">
    <div class="sec-t">Initial State</div>
    <select id="selPat" title="Pattern selector &mdash; choose a Game of Life pattern to place on the sphere. Random seeds fill the entire surface; named patterns are placed at random positions based on the Pattern Copies count">
      <optgroup label="--- Random Seeds ---">
        <option value="rnd-15">Random Sparse (15%)</option>
        <option value="rnd-30">Random Medium (30%)</option>
        <option value="rnd-50">Random Dense (50%)</option>
      </optgroup>
      <optgroup label="--- Still Lifes ---">
        <option value="block">Block</option>
        <option value="beehive">Beehive</option>
        <option value="loaf">Loaf</option>
        <option value="tub">Tub</option>
        <option value="boat">Boat</option>
        <option value="ship">Ship</option>
        <option value="pond">Pond</option>
      </optgroup>
      <optgroup label="--- Oscillators ---">
        <option value="blinker">Blinker (p2)</option>
        <option value="toad">Toad (p2)</option>
        <option value="beacon">Beacon (p2)</option>
        <option value="clock">Clock (p2)</option>
        <option value="pulsar">Pulsar (p3)</option>
        <option value="penta">Pentadecathlon (p15)</option>
        <option value="figureEight">Figure Eight (p8)</option>
        <option value="tumbler">Tumbler (p14)</option>
      </optgroup>
      <optgroup label="--- Spaceships ---">
        <option value="glider">Glider (c/4 diagonal)</option>
        <option value="lwss">Lightweight Spaceship</option>
        <option value="mwss">Middleweight Spaceship</option>
        <option value="hwss">Heavyweight Spaceship</option>
        <option value="copperhead">Copperhead (c/10)</option>
      </optgroup>
      <optgroup label="--- Guns / Factories ---">
        <option value="gosper">Gosper Glider Gun (Factory)</option>
      </optgroup>
      <optgroup label="--- Methuselahs ---">
        <option value="rpent">R-Pentomino (1103 gen)</option>
        <option value="acorn">Acorn (5206 gen)</option>
        <option value="diehard">Diehard (130 gen)</option>
        <option value="thunderbird">Thunderbird</option>
        <option value="piHept">&pi;-Heptomino</option>
        <option value="bhept">B-Heptomino</option>
      </optgroup>
      <optgroup label="--- Infinite Growth ---">
        <option value="inf1">Infinite Growth I</option>
        <option value="inf2">Infinite Growth II</option>
      </optgroup>
      <optgroup label="--- Superclass ---">
        <option value="totalAperiodic">Ⓢ Total Aperiodic (182 cells)</option>
      </optgroup>
    </select>
    <div style="height:6px"></div>
    <div class="row">
      <button class="btn p" id="bApply" title="Apply &mdash; clear the sphere and place the selected pattern. Random seeds fill the whole surface; named patterns are scattered as copies at random locations">Apply</button>
      <button class="btn" id="bRand" title="Randomize &mdash; clear the sphere and fill it with a random density of living cells (12&ndash;40%). Quick way to get unpredictable starting conditions">&#127922; Randomize</button>
    </div>
    <div style="height:6px"></div>
    <div class="sg">
      <div class="sl"><span title="Pattern Copies &mdash; how many copies of the selected pattern are scattered across the sphere when Apply is pressed. Only used for named patterns, not for random seeds">Pattern Copies</span><span class="v" id="vScat">8</span></div>
      <input type="range" id="rScat" min="1" max="40" value="8">
    </div>
  </div>

  <!-- CAMERA -->
  <div class="sec">
    <div class="sec-t">Camera</div>
    <div class="sg">
      <div class="sl"><span title="Zoom Distance &mdash; how far the camera is from the sphere. Lower values zoom in closer, higher values zoom out for a wider field of view">Zoom Distance</span><span class="v" id="vZoom">4.0</span></div>
      <input type="range" id="rZoom" min="15" max="80" value="40">
    </div>
    <div style="height:8px"></div>
    <div class="trow">
      <span title="Auto-Rotate &mdash; slowly and randomly rotate the sphere so all areas are visible over time. The rotation axis drifts organically for a cinematic effect">Auto-Rotate</span>
      <label class="tog"><input type="checkbox" id="tRot" checked><span class="tog-s"></span></label>
    </div>
    <div style="height:5px"></div>
    <div class="sg">
      <div class="sl"><span title="Rotation Speed &mdash; how fast the sphere auto-rotates. Higher values spin the sphere faster">Rotation Speed</span><span class="v" id="vRSpd">0.1</span></div>
      <input type="range" id="rRSpd" min="1" max="30" value="1">
    </div>
  </div>

  <!-- APPEARANCE -->
  <div class="sec">
    <div class="sec-t">Appearance</div>
    <div class="sg">
      <div class="sl"><span title="Emissive Glow &mdash; overall self-illumination intensity of the sphere. At 0 the sphere is only lit by scene lights; at max it glows brightly from within">Emissive Glow</span><span class="v" id="vGlow">1.0</span></div>
      <input type="range" id="rGlow" min="0" max="100" value="100">
    </div>
    <div style="height:6px"></div>
    <div class="trow">
      <span title="Grid Dots &mdash; toggle small circular reference dots on the sphere surface. These dots show the underlying cell grid structure on dead cells">Grid Dots</span>
      <label class="tog"><input type="checkbox" id="tGrid" checked><span class="tog-s"></span></label>
    </div>
    <div style="height:5px"></div>
    <div class="sg">
      <div class="sl"><span title="Dot Size &mdash; radius of the grid reference dots on the sphere. Larger dots make the grid structure more visible">Dot Size</span><span class="v" id="vDotR">0.8</span></div>
      <input type="range" id="rDotR" min="3" max="25" value="8">
    </div>
    <div style="height:6px"></div>
    <div class="sg">
      <div class="sl"><span title="Cell Exposure &mdash; brightens or darkens living cells. Positive values boost brightness and contrast, negative values dim them. Works like camera exposure compensation">Cell Exposure</span><span class="v" id="vExposure">+100</span></div>
      <input type="range" id="rExposure" min="-100" max="100" value="100">
    </div>
    <div style="height:4px"></div>
    <div class="sg">
      <div class="sl"><span title="Cell Saturation &mdash; adjusts colour richness of living cells. Positive values make colours more vivid, negative values desaturate toward greyscale">Cell Saturation</span><span class="v" id="vSaturation">+100</span></div>
      <input type="range" id="rSaturation" min="-100" max="100" value="100">
    </div>
    <div style="height:4px"></div>
    <div class="sg">
      <div class="sl"><span title="Day/Night Strength &mdash; controls the invisible top-right side light. 0 disables hemisphere shading, higher values increase bright-side milkiness and dark-side shading">Day/Night Strength</span><span class="v" id="vDayNight">50%</span></div>
      <input type="range" id="rDayNight" min="0" max="200" value="100">
    </div>
    <div style="height:6px"></div>
    <div class="trow">
      <span title="Cell Glow &mdash; adds a soft bloom aura around living cells. Creates a neon-like glow effect whose radius and intensity can be fine-tuned below">Cell Glow</span>
      <label class="tog"><input type="checkbox" id="tCGlow" checked><span class="tog-s"></span></label>
    </div>
    <div style="height:5px"></div>
    <div class="sg">
      <div class="sl"><span title="Glow Radius &mdash; blur radius of the cell glow aura. Larger values create a wider, softer bloom around living cells">Glow Radius</span><span class="v" id="vCGR">5</span></div>
      <input type="range" id="rCGR" min="1" max="20" value="5">
    </div>
    <div style="height:3px"></div>
    <div class="sg">
      <div class="sl"><span title="Glow Intensity &mdash; brightness of the cell glow aura. Higher values produce a more visible bloom effect">Glow Intensity</span><span class="v" id="vCGI">0.1</span></div>
      <input type="range" id="rCGI" min="10" max="100" value="10">
    </div>
    <div style="height:6px"></div>
    <div class="trow">
      <span title="Wireframe &mdash; overlay a geometric wireframe grid on the sphere surface. Fades based on viewing angle: bright on front-facing areas, transparent on edges">Wireframe</span>
      <label class="tog"><input type="checkbox" id="tWire" checked><span class="tog-s"></span></label>
    </div>
    <div style="height:4px"></div>
    <div class="sg">
      <div class="sl"><span title="Wire Exposure &mdash; brightness of the wireframe overlay. Higher values make the wireframe more visible against the sphere texture">Wire Exposure</span><span class="v" id="vWireExp">30</span></div>
      <input type="range" id="rWireExp" min="1" max="80" value="30">
    </div>
  </div>

  <!-- COLORS -->
  <div class="sec">
    <div class="sec-t">Colors</div>

    <div class="cpr" title="Alive colour &mdash; the base colour and brightness of living cells that have survived at least a few generations. This is the dominant colour visible on the sphere">
      <label>Alive</label>
      <input type="color" id="cAlive" value="#00ffc8">
      <input type="range" id="iAlive" min="10" max="100" value="100">
      <span class="iv" id="ivAlive">100%</span>
    </div>

    <div class="cpr" title="Born colour &mdash; the flash colour of cells in their first few generations of life. They transition from this colour to the Alive colour over ~3 ticks">
      <label>Born</label>
      <input type="color" id="cBorn" value="#ff00aa">
      <input type="range" id="iBorn" min="10" max="100" value="100">
      <span class="iv" id="ivBorn">100%</span>
    </div>

    <div class="cpr" title="Dead / Background colour &mdash; the colour of cells that are currently dead. Also serves as the sphere's background colour in areas with no activity">
      <label>Dead / BG</label>
      <input type="color" id="cDead" value="#0a0a14">
      <input type="range" id="iDead" min="10" max="100" value="100">
      <span class="iv" id="ivDead">100%</span>
    </div>

    <div class="cpr" title="Grid Dots colour &mdash; the colour and brightness of the small reference dots overlaid on the sphere surface. Only visible when Grid Dots is enabled">
      <label>Grid Dots</label>
      <input type="color" id="cDots" value="#0066ff">
      <input type="range" id="iDots" min="0" max="100" value="60">
      <span class="iv" id="ivDots">60%</span>
    </div>

    <div class="cpr" title="Impact colour &mdash; the colour used for meteor shockwave rings, the impact overlay cards, and the meteor statistics in the top bar">
      <label>Impact</label>
      <input type="color" id="cImpact" value="#4488ff">
      <input type="range" id="iImpact" min="10" max="100" value="100">
      <span class="iv" id="ivImpact">100%</span>
    </div>

    <div style="height:4px"></div>
    <div class="sl" style="margin-bottom:4px"><span title="Preset Themes &mdash; one-click colour schemes that set all five colour channels at once. You can further fine-tune individual colours after selecting a theme">Preset Themes</span></div>
    <select id="selTheme" title="Preset Themes &mdash; load a pre-configured colour scheme. Each preset changes Alive, Born, Dead, Grid Dots colours simultaneously">
      <option value="cm">Cyan & Magenta</option>
      <option value="go">Green & Orange</option>
      <option value="by">Blue & Yellow</option>
      <option value="pg">Purple & Green</option>
      <option value="fi">Fire</option>
      <option value="oc">Ocean</option>
      <option value="mx">Matrix</option>
    </select>
  </div>

</div>

<div id="ctxMenu" style="display:none"></div>
<div id="impactOverlay"></div>
<div id="golRules">
  <div class="rules-title">Conway's Game of Life &mdash; Rules</div>
  <div class="rule"><em>1. Birth:</em> A dead cell with exactly <em>3</em> living neighbours becomes alive.</div>
  <div class="rule"><em>2. Survival:</em> A living cell with <em>2</em> or <em>3</em> living neighbours stays alive.</div>
  <div class="rule"><em>3. Death:</em> All other living cells die &mdash; by underpopulation (&lt;2) or overcrowding (&gt;3).</div>
</div>

<div id="foot">
  <kbd>Drag</kbd> Rotate &middot; <kbd>Scroll</kbd> Zoom &middot; <kbd>Right-click</kbd> Place Pattern &middot; <kbd>Wipe</kbd> Erase Region &middot; Spherical Game of Life
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>

// ========================================
// ENGINE
// ========================================
const W=400, H=200, TOTAL=W*H, HW=W>>1;
let grid=new Uint8Array(TOTAL), buf=new Uint8Array(TOTAL), age=new Float32Array(TOTAL);
let gen=0, pop=0, running=false, speed=2, lastTick=0;
let meteorMode=true, meteorInterval=3, meteorTimer=0, nextMeteorTime=3;
let meteorSpeed=0.1;
let meteorAge=new Float32Array(TOTAL);
const meteorFlashMark=new Uint8Array(TOTAL);
const meteorFlashIdx=[];
let activeMeteors=[];
const meteorPool=[];
let meteorStats={};
const BASE_MAX_ACTIVE_METEORS=16;
let maxActiveMeteors=BASE_MAX_ACTIVE_METEORS;
const SAFE_MAX_ACTIVE_METEORS_LEVEL1=12;
const SAFE_MAX_ACTIVE_METEORS_LEVEL2=8;
const CRASH_LOG_STORAGE_KEY='cl-gol-crashlog-v1';
const CRASH_LOG_MAX_ENTRIES=300;
const BASE_RENDER_INTERVAL_IDLE=1000/24; // base GPU cap when no meteors are active
const BASE_RENDER_INTERVAL_METEOR=1000/45; // smoother meteor heads while meteors are in flight
const BASE_TEX_UPDATE_INTERVAL=1000/12; // keep heavy texture rebuilds capped at 12 fps
const METEOR_UPDATE_INTERVAL=1/60; // meteor physics at fixed 60 Hz
let renderIntervalIdle=BASE_RENDER_INTERVAL_IDLE;
let renderIntervalMeteor=BASE_RENDER_INTERVAL_METEOR;
let texUpdateInterval=BASE_TEX_UPDATE_INTERVAL;

// Appearance state
let dotRadius=0.8, cellGlow=true, glowRadius=5, glowIntensity=0.1, cellExposure=16, cellSaturation=1;
let dayNightStrength=1.0;
const CELL_GLOSS_HI_STRENGTH=0.12;  // subtle local glint (not point-like)
const CELL_GLOSS_SH_STRENGTH=0.05;  // subtle opposite-side shading
const cellGlossCache=[];

// Wipe mode
let wipeMode=false, wipeRadius=10, wiping=false;

// Impact shockwave rings
let impactRings=[];

// Texture upscale for pole distortion correction
const TEX_SCALE=10, TW=W*TEX_SCALE, TH=H*TEX_SCALE;
const hemiLightDir={x:0.70,y:0.60,z:0.38}; // invisible light from top-right
const HEMI_MILK_STRENGTH=0.08; // lit hemisphere -> slightly milkier
const HEMI_DARK_STRENGTH=0.06; // opposite hemisphere -> slightly darker
const USE_TEXTURE_HEMI=false; // Day/Night is handled in sphere shader for visible, stable effect.
const poleStretch=new Float32Array(H);
const poleCellH=new Uint8Array(H);
const rowSinTh=new Float32Array(H);
const rowCosTh=new Float32Array(H);
const colCosPh=new Float32Array(W);
const colSinPh=new Float32Array(W);
for(let y=0;y<H;y++){
  const th=(y+0.5)/H*Math.PI;
  const sinRaw=Math.sin(th);
  const sinTh=Math.max(0.06,sinRaw);
  rowSinTh[y]=sinRaw;
  rowCosTh[y]=Math.cos(th);
  poleStretch[y]=Math.min(12,1/sinTh);
  poleCellH[y]=Math.max(1,Math.round(TEX_SCALE*sinTh));
}
for(let x=0;x<W;x++){
  const ph=(x+0.5)/W*Math.PI*2;
  colCosPh[x]=Math.cos(ph);
  colSinPh[x]=Math.sin(ph);
}

function getCellGlossMask(cellH){
  let m=cellGlossCache[cellH];
  if(m)return m;
  const len=TEX_SCALE*cellH;
  const hi=new Float32Array(len);
  const sh=new Float32Array(len);
  for(let py=0;py<cellH;py++){
    const v=(py+0.5)/cellH;
    for(let px=0;px<TEX_SCALE;px++){
      const u=(px+0.5)/TEX_SCALE;
      // Broad top-right highlight, like a soft side light.
      const hdx=(u-0.74)/0.95, hdy=(v-0.30)/0.78;
      let hv=1-(hdx*hdx+hdy*hdy);
      if(hv<0)hv=0;
      // Opposite-side soft shading to preserve spherical depth.
      const sdx=(u-0.28)/0.98, sdy=(v-0.76)/0.88;
      let sv=1-(sdx*sdx+sdy*sdy);
      if(sv<0)sv=0;
      const gi=py*TEX_SCALE+px;
      hi[gi]=hv*hv*hv*CELL_GLOSS_HI_STRENGTH;
      sh[gi]=sv*sv*CELL_GLOSS_SH_STRENGTH;
    }
  }
  m={hi,sh};
  cellGlossCache[cellH]=m;
  return m;
}

// Spherical polar topology: reflect at poles with x+W/2 offset
function ix(x,y){
  if(y<0){y=-y-1;x+=HW}
  else if(y>=H){y=2*H-1-y;x+=HW}
  if(y<0)y=0;if(y>=H)y=H-1;
  return y*W+((x%W+W)%W);
}

function nb(x,y){let n=0;for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){if(!dx&&!dy)continue;if(grid[ix(x+dx,y+dy)])n++}return n}

const METEOR_FLASH_DECAY_PER_GEN=1/7;
function decayMeteorFlashByGenerations(genCount){
  if(genCount<=0||meteorFlashIdx.length===0)return false;
  const decay=genCount*METEOR_FLASH_DECAY_PER_GEN;
  let hasFlash=false;
  for(let fi=meteorFlashIdx.length-1;fi>=0;fi--){
    const i=meteorFlashIdx[fi];
    meteorAge[i]-=decay;
    if(meteorAge[i]<=0){
      meteorAge[i]=0;
      meteorFlashMark[i]=0;
      const tail=meteorFlashIdx.length-1;
      meteorFlashIdx[fi]=meteorFlashIdx[tail];
      meteorFlashIdx.pop();
    }else{
      hasFlash=true;
    }
  }
  return hasFlash;
}

function step(){
  pop=0;
  for(let y=0;y<H;y++)for(let x=0;x<W;x++){
    const i=y*W+x,n=nb(x,y),alive=grid[i];
    buf[i]=alive?(n===2||n===3?1:0):(n===3?1:0);
    if(buf[i]){age[i]=alive?Math.min(age[i]+1,80):0;pop++}
    else{age[i]=alive?-1:Math.min(age[i],-1)}
  }
  decayMeteorFlashByGenerations(1);
  [grid,buf]=[buf,grid]; gen++;
}

function clear(){
  grid.fill(0);buf.fill(0);age.fill(-15);meteorAge.fill(0);
  meteorFlashMark.fill(0);meteorFlashIdx.length=0;
  gen=0;pop=0;running=false;updPlayBtn();
}

// Patterns
const PAT={
  block:[[0,0],[1,0],[0,1],[1,1]],
  beehive:[[1,0],[2,0],[0,1],[3,1],[1,2],[2,2]],
  loaf:[[1,0],[2,0],[0,1],[3,1],[1,2],[3,2],[2,3]],
  tub:[[1,0],[0,1],[2,1],[1,2]],
  blinker:[[0,0],[1,0],[2,0]],
  toad:[[1,0],[2,0],[3,0],[0,1],[1,1],[2,1]],
  beacon:[[0,0],[1,0],[0,1],[3,2],[2,3],[3,3]],
  pulsar:(()=>{const c=[];for(const x of[2,3,4,8,9,10])for(const y of[0,5,7,12])c.push([x,y]);for(const y of[2,3,4,8,9,10])for(const x of[0,5,7,12])c.push([x,y]);return c})(),
  penta:[[1,0],[2,0],[3,0],[0,1],[4,1],[0,2],[4,2],[1,3],[2,3],[3,3],[1,6],[2,6],[3,6],[0,7],[4,7],[0,8],[4,8],[1,9],[2,9],[3,9]],
  glider:[[1,0],[2,1],[0,2],[1,2],[2,2]],
  lwss:[[1,0],[4,0],[0,1],[0,2],[4,2],[0,3],[1,3],[2,3],[3,3]],
  mwss:[[2,0],[0,1],[4,1],[5,2],[0,3],[5,3],[1,4],[2,4],[3,4],[4,4],[5,4]],
  hwss:[[2,0],[3,0],[0,1],[5,1],[6,2],[0,3],[6,3],[1,4],[2,4],[3,4],[4,4],[5,4],[6,4]],
  gosper:[[24,0],[22,1],[24,1],[12,2],[13,2],[20,2],[21,2],[34,2],[35,2],[11,3],[15,3],[20,3],[21,3],[34,3],[35,3],[0,4],[1,4],[10,4],[16,4],[20,4],[21,4],[0,5],[1,5],[10,5],[14,5],[16,5],[17,5],[22,5],[24,5],[10,6],[16,6],[24,6],[11,7],[15,7],[12,8],[13,8]],
  rpent:[[1,0],[2,0],[0,1],[1,1],[1,2]],
  acorn:[[1,0],[3,1],[0,2],[1,2],[4,2],[5,2],[6,2]],
  diehard:[[6,0],[0,1],[1,1],[1,2],[5,2],[6,2],[7,2]],
  inf1:[[0,0],[2,0],[2,1],[4,2],[4,3],[4,4],[6,3],[6,4],[6,5],[7,4]],
  inf2:[[0,0],[1,0],[2,0],[4,0],[0,1],[3,2],[4,2],[1,3],[2,3],[0,4],[1,4],[2,4]],
  boat:[[0,0],[1,0],[0,1],[2,1],[1,2]],
  ship:[[0,0],[1,0],[0,1],[2,1],[1,2],[2,2]],
  pond:[[1,0],[2,0],[0,1],[3,1],[0,2],[3,2],[1,3],[2,3]],
  clock:[[2,0],[0,1],[1,1],[2,2],[3,2],[1,3]],
  figureEight:[[0,0],[1,0],[2,0],[0,1],[1,1],[2,1],[0,2],[1,2],[2,2],[3,3],[4,3],[5,3],[3,4],[4,4],[5,4],[3,5],[4,5],[5,5]],
  tumbler:[[1,0],[5,0],[1,1],[5,1],[1,2],[2,2],[4,2],[5,2],[0,3],[2,3],[4,3],[6,3],[0,4],[2,4],[4,4],[6,4],[0,5],[1,5],[5,5],[6,5]],
  thunderbird:[[0,0],[1,0],[2,0],[1,2],[1,3],[1,4]],
  piHept:[[0,0],[1,0],[2,0],[0,1],[2,1],[0,2],[2,2]],
  bhept:[[1,0],[0,1],[1,1],[2,1],[0,2],[2,2],[1,3]],
  copperhead:[[1,0],[2,0],[4,0],[5,0],[3,1],[4,1],[3,2],[4,2],[0,3],[2,3],[5,3],[7,3],[0,4],[7,4],[0,6],[7,6],[1,7],[2,7],[5,7],[6,7],[2,8],[3,8],[4,8],[5,8],[3,10],[4,10],[3,11],[4,11]],
  totalAperiodic:[[41,0],[40,1],[41,1],[42,1],[39,2],[40,2],[42,2],[48,2],[39,3],[40,3],[41,3],[47,3],[48,3],[49,3],[40,4],[41,4],[46,4],[49,4],[50,4],[54,4],[55,4],[56,4],[46,5],[47,5],[48,5],[53,5],[56,5],[56,6],[56,7],[56,8],[40,9],[41,9],[42,9],[55,9],[40,10],[43,10],[40,11],[40,12],[41,13],[38,20],[39,20],[40,20],[38,21],[41,21],[53,21],[38,22],[52,22],[53,22],[54,22],[38,23],[51,23],[52,23],[54,23],[38,24],[51,24],[52,24],[53,24],[39,25],[52,25],[53,25],[35,28],[36,28],[37,28],[34,29],[35,29],[36,29],[37,29],[38,29],[34,30],[35,30],[36,30],[38,30],[39,30],[47,30],[48,30],[54,30],[57,30],[37,31],[38,31],[46,31],[47,31],[48,31],[49,31],[58,31],[46,32],[47,32],[49,32],[50,32],[54,32],[58,32],[48,33],[49,33],[55,33],[56,33],[57,33],[58,33],[20,36],[21,37],[1,38],[2,38],[16,38],[21,38],[54,38],[55,38],[56,38],[0,39],[1,39],[2,39],[3,39],[17,39],[18,39],[19,39],[20,39],[21,39],[56,39],[0,40],[1,40],[3,40],[4,40],[56,40],[2,41],[3,41],[55,41],[36,42],[37,43],[21,44],[22,44],[33,44],[37,44],[22,45],[23,45],[34,45],[35,45],[36,45],[37,45],[53,45],[54,45],[21,46],[22,46],[50,46],[51,46],[52,46],[54,46],[55,46],[21,47],[50,47],[51,47],[52,47],[53,47],[54,47],[51,48],[52,48],[53,48],[22,50],[23,50],[13,51],[14,51],[15,51],[16,51],[21,51],[22,51],[23,51],[24,51],[12,52],[16,52],[21,52],[22,52],[24,52],[25,52],[1,53],[2,53],[3,53],[4,53],[5,53],[16,53],[23,53],[24,53],[0,54],[5,54],[15,54],[5,55],[4,56]],
};

// Pattern display names
const PAT_NAMES={
  block:'Block',beehive:'Beehive',loaf:'Loaf',tub:'Tub',boat:'Boat',ship:'Ship',pond:'Pond',
  blinker:'Blinker',toad:'Toad',beacon:'Beacon',clock:'Clock',pulsar:'Pulsar',penta:'Pentadec.',
  figureEight:'Fig.Eight',tumbler:'Tumbler',
  glider:'Glider',lwss:'LWSS',mwss:'MWSS',hwss:'HWSS',copperhead:'Copperhead',
  gosper:'Gosper Gun',rpent:'R-Pento',acorn:'Acorn',diehard:'Diehard',
  thunderbird:'Thunder',piHept:'\u03C0-Hept',bhept:'B-Hept',
  inf1:'Inf.I',inf2:'Inf.II',nuke:'Nuke',superNuke:'Super Nuke',
  totalAperiodic:'Total Aperiodic',
};

// Braille pattern symbol generator (renders pattern as Unicode braille art)
function patternToBraille(patKey){
  const pat=PAT[patKey];
  if(!pat||pat.length===0)return '';
  let x0=Infinity,y0=Infinity,x1=-Infinity,y1=-Infinity;
  pat.forEach(([x,y])=>{x0=Math.min(x0,x);y0=Math.min(y0,y);x1=Math.max(x1,x);y1=Math.max(y1,y)});
  const ow=x1-x0+1,oh=y1-y0+1;
  const maxW=10,maxH=4;
  const sc=Math.max(1,ow/maxW,oh/maxH);
  const ew=Math.min(maxW,Math.ceil(ow/sc)),eh=Math.min(maxH,Math.ceil(oh/sc));
  const cells=new Set();
  pat.forEach(([x,y])=>{cells.add((x-x0)+','+(y-y0))});
  const g=[];
  for(let y=0;y<eh;y++){g[y]=[];for(let x=0;x<ew;x++){
    let found=false;
    const sx=Math.floor(x*sc),sy=Math.floor(y*sc),ex=Math.ceil((x+1)*sc),ey=Math.ceil((y+1)*sc);
    for(let oy=sy;oy<ey&&!found;oy++)for(let ox=sx;ox<ex&&!found;ox++)if(cells.has(ox+','+oy))found=true;
    g[y][x]=found;
  }}
  const cw=Math.ceil(ew/2);
  let r='';
  for(let cx=0;cx<cw;cx++){
    let c=0x2800;
    const bits=[[0,0,0x01],[0,1,0x02],[0,2,0x04],[0,3,0x40],[1,0,0x08],[1,1,0x10],[1,2,0x20],[1,3,0x80]];
    for(const[dx,dy,bit]of bits){
      const gx=cx*2+dx,gy=dy;
      if(gx<ew&&gy<eh&&g[gy][gx])c|=bit;
    }
    r+=String.fromCharCode(c);
  }
  return r;
}
const PAT_BRAILLE={};
Object.keys(PAT).forEach(k=>{PAT_BRAILLE[k]=patternToBraille(k)});
PAT_BRAILLE.nuke='\u2620';
PAT_BRAILLE.superNuke='\u2622';
PAT_BRAILLE.totalAperiodic='\u24C8';

// Superclass keys — patterns too large for cell-by-cell icon rendering
const SUPERCLASS_KEYS=['totalAperiodic'];
function isSuperclassKey(patKey){ return SUPERCLASS_KEYS.indexOf(patKey)!==-1; }
const SUPERCLASS_COLOR_RGB=[0,220,255];
const SUPERCLASS_COLOR_CSS='rgb('+SUPERCLASS_COLOR_RGB[0]+','+SUPERCLASS_COLOR_RGB[1]+','+SUPERCLASS_COLOR_RGB[2]+')';
const SUPERCLASS_COLOR_THREE=new THREE.Color(SUPERCLASS_COLOR_RGB[0]/255,SUPERCLASS_COLOR_RGB[1]/255,SUPERCLASS_COLOR_RGB[2]/255);

function initPatternSymbols(){
  document.querySelectorAll('#selPat option').forEach(opt=>{
    const k=opt.value;
    if(PAT_BRAILLE[k])opt.textContent=opt.textContent+' '+PAT_BRAILLE[k];
  });
}

// Pattern metadata for context menu
const PAT_MENU=[
  {cat:'Still Lifes',items:[['block','Block'],['beehive','Beehive'],['loaf','Loaf'],['tub','Tub'],['boat','Boat'],['ship','Ship'],['pond','Pond']]},
  {cat:'Oscillators',items:[['blinker','Blinker (p2)'],['toad','Toad (p2)'],['beacon','Beacon (p2)'],['clock','Clock (p2)'],['pulsar','Pulsar (p3)'],['penta','Pentadecathlon (p15)'],['figureEight','Figure Eight (p8)'],['tumbler','Tumbler (p14)']]},
  {cat:'Spaceships',items:[['glider','Glider'],['lwss','LWSS'],['mwss','MWSS'],['hwss','HWSS'],['copperhead','Copperhead (c/10)']]},
  {cat:'Guns',items:[['gosper','Gosper Glider Gun']]},
  {cat:'Methuselahs',items:[['rpent','R-Pentomino'],['acorn','Acorn'],['diehard','Diehard'],['thunderbird','Thunderbird'],['piHept','\u03C0-Heptomino'],['bhept','B-Heptomino']]},
  {cat:'Infinite Growth',items:[['inf1','Infinite I'],['inf2','Infinite II']]},
  {cat:'Superclass',items:[['totalAperiodic','\u24C8 Total Aperiodic']]},
];

function place(k,cx,cy){const p=PAT[k];if(!p)return;p.forEach(([dx,dy])=>{const i=ix(cx+dx,cy+dy);grid[i]=1;age[i]=0})}
function rotatePatternOffsets(pat,angleRad){
  // Keep canonical pattern integrity by rotating in 90-degree steps,
  // while still drawing a random 0..360-degree start angle per placement.
  const quarter=((Math.round(angleRad/(Math.PI*0.5))%4)+4)%4;
  if(quarter===0)return pat;

  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for(let i=0;i<pat.length;i++){
    const x=pat[i][0],y=pat[i][1];
    if(x<minX)minX=x;if(y<minY)minY=y;
    if(x>maxX)maxX=x;if(y>maxY)maxY=y;
  }
  const cx=(minX+maxX)/2,cy=(minY+maxY)/2;
  const out=[],seen=new Set();
  for(let i=0;i<pat.length;i++){
    const x=pat[i][0]-cx,y=pat[i][1]-cy;
    let rx,ry;
    if(quarter===1){rx=y;ry=-x}
    else if(quarter===2){rx=-x;ry=-y}
    else{rx=-y;ry=x}
    const nx=Math.round(rx+cx),ny=Math.round(ry+cy);
    const key=nx+','+ny;
    if(!seen.has(key)){seen.add(key);out.push([nx,ny])}
  }
  return out;
}
function placeRandomOriented(k,cx,cy,angleRad,spawnAge=0){
  const p=PAT[k];if(!p)return null;
  const a=angleRad===undefined?Math.random()*Math.PI*2:angleRad;
  const rp=rotatePatternOffsets(p,a);
  rp.forEach(([dx,dy])=>{const i=ix(cx+dx,cy+dy);grid[i]=1;age[i]=spawnAge});
  return rp;
}
function applyPat(){
  const v=$('selPat').value, sc=+$('rScat').value;
  clear();
  if(v.startsWith('rnd-')){const d=parseInt(v.split('-')[1])/100;for(let i=0;i<TOTAL;i++){grid[i]=Math.random()<d?1:0;age[i]=grid[i]?Math.random()*40:-15}}
  else{for(let s=0;s<sc;s++)placeRandomOriented(v,Math.floor(Math.random()*W),Math.floor(Math.random()*H))}
  cntPop();updTex();updStats();
}
function randomize(){clear();const d=.12+Math.random()*.28;for(let i=0;i<TOTAL;i++){grid[i]=Math.random()<d?1:0;age[i]=grid[i]?Math.random()*40:-15}cntPop();updTex();updStats()}
function cntPop(){pop=0;for(let i=0;i<TOTAL;i++)if(grid[i])pop++}

// ========================================
// COLOR SYSTEM
// ========================================
function hex2rgb(h){const r=parseInt(h.slice(1,3),16),g=parseInt(h.slice(3,5),16),b=parseInt(h.slice(5,7),16);return[r,g,b]}
function rgb2hex(r,g,b){return'#'+[r,g,b].map(v=>Math.round(v).toString(16).padStart(2,'0')).join('')}
function clamp(v,min,max){return Math.max(min,Math.min(max,v))}

function getImpactColorData(){
  const rgb=hex2rgb($('cImpact').value);
  const intensity=+$('iImpact').value/100;
  const r=clamp(rgb[0]*intensity,0,255);
  const g=clamp(rgb[1]*intensity,0,255);
  const b=clamp(rgb[2]*intensity,0,255);
  return{
    rgb,intensity,r,g,b,
    three:new THREE.Color(r/255,g/255,b/255),
    css:'rgb('+Math.round(r)+','+Math.round(g)+','+Math.round(b)+')'
  };
}

function getBornColorData(){
  const rgb=hex2rgb($('cBorn').value);
  const intensity=+$('iBorn').value/100;
  const r=clamp(rgb[0]*intensity,0,255);
  const g=clamp(rgb[1]*intensity,0,255);
  const b=clamp(rgb[2]*intensity,0,255);
  return{
    rgb,intensity,r,g,b,
    css:'rgb('+Math.round(r)+','+Math.round(g)+','+Math.round(b)+')'
  };
}

function getColors(){
  return{
    alive: hex2rgb($('cAlive').value),
    born:  hex2rgb($('cBorn').value),
    dead:  hex2rgb($('cDead').value),
    dots:  hex2rgb($('cDots').value),
    iAlive:+$('iAlive').value/100,
    iBorn: +$('iBorn').value/100,
    iDead: +$('iDead').value/100,
    iDots: +$('iDots').value/100,
  };
}

const PRESETS={
  cm:{alive:'#00ffc8',born:'#ff00aa',dead:'#0a0a14',dots:'#0066ff'},
  go:{alive:'#39ff14',born:'#ff6a00',dead:'#0a100a',dots:'#0044ff'},
  by:{alive:'#00aaff',born:'#ffd500',dead:'#0a0a14',dots:'#0055ff'},
  pg:{alive:'#bf00ff',born:'#39ff14',dead:'#100a14',dots:'#0066ff'},
  fi:{alive:'#ff5000',born:'#ffdc00',dead:'#140804',dots:'#0044cc'},
  oc:{alive:'#00c8ff',born:'#00ffb4',dead:'#040814',dots:'#0055ff'},
  mx:{alive:'#00ff41',born:'#96ff96',dead:'#000800',dots:'#003388'},
};

function applyPreset(key){
  const p=PRESETS[key]; if(!p)return;
  $('cAlive').value=p.alive;
  $('cBorn').value=p.born;
  $('cDead').value=p.dead;
  $('cDots').value=p.dots;
  updTex(); save();
}

// ========================================
// THREE.JS SCENE
// ========================================
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(50,innerWidth/innerHeight,0.1,100);
camera.position.set(0,0,3);

function createStableRenderer(){
  const attempts=[
    {antialias:false,powerPreference:'default'},
    {antialias:false,powerPreference:'low-power'},
    {antialias:true,powerPreference:'default'}
  ];
  let lastErr=null;
  for(let i=0;i<attempts.length;i++){
    try{return new THREE.WebGLRenderer(attempts[i])}
    catch(err){lastErr=err}
  }
  throw lastErr||new Error('WebGL renderer initialization failed');
}

const renderer=createStableRenderer();
const BASE_MAX_PIXEL_RATIO=1.25;
const MAX_DRAW_PIXELS=2560*1440;
let maxPixelRatio=BASE_MAX_PIXEL_RATIO;
let contextLossCount=0;
const CONTEXT_LOSS_BURST_WINDOW_MS=120000;
const CONTEXT_LOSS_DEGRADE_AFTER=1;
const CONTEXT_LOSS_PIXEL_RATIO_STEP=0.25;
const CONTEXT_LOSS_PIXEL_RATIO_MIN=1.0;
const contextLossTimes=[];
let lastContextLossBurst=0;
let contextRecoveryTimer=0;
function getTargetPixelRatio(){
  const viewportPixels=Math.max(1,innerWidth*innerHeight);
  const budgetPixelRatio=Math.sqrt(MAX_DRAW_PIXELS/viewportPixels);
  return Math.max(0.5,Math.min(devicePixelRatio,maxPixelRatio,budgetPixelRatio));
}
function applyRendererResolution(){
  renderer.setPixelRatio(getTargetPixelRatio());
  renderer.setSize(innerWidth,innerHeight);
}
function registerContextLossBurst(){
  const now=performance.now();
  contextLossTimes.push(now);
  while(contextLossTimes.length>0&&now-contextLossTimes[0]>CONTEXT_LOSS_BURST_WINDOW_MS){
    contextLossTimes.shift();
  }
  const burstCount=contextLossTimes.length;
  if(burstCount>=CONTEXT_LOSS_DEGRADE_AFTER){
    const drops=burstCount-CONTEXT_LOSS_DEGRADE_AFTER+1;
    const nextMax=Math.max(CONTEXT_LOSS_PIXEL_RATIO_MIN,BASE_MAX_PIXEL_RATIO-drops*CONTEXT_LOSS_PIXEL_RATIO_STEP);
    if(nextMax<maxPixelRatio){
      const prev=maxPixelRatio;
      maxPixelRatio=nextMax;
      addCrashLog('pixel-ratio-degraded','warn',{prev:Number(prev.toFixed(3)),next:Number(nextMax.toFixed(3)),burstCount});
    }
  }
  return burstCount;
}
function applyContextLossSafetyProfile(burstCount){
  let changed=false;
  let profile='none';

  if(burstCount>=1){
    profile='L1';
    if(maxActiveMeteors>SAFE_MAX_ACTIVE_METEORS_LEVEL1){
      maxActiveMeteors=SAFE_MAX_ACTIVE_METEORS_LEVEL1;
      changed=true;
    }
    if(renderIntervalMeteor<1000/40){
      renderIntervalMeteor=1000/40;
      changed=true;
    }
    if(texUpdateInterval<1000/10){
      texUpdateInterval=1000/10;
      changed=true;
    }
  }

  if(burstCount>=2){
    profile='L2';
    if(maxActiveMeteors>SAFE_MAX_ACTIVE_METEORS_LEVEL2){
      maxActiveMeteors=SAFE_MAX_ACTIVE_METEORS_LEVEL2;
      changed=true;
    }
    if(cellGlow){
      cellGlow=false;
      const tCGlow=document.getElementById('tCGlow');
      if(tCGlow)tCGlow.checked=false;
      changed=true;
    }
    if(typeof wire!=='undefined'&&wire&&wire.visible){
      wire.visible=false;
      const tWire=document.getElementById('tWire');
      if(tWire)tWire.checked=false;
      changed=true;
    }
    if(speed>30){
      speed=30;
      const rSpd=document.getElementById('rSpd');
      const vSpd=document.getElementById('vSpd');
      if(rSpd)rSpd.value='30';
      if(vSpd)vSpd.textContent='30 gen/s';
      changed=true;
    }
  }

  if(burstCount>=3&&meteorMode){
    profile='L3';
    meteorMode=false;
    const tMeteor=document.getElementById('tMeteor');
    if(tMeteor)tMeteor.checked=false;
    changed=true;
  }

  if(changed){
    scheduleNextMeteor();
    pendingTexUpdate=true;
    save();
    addCrashLog('context-loss-safety-profile','warn',{
      profile,
      burstCount,
      maxActiveMeteors,
      meteorInterval:Number(meteorInterval.toFixed(2)),
      meteorMode,
      cellGlow,
      wireVisible:(typeof wire!=='undefined'&&wire)?wire.visible:null,
      renderIntervalMeteorMs:Number(renderIntervalMeteor.toFixed(2)),
      texUpdateIntervalMs:Number(texUpdateInterval.toFixed(2))
    });
  }
}
applyRendererResolution();
renderer.setClearColor(0x0a0a0f);
document.body.appendChild(renderer.domElement);
renderer.domElement.style.cssText='position:fixed;top:0;left:0;z-index:0;background:#0a0a0f';
renderer.domElement.addEventListener('webglcontextcreationerror',e=>{
  addCrashLog('webgl-context-creation-error','error',{
    statusMessage:(e&&typeof e.statusMessage==='string'&&e.statusMessage)?e.statusMessage:'(empty)'
  });
});
let glContextLost=false;
let wasRunningBeforeContextLost=false;
let pageVisible=!document.hidden;
let rafId=0;
let disposed=false;
let pendingTexUpdate=false;
let resumeAfterRestoreAt=0;
const WIPE_VISUAL_INTERVAL=1000/30;
const OVERLAY_LAYOUT_INTERVAL=1000/30;
let lastWipeVisualUpdate=0;
let lastOverlayLayout=0;
let crashLogEntries=[];
let crashLogStorageEnabled=true;

function isLocalStorageSecurityError(err){
  return !!(err && (err.name==='SecurityError' || String(err).toLowerCase().includes('localstorage')));
}

function crashLogSnapshot(){
  const meteorCount=(typeof activeMeteors!=='undefined'&&activeMeteors)?activeMeteors.length:0;
  const overlayCount=(typeof impactSlots!=='undefined'&&impactSlots)?impactSlots.filter(s=>s).length:0;
  const safePR=(typeof maxPixelRatio==='number')?Number(maxPixelRatio.toFixed(3)):null;
  return{
    gen,pop,running,
    glContextLost,
    meteorCount,overlayCount,
    maxPixelRatio:safePR,
    devicePixelRatio:Number(devicePixelRatio.toFixed(3)),
    viewport:{w:innerWidth,h:innerHeight}
  };
}

function persistCrashLog(){
  if(!crashLogStorageEnabled)return;
  try{
    const payload={updatedAt:new Date().toISOString(),entries:crashLogEntries};
    localStorage.setItem(CRASH_LOG_STORAGE_KEY,JSON.stringify(payload));
  }catch(err){
    if(isLocalStorageSecurityError(err)){
      crashLogStorageEnabled=false;
      return;
    }
    console.warn('[CrashLog] persist failed',err);
  }
}

function addCrashLog(kind,level='info',details){
  const entry={
    ts:new Date().toISOString(),
    tMs:Math.round(performance.now()),
    kind,
    level,
    snapshot:crashLogSnapshot()
  };
  if(details!==undefined)entry.details=details;
  crashLogEntries.push(entry);
  if(crashLogEntries.length>CRASH_LOG_MAX_ENTRIES){
    crashLogEntries.splice(0,crashLogEntries.length-CRASH_LOG_MAX_ENTRIES);
  }
  persistCrashLog();
}

function loadCrashLog(){
  if(!crashLogStorageEnabled){
    crashLogEntries=[];
    return;
  }
  try{
    const raw=localStorage.getItem(CRASH_LOG_STORAGE_KEY);
    if(!raw)return;
    const parsed=JSON.parse(raw);
    if(parsed&&Array.isArray(parsed.entries)){
      crashLogEntries=parsed.entries.slice(-CRASH_LOG_MAX_ENTRIES);
    }
  }catch(err){
    crashLogEntries=[];
    if(isLocalStorageSecurityError(err)){
      crashLogStorageEnabled=false;
      return;
    }
    console.warn('[CrashLog] load failed',err);
  }
}

function exportCrashLog(){
  try{
    const payload={
      exportedAt:new Date().toISOString(),
      userAgent:navigator.userAgent,
      location:location.href,
      entries:crashLogEntries
    };
    const blob=new Blob([JSON.stringify(payload,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    const stamp=new Date().toISOString().replace(/[:.]/g,'-');
    a.href=url;
    a.download='conway-sphere-crash-log-'+stamp+'.json';
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url),1500);
    addCrashLog('crash-log-exported','info',{entries:crashLogEntries.length});
  }catch(err){
    console.warn('[CrashLog] export failed',err);
  }
}

function clearCrashLog(){
  crashLogEntries=[];
  if(crashLogStorageEnabled){
    try{localStorage.removeItem(CRASH_LOG_STORAGE_KEY)}catch(err){
      if(isLocalStorageSecurityError(err))crashLogStorageEnabled=false;
    }
  }
  addCrashLog('crash-log-cleared','warn');
}

let gpuRecoveryNoticeEl=null;
function ensureGpuRecoveryNotice(){
  if(gpuRecoveryNoticeEl)return gpuRecoveryNoticeEl;
  const box=document.createElement('div');
  box.id='gpuRecoveryNotice';
  box.style.cssText='position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:400;max-width:min(640px,92vw);padding:18px 20px;border:1px solid rgba(255,120,120,0.55);border-radius:10px;background:rgba(10,10,18,0.92);backdrop-filter:blur(10px);box-shadow:0 18px 48px rgba(0,0,0,0.6);color:#e8eef7;font-family:Rajdhani,sans-serif;display:none';
  box.innerHTML=
    '<div style="font-family:Orbitron,sans-serif;font-size:13px;letter-spacing:1.2px;color:#ff9da8;margin-bottom:8px">GPU CONTEXT LOST</div>'+
    '<div id="gpuRecoveryNoticeMsg" style="font-size:18px;line-height:1.35;margin-bottom:12px"></div>'+
    '<div style="display:flex;gap:10px;flex-wrap:wrap">'+
      '<button id="gpuRecoveryReloadBtn" class="btn p" style="min-width:160px">Reload Conway Scene</button>'+
      '<button id="gpuRecoveryDismissBtn" class="btn" style="min-width:120px">Dismiss</button>'+
    '</div>'+
    '<div style="margin-top:10px;font-size:14px;color:#9ab0c8">If reload does not help: restart browser (Chrome: chrome://restart) to reset the GPU process.</div>';
  document.body.appendChild(box);
  const reloadBtn=box.querySelector('#gpuRecoveryReloadBtn');
  const dismissBtn=box.querySelector('#gpuRecoveryDismissBtn');
  if(reloadBtn)reloadBtn.onclick=()=>location.reload();
  if(dismissBtn)dismissBtn.onclick=()=>{box.style.display='none'};
  gpuRecoveryNoticeEl=box;
  return box;
}

function showGpuRecoveryNotice(detail){
  const box=ensureGpuRecoveryNotice();
  const msgEl=box.querySelector('#gpuRecoveryNoticeMsg');
  if(msgEl){
    msgEl.textContent='WebGL/GPU rendering stopped. '+(detail||'Simulation was switched to safe mode.');
  }
  box.style.display='block';
}

function hideGpuRecoveryNotice(){
  if(gpuRecoveryNoticeEl)gpuRecoveryNoticeEl.style.display='none';
}

// Mystical skull cursor for wipe mode (canvas-rendered with arcane glow)
const _skullCvs=document.createElement('canvas');_skullCvs.width=40;_skullCvs.height=40;
const _skullCtx=_skullCvs.getContext('2d');
_skullCtx.textAlign='center';_skullCtx.textBaseline='middle';
// Outer mystical aura
_skullCtx.shadowColor='rgba(160,0,255,0.9)';_skullCtx.shadowBlur=12;
_skullCtx.font='26px serif';
_skullCtx.fillStyle='rgba(200,160,255,0.4)';_skullCtx.fillText('\u2620',20,19);
// Inner skull with hot glow
_skullCtx.shadowColor='rgba(255,50,200,0.8)';_skullCtx.shadowBlur=6;
_skullCtx.fillStyle='rgba(240,220,255,0.95)';_skullCtx.fillText('\u2620',20,19);
// Final crisp pass
_skullCtx.shadowBlur=0;_skullCtx.fillStyle='rgba(255,245,255,0.85)';_skullCtx.fillText('\u2620',20,19);
const wipeCursor='url('+_skullCvs.toDataURL()+') 20 20, crosshair';

// Dynamic centering: offset projection so sphere is centered in visible area
let _rw=0,_rh=0;
function updateCameraCenter(){
  // Sync renderer size if viewport changed (handles deferred layout/scrollbar shifts)
  const w=innerWidth,h=innerHeight;
  if(w!==_rw||h!==_rh){_rw=w;_rh=h;applyRendererResolution()}
  camera.aspect=w/h;
  camera.updateProjectionMatrix();

  const topbar=document.getElementById('topbar');
  const panel=document.getElementById('panel');
  const overlay=document.getElementById('impactOverlay');
  const rules=document.getElementById('golRules');
  const topInset=topbar?topbar.getBoundingClientRect().height:0;
  let leftBlock=0,rightBlock=0,bottomInset=0;

  if(panel){
    const pr=panel.getBoundingClientRect();
    if(innerWidth>768){
      leftBlock=Math.max(0,pr.right+12);
    }else{
      const panelFromBottom=Math.max(0,innerHeight-pr.top);
      bottomInset=Math.max(0,Math.min(innerHeight*0.5,panelFromBottom));
    }
  }

  if(overlay&&overlay.offsetParent!==null){
    const or=overlay.getBoundingClientRect();
    if(or.width>0&&or.height>0){
      rightBlock=Math.max(rightBlock,Math.max(0,innerWidth-or.left)+12);
    }
  }
  if(rules&&rules.offsetParent!==null){
    const rr=rules.getBoundingClientRect();
    const rs=getComputedStyle(rules);
    const isVisible=rs.visibility!=='hidden'&&parseFloat(rs.opacity||'0')>0.01;
    if(isVisible&&rr.width>0&&rr.height>0){
      rightBlock=Math.max(rightBlock,Math.max(0,innerWidth-rr.left)+12);
    }
  }

  // Keep sphere centered until side UI actually intrudes into the center region.
  const halfW=innerWidth*0.5;
  const leftInset=Math.max(0,leftBlock-halfW);
  const rightInset=Math.max(0,rightBlock-halfW);

  const usableW=Math.max(1,innerWidth-leftInset-rightInset);
  const usableH=Math.max(1,innerHeight-topInset-bottomInset);
  const centerX=leftInset+usableW*0.5;
  const centerY=topInset+usableH*0.5;
  const targetNdcX=(centerX/innerWidth)*2-1;
  const targetNdcY=1-(centerY/innerHeight)*2;

  camera.projectionMatrix.elements[8]=-targetNdcX;
  camera.projectionMatrix.elements[9]=-targetNdcY;
  camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
}

let zoom=4;

// Main texture canvas (upscaled for pole distortion correction)
const tc=document.createElement('canvas');tc.width=TW;tc.height=TH;
const tx=tc.getContext('2d');
const texImg=tx.createImageData(TW,TH);
const texImgData=texImg.data;

// Glow source + destination canvases
const glowSrc=document.createElement('canvas');glowSrc.width=W;glowSrc.height=H;
const gsx=glowSrc.getContext('2d');
const glowDst=document.createElement('canvas');glowDst.width=W;glowDst.height=H;
const gdx=glowDst.getContext('2d');
const glowImg=gsx.createImageData(W,H);
const glowImgData=glowImg.data;

const lifeTex=new THREE.CanvasTexture(tc);
lifeTex.wrapS=THREE.RepeatWrapping;lifeTex.wrapT=THREE.ClampToEdgeWrapping;
lifeTex.minFilter=THREE.LinearFilter;lifeTex.magFilter=THREE.LinearFilter;lifeTex.generateMipmaps=false;

const sphGeo=new THREE.SphereGeometry(1,64,32);

const sphMat=new THREE.MeshStandardMaterial({map:lifeTex,emissiveMap:lifeTex,emissive:new THREE.Color(1,1,1),emissiveIntensity:1.0,roughness:.55,metalness:.15,transparent:true,opacity:.84,depthWrite:false});
const DAY_NIGHT_DAY_GAIN=0.42;
const DAY_NIGHT_NIGHT_GAIN=0.34;
const DAY_LIGHT_VIEW_DIR=new THREE.Vector3(0.62,0.54,0.57).normalize(); // top-right/front in view space
let sphMatShaderRef=null;
sphMat.onBeforeCompile=(shader)=>{
  shader.uniforms.uDayNightStrength={value:dayNightStrength};
  shader.uniforms.uDayLightDir={value:DAY_LIGHT_VIEW_DIR.clone()};
  shader.uniforms.uDayGain={value:DAY_NIGHT_DAY_GAIN};
  shader.uniforms.uNightGain={value:DAY_NIGHT_NIGHT_GAIN};
  shader.fragmentShader=shader.fragmentShader.replace(
    'varying vec3 vViewPosition;',
    'varying vec3 vViewPosition;\nuniform float uDayNightStrength;\nuniform vec3 uDayLightDir;\nuniform float uDayGain;\nuniform float uNightGain;'
  );
  shader.fragmentShader=shader.fragmentShader.replace(
    'gl_FragColor = vec4( outgoingLight, diffuseColor.a );',
    'vec3 _dnColor=outgoingLight;\nfloat _dnH=dot(normalize(normal),normalize(uDayLightDir));\nfloat _dnDay=max(_dnH,0.0)*uDayGain*uDayNightStrength;\nfloat _dnNight=max(-_dnH,0.0)*uNightGain*uDayNightStrength;\n_dnColor=_dnColor*(1.0-_dnNight)+(vec3(1.0)-_dnColor)*_dnDay;\ngl_FragColor = vec4( _dnColor, diffuseColor.a );'
  );
  sphMatShaderRef=shader;
};
function syncDayNightUniform(){
  if(sphMatShaderRef&&sphMatShaderRef.uniforms&&sphMatShaderRef.uniforms.uDayNightStrength){
    sphMatShaderRef.uniforms.uDayNightStrength.value=dayNightStrength;
  }
}
sphMat.needsUpdate=true;
const sph=new THREE.Mesh(sphGeo,sphMat);
scene.add(sph);

// Back-face sphere: BasicMaterial (no scene lighting), additive blend glows through front
const sphBackMat=new THREE.MeshBasicMaterial({map:lifeTex,transparent:true,opacity:.15,side:THREE.BackSide,depthWrite:false,blending:THREE.AdditiveBlending});
const sphBack=new THREE.Mesh(sphGeo,sphBackMat);
scene.add(sphBack);
sph.renderOrder=1;
sphBack.renderOrder=2;

// Wireframe grid (no diagonals): only latitude + longitude lines
{var _wSegsW=48,_wSegsH=24,_wR=1.003;
const verts=[],norms=[];
// Build vertex grid [y][x]
const grid2=[];
for(let iy=0;iy<=_wSegsH;iy++){
  const row=[];
  const v=iy/_wSegsH, th=v*Math.PI;
  const sinTh=Math.sin(th), cosTh=Math.cos(th);
  for(let ix=0;ix<=_wSegsW;ix++){
    const u=ix/_wSegsW, ph=u*Math.PI*2;
    const x=-_wR*Math.cos(ph)*sinTh, y=_wR*cosTh, z=_wR*Math.sin(ph)*sinTh;
    row.push([x,y,z]);
  }
  grid2.push(row);
}
const pos=[],nor=[];
function addSeg(a,b){
  pos.push(a[0],a[1],a[2],b[0],b[1],b[2]);
  const na=[a[0]/_wR,a[1]/_wR,a[2]/_wR], nb=[b[0]/_wR,b[1]/_wR,b[2]/_wR];
  nor.push(na[0],na[1],na[2],nb[0],nb[1],nb[2]);
}
// Latitude lines (horizontal rings)
for(let iy=0;iy<=_wSegsH;iy++)
  for(let ix=0;ix<_wSegsW;ix++) addSeg(grid2[iy][ix],grid2[iy][ix+1]);
// Longitude lines (vertical arcs)
for(let ix=0;ix<=_wSegsW;ix++)
  for(let iy=0;iy<_wSegsH;iy++) addSeg(grid2[iy][ix],grid2[iy+1][ix]);
var _wGeo=new THREE.BufferGeometry();
_wGeo.setAttribute('position',new THREE.Float32BufferAttribute(pos,3));
_wGeo.setAttribute('normal',new THREE.Float32BufferAttribute(nor,3));
}
const wireShaderMat=new THREE.ShaderMaterial({
  uniforms:{wColor:{value:new THREE.Color(0x00ffc8)},wOpacity:{value:0.30}},
  vertexShader:`
    varying float vFade;
    void main(){
      vec3 wNorm=normalize(normalMatrix*normal);
      vec3 vDir=normalize(cameraPosition-(modelMatrix*vec4(position,1.0)).xyz);
      vFade=max(0.0,dot(wNorm,vDir));
      gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);
    }`,
  fragmentShader:`
    uniform vec3 wColor;
    uniform float wOpacity;
    varying float vFade;
    void main(){
      float a=wOpacity*mix(0.28,1.0,pow(vFade,1.2));
      gl_FragColor=vec4(wColor,a);
    }`,
  transparent:true,depthWrite:false
});
const wire=new THREE.LineSegments(_wGeo,wireShaderMat);
wire.visible=true;scene.add(wire);
wire.renderOrder=3;

// Lights
scene.add(new THREE.AmbientLight(0x222233,.4));
const l1=new THREE.PointLight(0x00ffc8,.7,12);l1.position.set(3,2,3);scene.add(l1);
const l2=new THREE.PointLight(0xff00aa,.4,12);l2.position.set(-3,-1,2);scene.add(l2);
const l3=new THREE.PointLight(0x4444ff,.3,12);l3.position.set(0,3,-2);scene.add(l3);

// Background stars
const stGeo=new THREE.BufferGeometry();const stPos=new Float32Array(4500);for(let i=0;i<4500;i++)stPos[i]=(Math.random()-.5)*60;
stGeo.setAttribute('position',new THREE.BufferAttribute(stPos,3));
const stMat=new THREE.PointsMaterial({color:0x334455,size:.04});
const stPts=new THREE.Points(stGeo,stMat);
scene.add(stPts);

// ========================================
// ROTATION & ZOOM
// ========================================
let dragging=false,pmx=0,pmy=0;
let axisDrag=false,axmx=0,axmy=0;
let rotQ=new THREE.Quaternion();
let autoRot=true,rotSpd=.1;
let rotAxis=new THREE.Vector3(0,1,.3).normalize();
let rotTarget=new THREE.Vector3(0,1,0).normalize();
let axisTimer=0;

renderer.domElement.addEventListener('contextmenu',e=>e.preventDefault());
renderer.domElement.addEventListener('pointerdown',e=>{
  if(e.button===0){
    if(wipeMode){wiping=true;doWipe(e.clientX,e.clientY)}
    else{dragging=true;pmx=e.clientX;pmy=e.clientY}
  } else if(e.button===2){
    axisDrag=true;axmx=e.clientX;axmy=e.clientY;
  }
});
window.addEventListener('pointermove',e=>{
  if(wiping){doWipe(e.clientX,e.clientY);return}
  if(axisDrag){
    const dx=(e.clientX-axmx)*.004,dy=(e.clientY-axmy)*.004;
    const q=new THREE.Quaternion();
    q.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1),dx));
    q.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0),dy));
    rotAxis.applyQuaternion(q).normalize();
    rotTarget.copy(rotAxis);
    axmx=e.clientX;axmy=e.clientY;
    return;
  }
  if(!dragging)return;
  const dx=(e.clientX-pmx)*.006,dy=(e.clientY-pmy)*.006;
  rotQ.premultiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0),dx));
  rotQ.premultiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0),dy));
  pmx=e.clientX;pmy=e.clientY;
});
function commitWipeVisuals(now){
  cntPop();updTex();updStats();
  pendingTexUpdate=false;
  lastWipeVisualUpdate=now;
}

window.addEventListener('pointerup',()=>{
  dragging=false;axisDrag=false;
  if(wiping)commitWipeVisuals(performance.now());
  wiping=false;
});

// Wipe: erase cells in radius at raycasted sphere position
function doWipe(cx,cy){
  rcMouse.x=(cx/innerWidth)*2-1;
  rcMouse.y=-(cy/innerHeight)*2+1;
  raycaster.setFromCamera(rcMouse,camera);
  const hits=raycaster.intersectObject(sph);
  if(hits.length>0&&hits[0].uv){
    const g=uvToGrid(hits[0].uv);
    const r2=wipeRadius*wipeRadius;
    for(let dy=-wipeRadius;dy<=wipeRadius;dy++){
      for(let dx=-wipeRadius;dx<=wipeRadius;dx++){
        if(dx*dx+dy*dy<=r2){
          const i=ix(g.x+dx,g.y+dy);
          grid[i]=0;age[i]=Math.min(age[i],-1);meteorAge[i]=0;meteorFlashMark[i]=0;
        }
      }
    }
    pendingTexUpdate=true;
    const now=performance.now();
    if(now-lastWipeVisualUpdate>=WIPE_VISUAL_INTERVAL)commitWipeVisuals(now);
  }
}

let pinchD=0;
renderer.domElement.addEventListener('touchstart',e=>{if(e.touches.length===2)pinchD=Math.hypot(e.touches[0].clientX-e.touches[1].clientX,e.touches[0].clientY-e.touches[1].clientY)},{passive:true});
renderer.domElement.addEventListener('touchmove',e=>{if(e.touches.length===2){const d=Math.hypot(e.touches[0].clientX-e.touches[1].clientX,e.touches[0].clientY-e.touches[1].clientY);zoom+=(pinchD-d)*.01;zoom=Math.max(1.5,Math.min(8,zoom));pinchD=d;$('rZoom').value=zoom*10;$('vZoom').textContent=zoom.toFixed(1)}},{passive:true});
renderer.domElement.addEventListener('wheel',e=>{zoom+=e.deltaY*.002;zoom=Math.max(1.5,Math.min(8,zoom));$('rZoom').value=zoom*10;$('vZoom').textContent=zoom.toFixed(1);save()},{passive:true});

// ========================================
// RIGHT-CLICK CONTEXT MENU
// ========================================
const raycaster=new THREE.Raycaster();
const rcMouse=new THREE.Vector2();
let ctxTarget={x:0,y:0};

function showCtxMenu(ex,ey){
  const m=document.getElementById('ctxMenu');
  let html='';
  PAT_MENU.forEach(g=>{
    html+='<div class="ctx-cat">'+g.cat+'</div>';
    g.items.forEach(([k,label])=>{
      const sym=PAT_BRAILLE[k]||'';
      html+='<div class="ctx-item" data-pat="'+k+'">'+(sym?'<span class="ctx-sym">'+sym+'</span> ':'')+label+'</div>';
    });
  });
  m.innerHTML=html;
  m.style.display='block';
  const mw=m.offsetWidth,mh=m.offsetHeight;
  m.style.left=Math.min(ex,innerWidth-mw-8)+'px';
  m.style.top=Math.min(ey,innerHeight-mh-8)+'px';
  m.querySelectorAll('.ctx-item').forEach(el=>{
    el.onclick=()=>{
      const k=el.dataset.pat;
      placeRandomOriented(k,ctxTarget.x,ctxTarget.y);
      cntPop();updTex();updStats();
      hideCtxMenu();
    };
  });
}
function hideCtxMenu(){document.getElementById('ctxMenu').style.display='none'}

function uvToGrid(uv){
  return{
    x:Math.floor(uv.x*W)%W,
    y:Math.floor((1-uv.y)*H)%H
  };
}

renderer.domElement.addEventListener('contextmenu',e=>{
  e.preventDefault();
  rcMouse.x=(e.clientX/innerWidth)*2-1;
  rcMouse.y=-(e.clientY/innerHeight)*2+1;
  raycaster.setFromCamera(rcMouse,camera);
  const hits=raycaster.intersectObject(sph);
  if(hits.length>0&&hits[0].uv){
    const g=uvToGrid(hits[0].uv);
    ctxTarget.x=g.x;ctxTarget.y=g.y;
    showCtxMenu(e.clientX,e.clientY);
  }
});
window.addEventListener('pointerdown',e=>{
  if(!document.getElementById('ctxMenu').contains(e.target))hideCtxMenu();
});
window.addEventListener('keydown',e=>{if(e.key==='Escape')hideCtxMenu()});

// ========================================
// METEOR SYSTEM
// ========================================
const METEOR_PATS=['glider','blinker','toad','beacon','clock','lwss','rpent','acorn','thunderbird','piHept','bhept','boat','ship','block','beehive','pulsar','figureEight','totalAperiodic'];
const NUKE_PAT_KEY='nuke';
const SUPER_NUKE_PAT_KEY='superNuke';
const NUKE_SPAWN_CHANCE=0.01; // Independent per meteor spawn (~1% long-run frequency)
const SUPER_NUKE_SPAWN_CHANCE=0.005; // Independent per meteor spawn (~0.5% long-run frequency)
const NUKE_WIPE_RADIUS=24;
const SUPER_NUKE_KILL_FRACTION=0.90;
const SUPER_NUKE_SIZE_SCALE=2.0;
const SUPER_NUKE_SPEED_SCALE=0.5;
const METEOR_ENABLE_POINT_LIGHT=false; // Keep sphere cell colours independent from Meteor toggle.
const NUKE_COLOR_RGB=[255,56,0];
const NUKE_COLOR_CSS='rgb('+NUKE_COLOR_RGB[0]+','+NUKE_COLOR_RGB[1]+','+NUKE_COLOR_RGB[2]+')';
const NUKE_COLOR_THREE=new THREE.Color(NUKE_COLOR_RGB[0]/255,NUKE_COLOR_RGB[1]/255,NUKE_COLOR_RGB[2]/255);
const SUPER_NUKE_COLOR_RGB=[255,0,196];
const SUPER_NUKE_COLOR_CSS='rgb('+SUPER_NUKE_COLOR_RGB[0]+','+SUPER_NUKE_COLOR_RGB[1]+','+SUPER_NUKE_COLOR_RGB[2]+')';
const SUPER_NUKE_COLOR_THREE=new THREE.Color(SUPER_NUKE_COLOR_RGB[0]/255,SUPER_NUKE_COLOR_RGB[1]/255,SUPER_NUKE_COLOR_RGB[2]/255);

function isSpecialNukeKey(patKey){
  return patKey===NUKE_PAT_KEY||patKey===SUPER_NUKE_PAT_KEY;
}
function isSpecialIconKey(patKey){
  return isSpecialNukeKey(patKey)||isSuperclassKey(patKey);
}

function getMeteorColorData(patKey){
  if(isSuperclassKey(patKey)){
    return{
      r:SUPERCLASS_COLOR_RGB[0],g:SUPERCLASS_COLOR_RGB[1],b:SUPERCLASS_COLOR_RGB[2],
      three:SUPERCLASS_COLOR_THREE,
      css:SUPERCLASS_COLOR_CSS
    };
  }
  if(patKey===SUPER_NUKE_PAT_KEY){
    return{
      r:SUPER_NUKE_COLOR_RGB[0],g:SUPER_NUKE_COLOR_RGB[1],b:SUPER_NUKE_COLOR_RGB[2],
      three:SUPER_NUKE_COLOR_THREE,
      css:SUPER_NUKE_COLOR_CSS
    };
  }
  if(patKey===NUKE_PAT_KEY){
    return{
      r:NUKE_COLOR_RGB[0],g:NUKE_COLOR_RGB[1],b:NUKE_COLOR_RGB[2],
      three:NUKE_COLOR_THREE,
      css:NUKE_COLOR_CSS
    };
  }
  return getImpactColorData();
}

function applyNukeWipe(cx,cy,radius){
  const r2=radius*radius;
  for(let dy=-radius;dy<=radius;dy++){
    const y2=dy*dy;
    for(let dx=-radius;dx<=radius;dx++){
      if(dx*dx+y2>r2)continue;
      const i=ix(cx+dx,cy+dy);
      grid[i]=0;
      age[i]=Math.min(age[i],-1);
      meteorAge[i]=0;
      meteorFlashMark[i]=0;
    }
  }
}

function applySuperNukeRadialWipe(worldImpactPt,killFraction){
  const f=clamp(killFraction,0,1);
  if(f<=0)return{destroyed:0,capAngleDeg:0};
  const impactLocal=worldImpactPt.clone().normalize().applyQuaternion(rotQ.clone().invert());
  // Spherical cap area fraction f = (1 - cos(theta)) / 2  =>  cos(theta) = 1 - 2f
  const cosRadius=clamp(1-2*f,-1,1);
  const capAngleDeg=Math.acos(cosRadius)*180/Math.PI;
  let destroyed=0;
  for(let y=0;y<H;y++){
    const sinTh=rowSinTh[y], cosTh=rowCosTh[y];
    for(let x=0;x<W;x++){
      const nx=-colCosPh[x]*sinTh, ny=cosTh, nz=colSinPh[x]*sinTh;
      const dot=nx*impactLocal.x+ny*impactLocal.y+nz*impactLocal.z;
      if(dot<cosRadius)continue;
      const i=y*W+x;
      if(grid[i])destroyed++;
      grid[i]=0;
      age[i]=Math.min(age[i],-1);
      meteorAge[i]=0;
      meteorFlashMark[i]=0;
    }
  }
  return{destroyed,capAngleDeg:Number(capAngleDeg.toFixed(2))};
}

// Glow sprite texture for meteor head (created once, shared)
const meteorGlowCvs=document.createElement('canvas');meteorGlowCvs.width=meteorGlowCvs.height=64;
const _mgx=meteorGlowCvs.getContext('2d');
const _mgg=_mgx.createRadialGradient(32,32,0,32,32,32);
_mgg.addColorStop(0,'rgba(255,255,255,1)');_mgg.addColorStop(0.1,'rgba(230,240,255,0.9)');
_mgg.addColorStop(0.3,'rgba(120,170,255,0.35)');_mgg.addColorStop(0.6,'rgba(50,100,255,0.08)');
_mgg.addColorStop(1,'rgba(0,0,0,0)');
_mgx.fillStyle=_mgg;_mgx.fillRect(0,0,64,64);
const meteorGlowTex=new THREE.CanvasTexture(meteorGlowCvs);
const meteorHeadGeo=new THREE.SphereGeometry(0.008,16,12);
const METEOR_TRAIL_LEN=72;
const _whiteColor=new THREE.Color(1,1,1);

function getMeteorCoreColor(threeColor){
  // Blend toward white to create a smoother transition from white core to colored glow.
  return threeColor.clone().lerp(_whiteColor,0.42);
}

function logRendererDebugInfo(){
  try{
    const gl=renderer.getContext();
    if(!gl)return;
    const ext=gl.getExtension('WEBGL_debug_renderer_info');
    const vendor=ext?gl.getParameter(ext.UNMASKED_VENDOR_WEBGL):'unknown';
    const rendererName=ext?gl.getParameter(ext.UNMASKED_RENDERER_WEBGL):'unknown';
    const api=(typeof WebGL2RenderingContext!=='undefined'&&gl instanceof WebGL2RenderingContext)?'WebGL2':'WebGL1';
    console.info('[WebGL] '+api+' vendor='+vendor+' renderer='+rendererName);
    addCrashLog('renderer-info','info',{api,vendor,renderer:rendererName});
  }catch(err){
    console.warn('[WebGL] renderer info unavailable',err);
    addCrashLog('renderer-info-failed','warn',{message:String(err&&err.message||err)});
  }
}

function markObjectMaterialNeedsUpdate(obj){
  const m=obj&&obj.material;
  if(!m)return;
  if(Array.isArray(m)){
    for(let i=0;i<m.length;i++)if(m[i])m[i].needsUpdate=true;
  }else{
    m.needsUpdate=true;
  }
}

function markAllMaterialsNeedsUpdate(){
  markObjectMaterialNeedsUpdate(sph);
  markObjectMaterialNeedsUpdate(sphBack);
  markObjectMaterialNeedsUpdate(wire);
  markObjectMaterialNeedsUpdate(stPts);
  for(const m of activeMeteors){
    markObjectMaterialNeedsUpdate(m.head);
    markObjectMaterialNeedsUpdate(m.trail);
    if(m&&m.trailPosAttr)m.trailPosAttr.needsUpdate=true;
  }
  for(const m of meteorPool){
    markObjectMaterialNeedsUpdate(m.head);
    markObjectMaterialNeedsUpdate(m.trail);
    if(m&&m.trailPosAttr)m.trailPosAttr.needsUpdate=true;
  }
}

function resetVolatileVisualStateOnContextLost(){
  for(let i=activeMeteors.length-1;i>=0;i--){
    releaseMeteorVisual(activeMeteors[i]);
  }
  activeMeteors.length=0;
  impactRings.length=0;
}

renderer.domElement.addEventListener('webglcontextlost',e=>{
  e.preventDefault();
  contextLossCount++;
  const burstCount=registerContextLossBurst();
  lastContextLossBurst=burstCount;
  applyContextLossSafetyProfile(burstCount);
  const msg=(e&&typeof e.statusMessage==='string'&&e.statusMessage)?e.statusMessage:'(empty)';
  console.warn(
    'WebGL context lost #'+contextLossCount+
    ' (burst '+burstCount+'/120s), max pixel ratio '+maxPixelRatio.toFixed(2)+
    ', statusMessage='+msg
  );
  addCrashLog('webgl-context-lost','error',{statusMessage:msg,burstCount,contextLossCount,maxPixelRatio:Number(maxPixelRatio.toFixed(3))});
  glContextLost=true;
  renderer.domElement.style.opacity='0';
  if(contextRecoveryTimer)clearTimeout(contextRecoveryTimer);
  contextRecoveryTimer=setTimeout(()=>{
    contextRecoveryTimer=0;
    if(glContextLost){
      showGpuRecoveryNotice('Reload this slide to recover the WebGL context.');
      addCrashLog('webgl-context-stuck','error',{contextLossCount,burstCount,maxPixelRatio:Number(maxPixelRatio.toFixed(3))});
    }
  },1800);
  wasRunningBeforeContextLost=running;
  running=false;
  resetVolatileVisualStateOnContextLost();
  updPlayBtn();
});
renderer.domElement.addEventListener('webglcontextrestored',()=>{
  glContextLost=false;
  renderer.domElement.style.opacity='1';
  if(contextRecoveryTimer){clearTimeout(contextRecoveryTimer);contextRecoveryTimer=0;}
  hideGpuRecoveryNotice();
  applyRendererResolution();
  if(lastContextLossBurst>0)applyContextLossSafetyProfile(lastContextLossBurst);
  lifeTex.needsUpdate=true;
  meteorGlowTex.needsUpdate=true;
  pendingTexUpdate=true;
  markAllMaterialsNeedsUpdate();
  resumeAfterRestoreAt=performance.now()+350;
  if(renderer.renderLists&&renderer.renderLists.dispose)renderer.renderLists.dispose();
  renderer.resetState();
  addCrashLog('webgl-context-restored','warn',{contextLossCount,maxPixelRatio:Number(maxPixelRatio.toFixed(3))});
  logRendererDebugInfo();
  if(wasRunningBeforeContextLost){
    running=true;
    updPlayBtn();
  }
});

function gridToSurface(gx,gy){
  const u=((gx+0.5)/W)%1, v=clamp((gy+0.5)/H,0,1);
  const theta=v*Math.PI;
  const phi=u*Math.PI*2;
  // Match Three.js SphereGeometry UV convention
  const pt=new THREE.Vector3(
    -Math.cos(phi)*Math.sin(theta),
    Math.cos(theta),
    Math.sin(phi)*Math.sin(theta)
  );
  pt.applyQuaternion(rotQ);
  return pt;
}

// Inverse: world-space point on sphere -> grid coordinates (matches Three.js UV mapping)
function surfaceToGrid(worldPt){
  const p=worldPt.clone().normalize().applyQuaternion(rotQ.clone().invert());
  const theta=Math.acos(Math.max(-1,Math.min(1,p.y)));
  const phi=Math.atan2(p.z,-p.x);
  const v=theta/Math.PI;
  let u=phi/(Math.PI*2);if(u<0)u+=1;
  return{x:Math.floor(u*W)%W,y:Math.min(H-1,Math.floor(v*H))};
}

function findEmptySpot(){
  let bestX=0,bestY=0,bestScore=Infinity;
  for(let t=0;t<15;t++){
    const tx=Math.floor(Math.random()*W),ty=Math.floor(Math.random()*H);
    let score=0;
    for(let dy=-8;dy<=8;dy++)for(let dx=-8;dx<=8;dx++){
      if(grid[ix(tx+dx,ty+dy)])score++;
    }
    if(score<bestScore){bestScore=score;bestX=tx;bestY=ty}
  }
  return{x:bestX,y:bestY};
}

function scheduleNextMeteor(){
  const minI=Math.max(0.25,meteorInterval*0.45);
  const maxI=Math.max(minI+0.2,meteorInterval*1.55);
  nextMeteorTime=minI+Math.random()*(maxI-minI);
}

function syncTrailRibbonColor(m,threeColor){
  if(m.trailMat&&m.trailMat.uniforms&&m.trailMat.uniforms.uColor){
    m.trailMat.uniforms.uColor.value.copy(threeColor);
  }
}

function updateTrailRibbon(m,headX,headY,headZ,visFactor,camX,camY,camZ){
  const len=m.trailLen;
  const tp=m.trailPositions;
  const vp=m.trailVerts;
  const offX=headX-m.pos.x,offY=headY-m.pos.y,offZ=headZ-m.pos.z;
  m.trail.position.set(offX,offY,offZ);
  const widthScale=m.trailWidthScale||1;
  const widthBase=0.052*(0.9+0.2*visFactor)*widthScale;
  let lastSx=1,lastSy=0,lastSz=0;

  for(let i=0;i<len;i++){
    const bi=i*3;
    const px=tp[bi],py=tp[bi+1],pz=tp[bi+2];

    let tx,ty,tz;
    if(i===0){
      tx=tp[0]-tp[3];ty=tp[1]-tp[4];tz=tp[2]-tp[5];
    }else if(i===len-1){
      const pi=(len-2)*3;
      tx=tp[pi]-tp[bi];ty=tp[pi+1]-tp[bi+1];tz=tp[pi+2]-tp[bi+2];
    }else{
      const pi=(i-1)*3,ni=(i+1)*3;
      tx=tp[pi]-tp[ni];ty=tp[pi+1]-tp[ni+1];tz=tp[pi+2]-tp[ni+2];
    }

    let tLen=Math.hypot(tx,ty,tz);
    if(tLen<1e-6){tx=0;ty=0;tz=1;tLen=1;}
    tx/=tLen;ty/=tLen;tz/=tLen;

    const wx=px+offX,wy=py+offY,wz=pz+offZ;
    let vx=camX-wx,vy=camY-wy,vz=camZ-wz;
    let vLen=Math.hypot(vx,vy,vz);
    if(vLen<1e-6){vx=0;vy=0;vz=1;vLen=1;}
    vx/=vLen;vy/=vLen;vz/=vLen;

    let sx=vy*tz-vz*ty;
    let sy=vz*tx-vx*tz;
    let sz=vx*ty-vy*tx;
    let sLen=Math.hypot(sx,sy,sz);
    if(sLen<1e-6){
      sx=lastSx;sy=lastSy;sz=lastSz;
    }else{
      sx/=sLen;sy/=sLen;sz/=sLen;
      lastSx=sx;lastSy=sy;lastSz=sz;
    }

    const f=i/(len-1);
    let w=widthBase*(0.18+0.82*Math.pow(1-f,0.58));
    if(i===0)w*=0.45; // protect bright head core from overbloom
    sx*=w;sy*=w;sz*=w;

    const vi=i*6;
    vp[vi]=px+sx;vp[vi+1]=py+sy;vp[vi+2]=pz+sz;
    vp[vi+3]=px-sx;vp[vi+4]=py-sy;vp[vi+5]=pz-sz;
  }

  m.trailPosAttr.needsUpdate=true;
  m.trailMat.uniforms.uOpacity.value=0.95*Math.max(0,Math.min(1,visFactor));
}

function syncActiveMeteorColors(){
  for(const m of activeMeteors){
    const c=getMeteorColorData(m.specialKey||null);
    m.glowMat.color.copy(c.three);
    if(m.coreMat)m.coreMat.color.copy(getMeteorCoreColor(c.three));
    if(m.light)m.light.color.copy(c.three);
    syncTrailRibbonColor(m,c.three);
  }
}

function setMeteorVisible(m,visible){
  m.head.visible=visible;
  m.trail.visible=visible;
  if(m.light)m.light.visible=visible;
}

function resetMeteorTrail(m,origin){
  const len=m.trailLen;
  const tp=m.trailPositions;
  const tv=m.trailVerts;
  for(let i=0;i<len;i++){
    const pi=i*3;
    tp[pi]=origin.x;tp[pi+1]=origin.y;tp[pi+2]=origin.z;
    const vi=i*6;
    tv[vi]=origin.x;tv[vi+1]=origin.y;tv[vi+2]=origin.z;
    tv[vi+3]=origin.x;tv[vi+4]=origin.y;tv[vi+5]=origin.z;
  }
  m.trailPosAttr.needsUpdate=true;
}

function createMeteorVisual(){
  const headMat=new THREE.MeshBasicMaterial({color:0xfcfdff,transparent:true,opacity:0.92,depthWrite:false});
  const head=new THREE.Mesh(meteorHeadGeo,headMat);
  head.renderOrder=8;
  scene.add(head);

  const tipMat=new THREE.SpriteMaterial({map:meteorGlowTex,color:0xffffff,transparent:true,opacity:0.92,depthWrite:false});
  const tip=new THREE.Sprite(tipMat);
  tip.scale.set(0.026,0.026,1);
  tip.renderOrder=9;
  head.add(tip);

  const coreMat=new THREE.SpriteMaterial({
    map:meteorGlowTex,
    color:0xffffff,
    transparent:true,
    opacity:0.78,
    depthWrite:false,
    blending:THREE.AdditiveBlending
  });
  const core=new THREE.Sprite(coreMat);
  core.scale.set(0.082,0.082,1);
  core.renderOrder=8;
  head.add(core);

  const glowMat=new THREE.SpriteMaterial({map:meteorGlowTex,color:0xffffff,transparent:true,opacity:0.76,depthWrite:false});
  const glow=new THREE.Sprite(glowMat);
  glow.scale.set(0.32,0.32,1);
  glow.renderOrder=7;
  head.add(glow);

  const trailLen=METEOR_TRAIL_LEN;
  const trailPositions=new Float32Array(trailLen*3);
  const trailVerts=new Float32Array(trailLen*6);
  const trailUVs=new Float32Array(trailLen*4);
  const trailIdx=new Uint16Array((trailLen-1)*6);
  for(let i=0;i<trailLen;i++){
    const ui=i*4;
    const v=i/(trailLen-1);
    trailUVs[ui]=0;trailUVs[ui+1]=v;
    trailUVs[ui+2]=1;trailUVs[ui+3]=v;
    if(i<trailLen-1){
      const ii=i*6,vi2=i*2;
      trailIdx[ii]=vi2;
      trailIdx[ii+1]=vi2+1;
      trailIdx[ii+2]=vi2+2;
      trailIdx[ii+3]=vi2+1;
      trailIdx[ii+4]=vi2+3;
      trailIdx[ii+5]=vi2+2;
    }
  }

  const trailGeo=new THREE.BufferGeometry();
  const trailPosAttr=new THREE.BufferAttribute(trailVerts,3);
  trailPosAttr.setUsage(THREE.DynamicDrawUsage);
  trailGeo.setAttribute('position',trailPosAttr);
  trailGeo.setAttribute('uv',new THREE.BufferAttribute(trailUVs,2));
  trailGeo.setIndex(new THREE.BufferAttribute(trailIdx,1));
  const trailMat=new THREE.ShaderMaterial({
    uniforms:{
      map:{value:meteorGlowTex},
      uColor:{value:new THREE.Color(1,1,1)},
      uOpacity:{value:0.95}
    },
    vertexShader:[
      'varying vec2 vUv;',
      'void main(){',
      '  vUv=uv;',
      '  gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);',
      '}'
    ].join('\n'),
    fragmentShader:[
      'uniform sampler2D map;',
      'uniform vec3 uColor;',
      'uniform float uOpacity;',
      'varying vec2 vUv;',
      'void main(){',
      '  vec4 tex=texture2D(map,vec2(vUv.x,0.5));',
      '  float side=max(0.0,1.0-abs(vUv.x*2.0-1.0));',
      '  float sideFade=pow(side,1.55);',
      '  float along=pow(max(0.0,1.0-vUv.y),1.22);',
      '  float alpha=tex.a*sideFade*along*uOpacity;',
      '  if(alpha<0.003) discard;',
      '  float core=pow(side,4.0)*pow(max(0.0,1.0-vUv.y),1.6);',
      '  vec3 col=mix(uColor,vec3(1.0),0.24*core);',
      '  gl_FragColor=vec4(col*tex.rgb,alpha);',
      '}'
    ].join('\n'),
    transparent:true,
    depthWrite:false,
    side:THREE.DoubleSide,
    blending:THREE.AdditiveBlending
  });
  const trail=new THREE.Mesh(trailGeo,trailMat);
  trail.renderOrder=4;
  trail.frustumCulled=false;
  scene.add(trail);

  let light=null;
  if(METEOR_ENABLE_POINT_LIGHT){
    light=new THREE.PointLight(0xffffff,2.0,6);
    scene.add(light);
  }

  const meteor={
    head,tip,tipMat,core,coreMat,trail,trailGeo,trailMat,trailPosAttr,trailVerts,glow,glowMat,trailPositions,trailLen,light,
    pos:new THREE.Vector3(),prevPos:new THREE.Vector3(),renderPos:new THREE.Vector3(),vel:new THREE.Vector3(),
    patKey:'',specialKey:null,isNuke:false,isSuperNuke:false,speedScale:1,sizeScale:1,trailWidthScale:1,age:0,inPool:false
  };
  setMeteorVisible(meteor,false);
  return meteor;
}

function acquireMeteorVisual(){
  const meteor=meteorPool.pop()||createMeteorVisual();
  meteor.inPool=false;
  setMeteorVisible(meteor,true);
  return meteor;
}

function releaseMeteorVisual(m){
  if(!m||m.inPool)return;
  m.inPool=true;
  m.age=0;
  m.patKey='';
  m.specialKey=null;
  m.isNuke=false;
  m.isSuperNuke=false;
  m.speedScale=1;
  m.sizeScale=1;
  m.trailWidthScale=1;
  setMeteorVisible(m,false);
  meteorPool.push(m);
  if(renderer.renderLists&&renderer.renderLists.dispose)renderer.renderLists.dispose();
}

function spawnMeteor(){
  if(activeMeteors.length>=maxActiveMeteors)return;
  const roll=Math.random();
  const patKey=roll<SUPER_NUKE_SPAWN_CHANCE
    ? SUPER_NUKE_PAT_KEY
    : roll<(SUPER_NUKE_SPAWN_CHANCE+NUKE_SPAWN_CHANCE)
      ? NUKE_PAT_KEY
      : METEOR_PATS[Math.floor(Math.random()*METEOR_PATS.length)];
  const isSuperNuke=patKey===SUPER_NUKE_PAT_KEY;
  const isNuke=patKey===NUKE_PAT_KEY;
  const isSuperclass=isSuperclassKey(patKey);
  const specialKey=(isSpecialNukeKey(patKey)||isSuperclass)?patKey:null;
  const imp=getMeteorColorData(specialKey);

  // Spawn bias:
  // - keep meteors mostly on the camera-visible hemisphere
  // - favor right side of screen (user preference: fewer left, more right)
  const camDir=camera.position.clone().normalize();
  let originDir=null;
  let bestDir=null;
  let bestScore=-Infinity;
  for(let tries=0;tries<32;tries++){
    const rTh=Math.acos(2*Math.random()-1),rPh=Math.random()*Math.PI*2;
    const candidate=new THREE.Vector3(Math.sin(rTh)*Math.cos(rPh),Math.cos(rTh),Math.sin(rTh)*Math.sin(rPh));
    const visDot=candidate.dot(camDir);
    if(visDot<0&&Math.random()<0.6)continue;

    const probeScreen=worldToScreen(candidate.clone().multiplyScalar(4.2));
    const xNormRaw=clamp(probeScreen.x/Math.max(1,innerWidth),0,1); // 0=left, 1=right
    // Screen orientation is mirrored for this scene setup: flip so "right" means visually right.
    const xNorm=1-xNormRaw;
    const rightWeight=0.18+0.82*Math.pow(xNorm,1.65);
    const score=rightWeight+Math.max(0,visDot)*0.25;
    if(score>bestScore){bestScore=score;bestDir=candidate}
    if(Math.random()<rightWeight){
      originDir=candidate;
      break;
    }
  }
  if(!originDir)originDir=bestDir||new THREE.Vector3(0,0,1);
  const originDist=3.5+Math.random()*2.0;
  const origin=originDir.clone().multiplyScalar(originDist);

  // Initial velocity: toward sphere center (gravity), small perpendicular deviation
  const toCenter=origin.clone().negate().normalize();
  const baseSpeed=Math.sqrt(2.5/originDist)*0.8; // below escape velocity -> always captured
  const dev=new THREE.Vector3(Math.random()-.5,Math.random()-.5,Math.random()-.5);
  dev.sub(toCenter.clone().multiplyScalar(dev.dot(toCenter))).normalize();
  const vel=toCenter.clone().multiplyScalar(baseSpeed).add(dev.multiplyScalar(baseSpeed*0.1));

  const meteor=acquireMeteorVisual();
  meteor.pos.copy(origin);
  meteor.prevPos.copy(origin);
  meteor.renderPos.copy(origin);
  meteor.vel.copy(vel);
  meteor.patKey=patKey;
  meteor.specialKey=specialKey;
  meteor.isNuke=isNuke;
  meteor.isSuperNuke=isSuperNuke;
  meteor.speedScale=isSuperNuke?SUPER_NUKE_SPEED_SCALE:1;
  meteor.sizeScale=isSuperNuke?SUPER_NUKE_SIZE_SCALE:1;
  meteor.trailWidthScale=meteor.sizeScale;
  meteor.age=0;
  meteor.head.position.copy(origin);
  meteor.head.scale.setScalar(meteor.sizeScale);
  meteor.head.material.opacity=0.92;
  meteor.tipMat.opacity=0.92;
  meteor.coreMat.opacity=0.78;
  meteor.glowMat.opacity=0.76;
  meteor.tip.scale.set(0.026*meteor.sizeScale,0.026*meteor.sizeScale,1);
  meteor.core.scale.set(0.082*meteor.sizeScale,0.082*meteor.sizeScale,1);
  meteor.glow.scale.set(0.32*meteor.sizeScale,0.32*meteor.sizeScale,1);
  meteor.glowMat.color.copy(imp.three);
  meteor.coreMat.color.copy(getMeteorCoreColor(imp.three));
  if(meteor.light){
    meteor.light.color.copy(imp.three);
    meteor.light.intensity=2.0;
    meteor.light.position.copy(origin);
  }
  resetMeteorTrail(meteor,origin);
  syncTrailRibbonColor(meteor,imp.three);
  updateTrailRibbon(meteor,origin.x,origin.y,origin.z,1.0,camera.position.x,camera.position.y,camera.position.z);
  activeMeteors.push(meteor);
}

function disposeMeteorVisuals(m){
  if(!m)return;
  scene.remove(m.head);
  if(m.light)scene.remove(m.light);
  if(m.trail)scene.remove(m.trail);
  if(m.head&&m.head.material)m.head.material.dispose();
  if(m.tipMat)m.tipMat.dispose();
  if(m.coreMat)m.coreMat.dispose();
  if(m.glowMat)m.glowMat.dispose();
  if(m.trailGeo)m.trailGeo.dispose();
  if(m.trailMat)m.trailMat.dispose();
}

const _impactWorldPt=new THREE.Vector3();
const METEOR_TRAIL_POINT_STEP=0.01;
const METEOR_TRAIL_MAX_INSERTS=12;

function updateMeteorVisuals(interp,frameDt){
  const a=Math.max(0,Math.min(1,interp));
  const camX=camera.position.x,camY=camera.position.y,camZ=camera.position.z;
  const camLen=Math.hypot(camX,camY,camZ)||1;
  const camNx=camX/camLen,camNy=camY/camLen,camNz=camZ/camLen;

  for(let i=0;i<activeMeteors.length;i++){
    const m=activeMeteors[i];
    const sizeScale=m.sizeScale||1;
    const tx=m.prevPos.x+(m.pos.x-m.prevPos.x)*a;
    const ty=m.prevPos.y+(m.pos.y-m.prevPos.y)*a;
    const tz=m.prevPos.z+(m.pos.z-m.prevPos.z)*a;
    m.renderPos.x=tx;
    m.renderPos.y=ty;
    m.renderPos.z=tz;
    const px=m.renderPos.x,py=m.renderPos.y,pz=m.renderPos.z;
    m.head.position.set(px,py,pz);
    if(m.light)m.light.position.set(px,py,pz);

    const r=Math.hypot(px,py,pz)||1;
    const facing=camNx*(px/r)+camNy*(py/r)+camNz*(pz/r); // +1=facing camera, -1=behind sphere
    const visFactor=facing>0?1.0:Math.max(0.08,0.3+facing*0.5); // behind: 8%-30%
    m.head.scale.setScalar(sizeScale);
    m.glow.scale.set(0.32*sizeScale,0.32*sizeScale,1);
    m.glowMat.opacity=0.78*visFactor;
    m.head.material.opacity=0.92*visFactor;
    m.tipMat.opacity=0.88*visFactor;
    m.tip.scale.set(0.026*sizeScale,0.026*sizeScale,1);
    if(m.core){
      m.core.scale.set(0.082*sizeScale,0.082*sizeScale,1);
      m.coreMat.opacity=0.74*visFactor;
    }
    updateTrailRibbon(m,px,py,pz,visFactor,camX,camY,camZ);
    if(m.light)m.light.intensity=2.0*visFactor;
  }
}

function updateMeteors(dt){
  const G=2.5; // gravitational constant
  const sDt=dt*meteorSpeed*3.0;

  for(let mi=activeMeteors.length-1;mi>=0;mi--){
    const m=activeMeteors[mi];
    const pos=m.pos,prevPos=m.prevPos,vel=m.vel;
    const motionScale=m.speedScale||1;
    const mDt=sDt*motionScale;
    m.age+=dt*motionScale;

    // Gravitational acceleration toward sphere center
    prevPos.copy(pos);
    const prevX=prevPos.x,prevY=prevPos.y,prevZ=prevPos.z;
    const rPrev=Math.hypot(prevX,prevY,prevZ);
    const rGrav=Math.max(0.1,rPrev);
    const invR=1/rGrav;
    const accScale=-G/(rGrav*rGrav);
    // Symplectic Euler: update velocity, then position
    vel.x+=prevX*invR*accScale*mDt;
    vel.y+=prevY*invR*accScale*mDt;
    vel.z+=prevZ*invR*accScale*mDt;
    pos.x+=vel.x*mDt;
    pos.y+=vel.y*mDt;
    pos.z+=vel.z*mDt;
    const r=Math.hypot(pos.x,pos.y,pos.z); // post-update distance for impact check

    // Densify trail samples to avoid dotted look at higher meteor speeds
    const dx=pos.x-prevX,dy=pos.y-prevY,dz=pos.z-prevZ;
    const travel=Math.hypot(dx,dy,dz);
    let inserts=Math.ceil(travel/METEOR_TRAIL_POINT_STEP);
    if(!Number.isFinite(inserts)||inserts<1)inserts=1;
    if(inserts>METEOR_TRAIL_MAX_INSERTS)inserts=METEOR_TRAIL_MAX_INSERTS;
    const shift=inserts*3;
    for(let ti=m.trailLen*3-1;ti>=shift;ti--)m.trailPositions[ti]=m.trailPositions[ti-shift];
    if(inserts===1){
      m.trailPositions[0]=pos.x;
      m.trailPositions[1]=pos.y;
      m.trailPositions[2]=pos.z;
    }else{
      for(let j=0;j<inserts;j++){
        const f=1-j/(inserts-1);
        const bi=j*3;
        m.trailPositions[bi]=prevX+dx*f;
        m.trailPositions[bi+1]=prevY+dy*f;
        m.trailPositions[bi+2]=prevZ+dz*f;
      }
    }
    // Impact: meteor reached sphere surface (or timeout safety)
    if(r<=1.005||m.age>15){
      // Interpolate to find exact surface crossing point
      let ipx,ipy,ipz;
      if(rPrev>1.0&&r<1.0&&rPrev!==r){
        const t=(rPrev-1.0)/(rPrev-r);
        ipx=prevX+(pos.x-prevX)*t;
        ipy=prevY+(pos.y-prevY)*t;
        ipz=prevZ+(pos.z-prevZ)*t;
      }else{
        ipx=pos.x;ipy=pos.y;ipz=pos.z;
      }
      const il=Math.hypot(ipx,ipy,ipz)||1;
      _impactWorldPt.set(ipx/il,ipy/il,ipz/il);
      const grid=surfaceToGrid(_impactWorldPt);
      if(m.isSuperNuke){
        const wipe=applySuperNukeRadialWipe(_impactWorldPt,SUPER_NUKE_KILL_FRACTION);
        addCrashLog('super-nuke-impact','warn',{
          killFraction:SUPER_NUKE_KILL_FRACTION,
          destroyed:wipe.destroyed,
          capAngleDeg:wipe.capAngleDeg
        });
      }else if(m.isNuke){
        applyNukeWipe(grid.x,grid.y,NUKE_WIPE_RADIUS);
      }else{
        // Keep Alive/Born color settings independent from Meteor toggle:
        // impact-seeded cells start "mature" so they use Alive color immediately.
        const placed=placeRandomOriented(m.patKey,grid.x,grid.y,undefined,4);
        if(placed)placed.forEach(([dx,dy])=>{
          const i=ix(grid.x+dx,grid.y+dy);
          meteorAge[i]=1.0;
          if(!meteorFlashMark[i]){meteorFlashMark[i]=1;meteorFlashIdx.push(i);}
        });
      }
      cntPop();pendingTexUpdate=true;updStats();
      const ringColor=m.specialKey?getMeteorColorData(m.specialKey).rgb:null;
      impactRings.push({cx:grid.x,cy:grid.y,t:0,color:ringColor,bornBeat:1});
      meteorStats[m.patKey]=(meteorStats[m.patKey]||0)+1;
      updMeteorStats();
      showImpactOverlay(m.patKey);
      // Cleanup
      releaseMeteorVisual(m);
      activeMeteors.splice(mi,1);
    }
  }
}

// ========================================
// IMPACT OVERLAY &mdash; multi-frame with per-slot fade
// ========================================
let impactSlots=[]; // each: {patKey,timer,num,el} or null
let impactNum=0;
let _rulesVisible=false, _rulesShowLock=0;
let _rulesOpacity=0; // current animated opacity
let _rulesLastUpdate=performance.now()*0.001;
const RULES_COLLISION_PAD=6;
const RULES_SHOW_LOCK_SEC=0.25;
const RULES_FADE_IN_PER_SEC=2.4;
const RULES_FADE_OUT_PER_SEC=5.5;

function setRulesVisible(nextVisible){
  if(_rulesVisible===nextVisible)return;
  _rulesVisible=nextVisible;
  // Anti-flicker: after every state change, delay next possible show.
  _rulesShowLock=RULES_SHOW_LOCK_SEC;
}

function tickRulesLock(){
  const now=performance.now()*0.001;
  const dt=Math.max(0,Math.min(0.25,now-_rulesLastUpdate));
  _rulesLastUpdate=now;
  if(_rulesShowLock>0)_rulesShowLock=Math.max(0,_rulesShowLock-dt);
  return dt;
}

function toRect(domRect){
  return{
    left:domRect.left,
    top:domRect.top,
    right:domRect.right,
    bottom:domRect.bottom,
    width:domRect.width,
    height:domRect.height
  };
}

function getLayoutRect(el){
  if(!el)return null;
  const cs=getComputedStyle(el);
  if(cs.display==='none')return null;
  const r=el.getBoundingClientRect();
  if(r.width<=0||r.height<=0)return null;
  return toRect(r);
}

function getVisibleRect(el){
  const r=getLayoutRect(el);
  if(!r)return null;
  const cs=getComputedStyle(el);
  if(cs.visibility==='hidden'||parseFloat(cs.opacity||'1')<=0.01)return null;
  return r;
}

function rectsOverlap(a,b,pad=0){
  return a.left<(b.right-pad)&&a.right>(b.left+pad)&&a.top<(b.bottom-pad)&&a.bottom>(b.top+pad);
}

function circleRectOverlap(cx,cy,radius,rect,pad=0){
  const left=rect.left-pad,right=rect.right+pad,top=rect.top-pad,bottom=rect.bottom+pad;
  const nearX=Math.max(left,Math.min(cx,right));
  const nearY=Math.max(top,Math.min(cy,bottom));
  const dx=nearX-cx,dy=nearY-cy;
  return dx*dx+dy*dy<=radius*radius;
}

// Precompute fixed canvas size from largest meteor pattern (all frames same size)
// Superclass patterns are excluded — they use symbol rendering, not cell-by-cell icons
let _impMaxW=0,_impMaxH=0;
METEOR_PATS.forEach(k=>{if(isSuperclassKey(k))return;const p=PAT[k];if(!p)return;let x0=Infinity,y0=Infinity,x1=-Infinity,y1=-Infinity;p.forEach(([x,y])=>{if(x<x0)x0=x;if(y<y0)y0=y;if(x>x1)x1=x;if(y>y1)y1=y});_impMaxW=Math.max(_impMaxW,x1-x0+1);_impMaxH=Math.max(_impMaxH,y1-y0+1)});
const IMP_CELL=6,IMP_PAD=2,IMP_CVS_W=(_impMaxW+IMP_PAD*2)*IMP_CELL,IMP_CVS_H=(_impMaxH+IMP_PAD*2)*IMP_CELL;
const IMPACT_BORN_BEAT_SEC=0.22;
const _w2sOrigin=new THREE.Vector3(0,0,0);
const _w2sX=new THREE.Vector3(1,0,0);
const _w2sTmp=new THREE.Vector3();

function worldToScreen(v){
  const p=_w2sTmp.copy(v).project(camera);
  return{
    x:(p.x*0.5+0.5)*innerWidth,
    y:(-p.y*0.5+0.5)*innerHeight
  };
}

function computeOverlayCapacity(){
  // Collision system: compute how many columns/rows of impact cards fit
  // in the space RIGHT of the sphere, without overlapping anything.
  const overlay=document.getElementById('impactOverlay');
  const topbar=document.getElementById('topbar');
  const foot=document.getElementById('foot');
  const margin=10, gridGap=8, gap=16;

  const topY=topbar?(topbar.getBoundingClientRect().bottom+8):60;
  const botY=foot&&foot.offsetParent!==null?(foot.getBoundingClientRect().top-8):(innerHeight-margin);

  // Measure one card size
  let cardW=120, cardH=120;
  if(overlay&&overlay.children.length>0){
    const sample=overlay.children[0];
    if(sample.offsetWidth>0)cardW=sample.offsetWidth;
    if(sample.offsetHeight>0)cardH=sample.offsetHeight;
  }

  // Compute where the sphere's right edge is on screen
  const sc=worldToScreen(_w2sOrigin);
  const se=worldToScreen(_w2sX);
  const sphereR=Math.max(80,Math.hypot(se.x-sc.x,se.y-sc.y));
  const sphereRightEdge=sc.x+sphereR;

  // Available width = from sphere right edge + gap to viewport right - margin
  const availW=Math.max(0,innerWidth-sphereRightEdge-gap-margin);
  const availH=Math.max(0,botY-topY);

  // Determine how many columns fit (4->3->2->1->0)
  let cols=4;
  while(cols>0){
    const neededW=cols*cardW+(cols-1)*gridGap;
    if(neededW<=availW)break;
    cols--;
  }

  // Max rows that fit vertically
  let maxRows=0;
  if(cols>0){
    maxRows=Math.max(0,Math.floor((availH+gridGap)/(cardH+gridGap)));
  }

  const maxSlots=cols*maxRows;

  return{topY,botY,cols,maxRows,maxSlots,cardW,cardH,gridGap};
}

function positionImpactOverlay(){
  const overlay=document.getElementById('impactOverlay');
  if(!overlay)return;
  const activeCount=impactSlots.filter(s=>s).length;
  const rules=document.getElementById('golRules');
  const cap=computeOverlayCapacity();

  // Rules: fixed bottom-right. Active DOM collision management.
  if(rules){
    const rulesRect=getLayoutRect(rules);
    const dtRules=tickRulesLock();
    let hasCollision=true;
    if(rulesRect){
      const sc=worldToScreen(_w2sOrigin);
      const se=worldToScreen(_w2sX);
      const sphereR=Math.max(80,Math.hypot(se.x-sc.x,se.y-sc.y));
      const sphereOverlap=circleRectOverlap(sc.x,sc.y,sphereR+8,rulesRect,RULES_COLLISION_PAD);

      const colliders=[
        getVisibleRect(document.getElementById('topbar')),
        getVisibleRect(document.getElementById('panel')),
        getVisibleRect(document.getElementById('foot')),
        getVisibleRect(document.getElementById('ctxMenu')),
        getVisibleRect(overlay),
      ].filter(Boolean);
      const uiOverlap=colliders.some(r=>rectsOverlap(rulesRect,r,RULES_COLLISION_PAD));
      hasCollision=sphereOverlap||uiOverlap;
    }

    if(hasCollision){
      setRulesVisible(false);
    }else if(_rulesShowLock<=0){
      setRulesVisible(true);
    }

    const fadeSpeed=_rulesVisible?RULES_FADE_IN_PER_SEC:RULES_FADE_OUT_PER_SEC;
    _rulesOpacity=_rulesVisible
      ?Math.min(1,_rulesOpacity+fadeSpeed*dtRules)
      :Math.max(0,_rulesOpacity-fadeSpeed*dtRules);
    rules.style.opacity=_rulesOpacity.toFixed(3);
    rules.style.visibility=_rulesOpacity<=0?'hidden':'visible';
  }

  if(!activeCount||!overlay.children.length){
    overlay.style.display='none';
    return;
  }

  // If no space at all, hide overlay and rapidly expire all slots
  if(cap.maxSlots<=0){
    overlay.style.display='none';
    // Quickly expire all active slots so they don't pile up
    for(let i=0;i<impactSlots.length;i++){
      if(impactSlots[i]&&impactSlots[i].timer>0.15)impactSlots[i].timer=0.15;
    }
    return;
  }

  // Accelerate fade on excess slots (oldest/shortest-lived first)
  if(activeCount>cap.maxSlots){
    const active=impactSlots.map((s,i)=>s?{s,i}:null).filter(Boolean)
      .sort((a,b)=>a.s.timer-b.s.timer);
    const excess=activeCount-cap.maxSlots;
    for(let i=0;i<excess&&i<active.length;i++){
      if(active[i].s.timer>0.2)active[i].s.timer=0.2;
    }
  }

  // Position: right-aligned, below topbar, never overlapping sphere
  overlay.style.gridTemplateColumns='repeat('+cap.cols+',auto)';
  overlay.style.left='auto';
  overlay.style.right='max(10px, env(safe-area-inset-right))';
  overlay.style.top=Math.round(cap.topY)+'px';
  overlay.style.display='grid';
}

function makeImpactCard(patKey,num,useBorn=false){
  const isSpecialNuke=isSpecialNukeKey(patKey);
  const isSuperclass=isSuperclassKey(patKey);
  const isSymbolIcon=isSpecialNuke||isSuperclass;
  const isSuperNuke=patKey===SUPER_NUKE_PAT_KEY;
  const imp=isSymbolIcon?getMeteorColorData(patKey):(useBorn?getBornColorData():getImpactColorData());
  const icR=imp.r,icG=imp.g,icB=imp.b;
  const colStr='rgb('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+')';
  const glowStr='rgba('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+',0.6)';
  const pat=PAT[patKey];
  if(!pat&&!isSpecialNuke)return null;
  const card=document.createElement('div');card.className='imp-card';
  const numEl=document.createElement('div');numEl.className='imp-num';numEl.textContent=''+num;numEl.style.color=colStr;
  card.appendChild(numEl);
  const cvs=document.createElement('canvas');cvs.width=IMP_CVS_W;cvs.height=IMP_CVS_H;
  const ctx=cvs.getContext('2d');
  if(isSymbolIcon){
    ctx.fillStyle='rgba('+Math.round(icR*0.35)+','+Math.round(icG*0.35)+','+Math.round(icB*0.35)+',0.5)';
    ctx.fillRect(2,2,IMP_CVS_W-4,IMP_CVS_H-4);
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.shadowColor='rgba('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+',0.85)';
    ctx.shadowBlur=18;
    ctx.font='700 '+Math.floor(IMP_CVS_H*0.62)+'px Segoe UI Symbol, Noto Sans Symbols, sans-serif';
    ctx.fillStyle='rgba('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+',0.98)';
    const sym=isSuperNuke?'\u2622':isSuperclass?'\u24C8':'\u2620';
    ctx.fillText(sym,Math.floor(IMP_CVS_W*0.5),Math.floor(IMP_CVS_H*0.56));
    ctx.shadowBlur=0;
  }else{
    let x0=Infinity,y0=Infinity,x1=-Infinity,y1=-Infinity;
    pat.forEach(([x,y])=>{if(x<x0)x0=x;if(y<y0)y0=y;if(x>x1)x1=x;if(y>y1)y1=y});
    const offX=Math.floor((IMP_CVS_W-(x1-x0+1)*IMP_CELL)/2),offY=Math.floor((IMP_CVS_H-(y1-y0+1)*IMP_CELL)/2);
    pat.forEach(([x,y])=>{
      const px=offX+(x-x0)*IMP_CELL,py=offY+(y-y0)*IMP_CELL;
      ctx.fillStyle='rgba('+Math.round(icR*0.4)+','+Math.round(icG*0.4)+','+Math.round(icB*0.4)+',0.5)';
      ctx.fillRect(px-1,py-1,IMP_CELL+2,IMP_CELL+2);
      ctx.fillStyle='rgba('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+',0.95)';
      ctx.fillRect(px+1,py+1,IMP_CELL-2,IMP_CELL-2);
    });
  }
  card.appendChild(cvs);
  const lbl=document.createElement('div');lbl.className='imp-label';
  const _brl=PAT_BRAILLE[patKey]||'';
  lbl.innerHTML=(PAT_NAMES[patKey]||patKey).toUpperCase()+(_brl?' <span class="imp-sym">'+_brl+'</span>':'');
  lbl.style.color=colStr;lbl.style.textShadow='0 0 10px '+glowStr;
  card.appendChild(lbl);
  card.style.borderColor='rgba('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+',0.35)';
  card.style.boxShadow='0 0 15px rgba('+Math.round(icR)+','+Math.round(icG)+','+Math.round(icB)+',0.15)';
  return card;
}

function syncOverlayChild(idx){
  // Sync one grid cell: show card or invisible placeholder
  const overlay=document.getElementById('impactOverlay');
  const s=impactSlots[idx];
  const child=overlay.children[idx];
  if(s){
    if(child)overlay.replaceChild(s.el,child); else overlay.appendChild(s.el);
  }else{
    const ph=document.createElement('div');ph.className='imp-card';ph.style.visibility='hidden';
    if(child)overlay.replaceChild(ph,child); else overlay.appendChild(ph);
  }
}

function trimOverlay(){
  // Remove trailing empty placeholders + hide overlay if nothing left
  const overlay=document.getElementById('impactOverlay');
  while(impactSlots.length>0&&!impactSlots[impactSlots.length-1]){
    impactSlots.pop();
    if(overlay.lastChild)overlay.removeChild(overlay.lastChild);
  }
  if(impactSlots.length>0){
    overlay.style.display='grid';
  }else{
    overlay.style.display='none';
  }
}

function showImpactOverlay(patKey,keepTimer=false){
  const overlay=document.getElementById('impactOverlay');
  if(keepTimer){
    // Recolor existing cards in-place (e.g. when impact color changes)
    for(let i=0;i<impactSlots.length;i++){
      const s=impactSlots[i];if(!s)continue;
      const newEl=makeImpactCard(s.patKey,s.num,s.bornBeat>0);
      if(newEl){newEl.style.opacity=s.el.style.opacity||'1';s.el=newEl;syncOverlayChild(i)}
    }
    return;
  }
  // Check if there's any space at all before creating a new card
  const cap=computeOverlayCapacity();
  if(cap.maxSlots<=0){
    // No space &mdash; don't create the card, just count the stat
    return;
  }
  impactNum++;
  let idx=impactSlots.findIndex(s=>!s);
  if(idx<0)idx=impactSlots.length;
  const bornBeat=IMPACT_BORN_BEAT_SEC;
  const el=makeImpactCard(patKey,impactNum,bornBeat>0);
  if(!el)return;
  // Adapt timer: shorter lifetime when space is tight
  const activeCount=impactSlots.filter(s=>s).length;
  const slotsLeft=cap.maxSlots-activeCount;
  const timer=slotsLeft>2?7.0:slotsLeft>0?4.0:2.0;
  impactSlots[idx]={patKey,timer:timer,num:impactNum,el,bornBeat};
  syncOverlayChild(idx);
  overlay.style.display='grid';
  positionImpactOverlay();
}

// ========================================
// METEOR STATS
// ========================================
function updMeteorStats(){
  const el=document.getElementById('mStats');
  const entries=Object.entries(meteorStats).sort((a,b)=>b[1]-a[1]);
  if(entries.length===0){el.innerHTML='';return}
  const total=entries.reduce((s,e)=>s+e[1],0);
  const pinnedKeys=[NUKE_PAT_KEY,SUPER_NUKE_PAT_KEY];
  const pinnedEntries=pinnedKeys.map(k=>entries.find(([kk])=>kk===k)).filter(Boolean);
  const otherEntries=entries.filter(([k])=>!pinnedKeys.includes(k));
  const displayEntries=[...pinnedEntries,...otherEntries.slice(0,Math.max(0,6-pinnedEntries.length))];
  const imp=getImpactColorData();
  const soft='rgba('+Math.round(imp.r)+','+Math.round(imp.g)+','+Math.round(imp.b)+',0.72)';
  el.innerHTML='<span style="color:'+soft+'" title="Total meteor impacts since last clear"><span class="ml">Impacts:</span> <span class="mc" style="color:'+imp.css+'">'+total+'</span></span> '+
    displayEntries.map(([k,v])=>{
      const isSuperNuke=k===SUPER_NUKE_PAT_KEY;
      const isNuke=k===NUKE_PAT_KEY;
      const kSoft=isSuperNuke
        ?'rgba('+SUPER_NUKE_COLOR_RGB[0]+','+SUPER_NUKE_COLOR_RGB[1]+','+SUPER_NUKE_COLOR_RGB[2]+',0.86)'
        :isNuke
          ?'rgba('+NUKE_COLOR_RGB[0]+','+NUKE_COLOR_RGB[1]+','+NUKE_COLOR_RGB[2]+',0.82)'
          :soft;
      const kColor=isSuperNuke?SUPER_NUKE_COLOR_CSS:isNuke?NUKE_COLOR_CSS:imp.css;
      return '<span style="color:'+kSoft+'" title="Number of '+((PAT_NAMES[k]||k))+' impacts delivered by meteor"><span class="ml">'+(PAT_BRAILLE[k]||'')+' '+(PAT_NAMES[k]||k)+':</span> <span class="mc" style="color:'+kColor+'">'+v+'</span></span>';
    }).join(' ');
}

// ========================================
// TEXTURE RENDERING
// ========================================


function updTex(){
  const c=getColors();
  const d=texImgData;
  d.fill(0);
  const gridOn=$('tGrid').checked;

  const aR=c.alive[0]*c.iAlive, aG=c.alive[1]*c.iAlive, aB=c.alive[2]*c.iAlive;
  const bR=c.born[0]*c.iBorn, bG=c.born[1]*c.iBorn, bB=c.born[2]*c.iBorn;
  const dR=c.dead[0]*c.iDead, dG=c.dead[1]*c.iDead, dB=c.dead[2]*c.iDead;
  const gR=c.dots[0]*c.iDots, gG=c.dots[1]*c.iDots, gB=c.dots[2]*c.iDots;
  // Block-paint with pole correction (reduced height near poles for square cells)
  for(let y=0;y<H;y++){
    const sinTh=rowSinTh[y], cosTh=rowCosTh[y];
    const cellH=poleCellH[y];
    const glossMask=getCellGlossMask(cellH);
    const glossHi=glossMask.hi, glossSh=glossMask.sh;
    const yOff=(TEX_SCALE-cellH)>>1;
    for(let x=0;x<W;x++){
      const i=y*W+x;
      const alive=grid[i];
      let cr,cg,cb;
      if(alive){
        if(age[i]===0){cr=bR;cg=bG;cb=bB}
        else{cr=aR;cg=aG;cb=aB}
        // Meteor impact flash: spawned impact cells start in Born tint, then fade to Alive.
        if(meteorAge[i]>0){
          const mf=Math.min(1,meteorAge[i]);
          const inv=1-mf;
          cr=cr*inv+bR*mf;
          cg=cg*inv+bG*mf;
          cb=cb*inv+bB*mf;
        }
        if(cellExposure!==0){
          let L=(cr+cg+cb)/3;
          if(L>0.5){
            let Ln=Math.max(0,L*Math.pow(2,cellExposure));
            Ln=Math.min(255,Ln);
            let s=Ln/L;
            const mx=Math.max(cr,cg,cb)*s;
            if(mx>255)s=255/Math.max(cr,cg,cb);
            cr=Math.max(0,cr*s);cg=Math.max(0,cg*s);cb=Math.max(0,cb*s);
          }
        }
        if(cellSaturation!==0){
          const L=0.299*cr+0.587*cg+0.114*cb;
          const f=1+cellSaturation;
          cr=Math.max(0,Math.min(255,L+(cr-L)*f));
          cg=Math.max(0,Math.min(255,L+(cg-L)*f));
          cb=Math.max(0,Math.min(255,L+(cb-L)*f));
        }
        // Hemisphere side-light: top-right side looks slightly milkier,
        // opposite side slightly darker. Independent from meteor system.
        const nx=-colCosPh[x]*sinTh, ny=cosTh, nz=colSinPh[x]*sinTh;
        const hemi=nx*hemiLightDir.x+ny*hemiLightDir.y+nz*hemiLightDir.z;
        if(USE_TEXTURE_HEMI&&hemi!==0&&dayNightStrength>0){
          const milk=hemi>0?hemi*HEMI_MILK_STRENGTH*dayNightStrength:0;
          const dark=hemi<0?-hemi*HEMI_DARK_STRENGTH*dayNightStrength:0;
          const keep=1-dark;
          cr=cr*keep+(255-cr)*milk;
          cg=cg*keep+(255-cg)*milk;
          cb=cb*keep+(255-cb)*milk;
        }
      } else {
        cr=dR;cg=dG;cb=dB;
      }
      const txL=x*TEX_SCALE;
      const tyT=y*TEX_SCALE+yOff;
      if(alive){
        const br=Math.min(255,cr+35),bgr=Math.min(255,cg+35),bbr=Math.min(255,cb+35);
        for(let py=0;py<cellH;py++){
          const rowOff=(tyT+py)*TW;
          const glossOff=py*TEX_SCALE;
          const borderY=(py===0||py===cellH-1);
          for(let px=0;px<TEX_SCALE;px++){
            const tp=(rowOff+((txL+px)%TW+TW)%TW)<<2;
            const border=borderY||(px===0||px===TEX_SCALE-1);
            let pr,pg,pb;
            if(border){pr=br;pg=bgr;pb=bbr}
            else{pr=cr;pg=cg;pb=cb}
            let sh=glossSh[glossOff+px], hi=glossHi[glossOff+px];
            if(border){sh*=0.72;hi*=0.70}
            pr*=1-sh;pg*=1-sh;pb*=1-sh;
            pr=pr+(255-pr)*hi;pg=pg+(255-pg)*hi;pb=pb+(255-pb)*hi;
            d[tp]=pr;d[tp+1]=pg;d[tp+2]=pb;
            d[tp+3]=255;
          }
        }
      } else {
        for(let py=0;py<cellH;py++){
          const rowOff=(tyT+py)*TW;
          for(let px=0;px<TEX_SCALE;px++){
            const tp=(rowOff+((txL+px)%TW+TW)%TW)<<2;
            d[tp]=cr;d[tp+1]=cg;d[tp+2]=cb;d[tp+3]=0;
          }
        }
      }
    }
  }
  tx.putImageData(texImg,0,0);

  // Cell glow aura: computed at base res, scaled up for composite
  if(cellGlow){
    const gd=glowImgData;
    for(let i=0;i<TOTAL;i++){
      const p=i*4;
      if(grid[i]){
        gd[p]=aR;gd[p+1]=aG;gd[p+2]=aB;
        gd[p+3]=255;
      }else{
        gd[p]=0;gd[p+1]=0;gd[p+2]=0;gd[p+3]=0;
      }
    }
    gsx.putImageData(glowImg,0,0);
    gdx.clearRect(0,0,W,H);
    const blurPx=Math.max(0.6,glowRadius*3.0);
    gdx.filter='blur('+blurPx+'px)';
    gdx.drawImage(glowSrc,0,0);
    gdx.filter='none';
    // Compensate blur energy loss: additive self-compositing restores brightness
    const boostPasses=Math.max(0,Math.ceil(blurPx/6)-1);
    if(boostPasses>0){
      gdx.globalCompositeOperation='lighter';
      for(let bp=0;bp<boostPasses;bp++)gdx.drawImage(glowDst,0,0);
      gdx.globalCompositeOperation='source-over';
    }
    tx.globalCompositeOperation='lighter';
    tx.globalAlpha=Math.min(1.0,glowIntensity*2.0);
    tx.drawImage(glowDst,0,0,TW,TH);
    tx.globalAlpha=1;
    tx.globalCompositeOperation='source-over';
  }

  // Impact shockwave rings (scaled to TWxTH texture)
  if(impactRings.length>0){
    const bornC=hex2rgb($('cBorn').value);
    const bornI=+$('iBorn').value/100;
    const impC=hex2rgb($('cImpact').value);
    const impI=+$('iImpact').value/100;
    const S=TEX_SCALE;
    for(const ring of impactRings){
      const firstBeat=(ring.bornBeat===1)||ring.t<0.12;
      const ringC=firstBeat?bornC:(ring.color||impC);
      const ringI=firstBeat?bornI:(ring.color?1.0:impI);
      const r=ring.t*40*S;
      const rcx=(ring.cx+0.5)*S, rcy=(ring.cy+0.5)*S;
      const opacity=Math.max(0,1-ring.t/1.5)*ringI;
      if(ring.t<0.6){
        const f=1-ring.t/0.6;
        const flashR=Math.max(3,ring.t*22)*S;
        tx.fillStyle='rgba(255,255,255,'+(f*f*ringI).toFixed(3)+')';
        for(const ox of[-TW,0,TW]){tx.beginPath();tx.arc(rcx+ox,rcy,flashR*0.4,0,Math.PI*2);tx.fill()}
        tx.fillStyle='rgba('+ringC[0]+','+ringC[1]+','+ringC[2]+','+(f*ringI*0.7).toFixed(3)+')';
        for(const ox of[-TW,0,TW]){tx.beginPath();tx.arc(rcx+ox,rcy,flashR,0,Math.PI*2);tx.fill()}
      }
      const w=Math.max(1,4.5-ring.t*2.5)*S;
      tx.strokeStyle='rgba('+Math.round(ringC[0]*opacity)+','+Math.round(ringC[1]*opacity)+','+Math.round(ringC[2]*opacity)+','+opacity.toFixed(3)+')';
      tx.lineWidth=w;
      for(const ox of[-TW,0,TW]){tx.beginPath();tx.arc(rcx+ox,rcy,r,0,Math.PI*2);tx.stroke()}
      if(ring.t>0.12){
        const r2=(ring.t-0.12)*34*S;
        const op2=Math.max(0,1-(ring.t-0.12)/1.3)*ringI*0.45;
        tx.strokeStyle='rgba('+Math.round(ringC[0]*op2)+','+Math.round(ringC[1]*op2)+','+Math.round(ringC[2]*op2)+','+op2.toFixed(3)+')';
        tx.lineWidth=Math.max(0.5,2.5-ring.t*1.5)*S;
        for(const ox of[-TW,0,TW]){tx.beginPath();tx.arc(rcx+ox,rcy,r2,0,Math.PI*2);tx.stroke()}
      }
      if(firstBeat)ring.bornBeat=0;
    }
  }

  // Cross markers at wireframe intersections (fade out from center + bright center dot)
  if(gridOn && c.iDots>0.01){
    const prevComp=tx.globalCompositeOperation;
    tx.globalCompositeOperation='destination-over';
    const armLen=Math.max(2,dotRadius*TEX_SCALE);
    const steps=Math.ceil(armLen);
    for(let iy=1;iy<_wSegsH;iy++){
      const v=iy/_wSegsH;
      const tyPx=v*TH;
      const th=v*Math.PI;
      const sinTh=Math.max(0.06,Math.sin(th));
      const stretchX=Math.max(1,Math.min(12,1/sinTh)*0.7);
      const cellY=Math.min(H-1,Math.round(v*H));
      for(let ix=0;ix<_wSegsW;ix++){
        const u=ix/_wSegsW;
        const txPx=u*TW;
        const cellX=Math.round(u*W)%W;
        if(!grid[cellY*W+cellX]){
          // Cross arms (solid, fade only at tips)
          const fadePx=Math.min(3,steps);
          for(let s=1;s<=steps;s++){
            const tip=steps-s;
            const a=tip<fadePx?((tip+1)/fadePx*0.7).toFixed(3):'0.700';
            tx.fillStyle='rgba('+Math.round(gR)+','+Math.round(gG)+','+Math.round(gB)+','+a+')';
            const dx=s*stretchX, dy=s;
            tx.fillRect(txPx+dx-0.5,tyPx-0.5,1,1);
            tx.fillRect(txPx-dx-0.5,tyPx-0.5,1,1);
            tx.fillRect(txPx-0.5,tyPx+dy-0.5,1,1);
            tx.fillRect(txPx-0.5,tyPx-dy-0.5,1,1);
          }
          // Bright center dot
          tx.fillStyle='rgba(255,255,255,0.85)';
          tx.beginPath();
          tx.arc(txPx,tyPx,Math.max(0.8,armLen*0.15),0,Math.PI*2);
          tx.fill();
        }
      }
    }
    tx.globalCompositeOperation=prevComp;
  }

  lifeTex.needsUpdate=true;
  lastTexUpdate=performance.now();
}

// ========================================
// UI WIRING
// ========================================
function $(id){return document.getElementById(id)}
function updPlayBtn(){const b=$('bPlay');b.innerHTML=running?'&#9208; Pause':'&#9654; Play';b.classList.toggle('on',running)}
const METEOR_INTERVAL_MIN=2;
const METEOR_INTERVAL_MAX=15;
function meteorIntervalFromSlider(raw){
  const v=Math.round(raw);
  return METEOR_INTERVAL_MIN+METEOR_INTERVAL_MAX-clamp(v,METEOR_INTERVAL_MIN,METEOR_INTERVAL_MAX);
}
function meteorIntervalToSlider(intervalVal){
  const v=Math.round(intervalVal);
  return METEOR_INTERVAL_MIN+METEOR_INTERVAL_MAX-clamp(v,METEOR_INTERVAL_MIN,METEOR_INTERVAL_MAX);
}
function fmtNum(n){
  if(n<1e6)return n.toLocaleString();
  if(n<1e9)return(n/1e6).toFixed(2)+'M';
  if(n<1e12)return(n/1e9).toFixed(2)+'B';
  return(n/1e12).toFixed(2)+'T';
}
function updStats(){$('sGen').textContent=fmtNum(gen);$('sPop').textContent=fmtNum(pop);$('sPct').textContent=((pop/TOTAL)*100).toFixed(1)+'%'}

$('bPlay').onclick=()=>{running=!running;updPlayBtn();save()};
$('bStep').onclick=()=>{step();updTex();updStats()};
$('bClear').onclick=()=>{clear();meteorStats={};updMeteorStats();updTex();updStats();save()};
$('bApply').onclick=()=>{applyPat();save()};
$('bRand').onclick=()=>{randomize();save()};
$('bExpCrashLog').onclick=()=>{exportCrashLog()};
$('bClrCrashLog').onclick=()=>{
  if(confirm('Delete stored crash diagnostics?'))clearCrashLog();
};

$('bWipe').onclick=()=>{wipeMode=!wipeMode;$('bWipe').classList.toggle('on',wipeMode);renderer.domElement.style.cursor=wipeMode?wipeCursor:'';save()};
$('rWipeR').oninput=e=>{wipeRadius=+e.target.value;$('vWipeR').textContent=e.target.value;save()};
$('rSpd').oninput=e=>{speed=+e.target.value;$('vSpd').textContent=speed+' gen/s';save()};
$('tMeteor').onchange=e=>{meteorMode=e.target.checked;meteorTimer=0;scheduleNextMeteor();save()};
$('rMInt').oninput=e=>{
  meteorInterval=meteorIntervalFromSlider(+e.target.value);
  $('vMInt').textContent=meteorInterval+'s';
  scheduleNextMeteor();
  save();
};
$('rMSpd').oninput=e=>{meteorSpeed=+e.target.value/100;$('vMSpd').textContent=meteorSpeed.toFixed(1);save()};
$('rScat').oninput=e=>{$('vScat').textContent=e.target.value;save()};
$('rZoom').oninput=e=>{zoom=+e.target.value/10;$('vZoom').textContent=zoom.toFixed(1);save()};
$('tRot').onchange=e=>{autoRot=e.target.checked;save()};
$('rRSpd').oninput=e=>{rotSpd=+e.target.value/10;$('vRSpd').textContent=rotSpd.toFixed(1);save()};
$('rGlow').oninput=e=>{const v=+e.target.value/100;sphMat.emissiveIntensity=v;$('vGlow').textContent=v.toFixed(1);save()};
// Grid Dots toggle: always NearestFilter, just controls dot visibility
$('tGrid').onchange=e=>{updTex();save()};
$('tWire').onchange=e=>{wire.visible=e.target.checked;save()};
$('rWireExp').oninput=e=>{const v=+e.target.value/100;wireShaderMat.uniforms.wOpacity.value=v;$('vWireExp').textContent=e.target.value;save()};
// Dot size
$('rDotR').oninput=e=>{dotRadius=+e.target.value/10;$('vDotR').textContent=dotRadius.toFixed(1);updTex();save()};
// Cell glow controls
$('rExposure').oninput=e=>{cellExposure=+e.target.value/6.25;$('vExposure').textContent=e.target.value>0?'+'+e.target.value:e.target.value;updTex();save()};
$('rSaturation').oninput=e=>{cellSaturation=+e.target.value/100;$('vSaturation').textContent=e.target.value>0?'+'+e.target.value:e.target.value;updTex();save()};
$('rDayNight').oninput=e=>{dayNightStrength=+e.target.value/100;$('vDayNight').textContent=Math.round((+e.target.value)/2)+'%';syncDayNightUniform();updTex();save()};
$('tCGlow').onchange=e=>{cellGlow=e.target.checked;updTex();save()};
$('rCGR').oninput=e=>{glowRadius=+e.target.value;$('vCGR').textContent=e.target.value;updTex();save()};
$('rCGI').oninput=e=>{glowIntensity=+e.target.value/100;$('vCGI').textContent=glowIntensity.toFixed(1);updTex();save()};


// Theme preset dropdown
$('selTheme').onchange=e=>{applyPreset(e.target.value)};

// Color pickers & intensity sliders -> live update
['Alive','Born','Dead','Dots','Impact'].forEach(name=>{
  const cEl=$('c'+name), iEl=$('i'+name), ivEl=$('iv'+name);
  const handler=()=>{
    ivEl.textContent=iEl.value+'%';
    if(name==='Impact'){
      syncActiveMeteorColors();
      updMeteorStats();
      if(impactSlots.some(s=>s))showImpactOverlay(null,true);
    }
    updTex();
    save();
  };
  cEl.addEventListener('input',handler);
  iEl.addEventListener('input',handler);
});

// ========================================
// LOCAL STORAGE
// ========================================
function save(){
  try{localStorage.setItem('cl-gol2',JSON.stringify({
    speed,zoom,autoRot,rotSpd,meteorMode,meteorInterval,
    grid:$('tGrid').checked,wireframe:$('tWire').checked,wireExp:wireShaderMat.uniforms.wOpacity.value,
    glow:sphMat.emissiveIntensity,
    pat:$('selPat').value,scat:$('rScat').value,
    thm:$('selTheme').value,
    cAlive:$('cAlive').value,cBorn:$('cBorn').value,
    cDead:$('cDead').value,cDots:$('cDots').value,cImpact:$('cImpact').value,
    iAlive:$('iAlive').value,iBorn:$('iBorn').value,
    iDead:$('iDead').value,iDots:$('iDots').value,iImpact:$('iImpact').value,
    dotRadius,cellGlow,glowRadius,glowIntensity,cellExposure,cellSaturation,dayNightStrength,wipeRadius,meteorSpeed,
  }))}catch(e){}
}

function load(){
  try{
    const r=localStorage.getItem('cl-gol2');if(!r)return;
    const s=JSON.parse(r);
    if(s.speed){speed=s.speed;$('rSpd').value=speed;$('vSpd').textContent=speed+' gen/s'}
    if(s.zoom){zoom=s.zoom;$('rZoom').value=zoom*10;$('vZoom').textContent=zoom.toFixed(1)}
    if(s.autoRot!==undefined){autoRot=s.autoRot;$('tRot').checked=autoRot}
    if(s.rotSpd){rotSpd=s.rotSpd;$('rRSpd').value=rotSpd*10;$('vRSpd').textContent=rotSpd.toFixed(1)}
    if(s.meteorMode!==undefined){meteorMode=s.meteorMode;$('tMeteor').checked=meteorMode}
    if(s.meteorInterval!==undefined){
      meteorInterval=clamp(s.meteorInterval,METEOR_INTERVAL_MIN,METEOR_INTERVAL_MAX);
      $('rMInt').value=meteorIntervalToSlider(meteorInterval);
      $('vMInt').textContent=meteorInterval+'s';
    }
    if(s.grid!==undefined){$('tGrid').checked=s.grid}
    if(s.wireframe!==undefined){$('tWire').checked=s.wireframe;wire.visible=s.wireframe}
    if(s.wireExp!==undefined){wireShaderMat.uniforms.wOpacity.value=s.wireExp;$('rWireExp').value=s.wireExp*100;$('vWireExp').textContent=Math.round(s.wireExp*100)}
    if(s.glow!==undefined){sphMat.emissiveIntensity=s.glow;$('rGlow').value=s.glow*100;$('vGlow').textContent=s.glow.toFixed(1)}
    if(s.pat)$('selPat').value=s.pat;
    if(s.scat){$('rScat').value=s.scat;$('vScat').textContent=s.scat}
    if(s.thm)$('selTheme').value=s.thm;
    if(s.cAlive)$('cAlive').value=s.cAlive;
    if(s.cBorn)$('cBorn').value=s.cBorn;
    if(s.cDead)$('cDead').value=s.cDead;
    if(s.cDots)$('cDots').value=s.cDots;
    if(s.cImpact)$('cImpact').value=s.cImpact;
    if(s.iAlive){$('iAlive').value=s.iAlive;$('ivAlive').textContent=s.iAlive+'%'}
    if(s.iBorn){$('iBorn').value=s.iBorn;$('ivBorn').textContent=s.iBorn+'%'}
    if(s.iDead){$('iDead').value=s.iDead;$('ivDead').textContent=s.iDead+'%'}
    if(s.iDots){$('iDots').value=s.iDots;$('ivDots').textContent=s.iDots+'%'}
    if(s.iImpact){$('iImpact').value=s.iImpact;$('ivImpact').textContent=s.iImpact+'%'}
    // New settings
    if(s.dotRadius!==undefined){dotRadius=s.dotRadius;$('rDotR').value=dotRadius*10;$('vDotR').textContent=dotRadius.toFixed(1)}
    if(s.cellGlow!==undefined){cellGlow=s.cellGlow;$('tCGlow').checked=cellGlow}
    if(s.glowRadius!==undefined){glowRadius=s.glowRadius;$('rCGR').value=glowRadius;$('vCGR').textContent=glowRadius}
    if(s.glowIntensity!==undefined){glowIntensity=s.glowIntensity;$('rCGI').value=glowIntensity*100;$('vCGI').textContent=glowIntensity.toFixed(1)}

    if(s.cellExposure!==undefined){cellExposure=s.cellExposure;$('rExposure').value=cellExposure*6.25;const ev=Math.round(cellExposure*6.25);$('vExposure').textContent=ev>0?'+'+ev:''+ev}
    if(s.cellSaturation!==undefined){cellSaturation=s.cellSaturation;$('rSaturation').value=cellSaturation*100;const cv=Math.round(cellSaturation*100);$('vSaturation').textContent=cv>0?'+'+cv:''+cv}
    if(s.dayNightStrength!==undefined){dayNightStrength=s.dayNightStrength;$('rDayNight').value=Math.round(dayNightStrength*100);$('vDayNight').textContent=Math.round(dayNightStrength*50)+'%';syncDayNightUniform()}
    if(s.wipeRadius!==undefined){wipeRadius=s.wipeRadius;$('rWipeR').value=wipeRadius;$('vWipeR').textContent=wipeRadius}
    if(s.meteorSpeed!==undefined){meteorSpeed=s.meteorSpeed;$('rMSpd').value=meteorSpeed*100;$('vMSpd').textContent=meteorSpeed.toFixed(1)}
    scheduleNextMeteor();
  }catch(e){}
}

// ========================================
// MAIN LOOP
// ========================================
let lastFrame=0;
let lastRender=0;
let lastTexUpdate=0;
let meteorAccum=0;
function animate(t){
  if(disposed)return;
  rafId=requestAnimationFrame(animate);
  if(!pageVisible||glContextLost||t<resumeAfterRestoreAt){lastFrame=t;return}
  const dtRaw=(t-lastFrame)/1000||.016;
  const dt=Math.min(0.1,dtRaw); // clamp long stalls to avoid visible jumps
  lastFrame=t;

  if(running&&t-lastTick>=1000/speed){step();pendingTexUpdate=true;updStats();lastTick=t}

  // Meteor rain (randomized interval)
  if(meteorMode){
    meteorTimer+=dt;
    if(meteorTimer>=nextMeteorTime){meteorTimer=0;scheduleNextMeteor();spawnMeteor()}
  }
  if(activeMeteors.length>0){
    meteorAccum=Math.min(0.25,meteorAccum+dt);
    while(meteorAccum>=METEOR_UPDATE_INTERVAL){
      updateMeteors(METEOR_UPDATE_INTERVAL);
      meteorAccum-=METEOR_UPDATE_INTERVAL;
    }
  }else{
    meteorAccum=0;
  }

  // Advance and cull impact shockwave rings
  let hasRings=false;
  for(let ri=impactRings.length-1;ri>=0;ri--){
    impactRings[ri].t+=dt;
    if(impactRings[ri].t>1.6)impactRings.splice(ri,1);
    else hasRings=true;
  }
  if(hasRings)pendingTexUpdate=true;

  // Impact overlay per-slot fade (1s fade-out)
  {let _impTrim=false;
  for(let i=0;i<impactSlots.length;i++){
    const s=impactSlots[i];if(!s)continue;
    s.timer-=dt;
    if(s.bornBeat>0){
      s.bornBeat=Math.max(0,s.bornBeat-dt);
      if(s.bornBeat<=0){
        const newEl=makeImpactCard(s.patKey,s.num,false);
        if(newEl){
          newEl.style.opacity=s.el.style.opacity||'1';
          s.el=newEl;
          syncOverlayChild(i);
        }
      }
    }
    if(s.timer<=0){
      impactSlots[i]=null;
      syncOverlayChild(i);
      _impTrim=true;
    }else if(s.timer<=1.0){
      s.el.style.opacity=Math.max(0,s.timer/1.0).toString();
    }
  }
  if(_impTrim)trimOverlay();
  if(t-lastOverlayLayout>=OVERLAY_LAYOUT_INTERVAL){
    positionImpactOverlay();
    lastOverlayLayout=t;
  }}

  if(autoRot&&!dragging){
    axisTimer+=dt;
    if(axisTimer>2+Math.random()*6){rotTarget.set((Math.random()-.5)*2,(Math.random()-.5)*2,(Math.random()-.5)*2).normalize();axisTimer=0}
    rotAxis.lerp(rotTarget,.008).normalize();
    rotQ.premultiply(new THREE.Quaternion().setFromAxisAngle(rotAxis,rotSpd*dt*.4));
  }

  sph.quaternion.copy(rotQ);sphBack.quaternion.copy(rotQ);wire.quaternion.copy(rotQ);
  camera.position.z+=(zoom-camera.position.z)*.1;

  // Only render to GPU at capped framerate with stable pacing
  const renderInterval=(activeMeteors.length>0)?renderIntervalMeteor:renderIntervalIdle;
  const renderElapsed=t-lastRender;
  if(renderElapsed>=renderInterval){
    lastRender=t-(renderElapsed%renderInterval);
    updateCameraCenter();
    if(activeMeteors.length>0){
      updateMeteorVisuals(meteorAccum/METEOR_UPDATE_INTERVAL,dt);
    }
    if(pendingTexUpdate&&t-lastTexUpdate>=texUpdateInterval){
      updTex();
      pendingTexUpdate=false;
    }
    renderer.render(scene,camera);
  }
}

function refreshLayoutNow(){
  if(disposed)return;
  updateCameraCenter();
  positionImpactOverlay();
}

window.addEventListener('resize',()=>{
  if(disposed)return;
  applyRendererResolution();
  refreshLayoutNow();
});

let visualViewportHandler=null;
if(window.visualViewport){
  visualViewportHandler=()=>{refreshLayoutNow()};
  window.visualViewport.addEventListener('resize',visualViewportHandler,{passive:true});
  window.visualViewport.addEventListener('scroll',visualViewportHandler,{passive:true});
}

let layoutResizeObserver=null;
if('ResizeObserver' in window){
  layoutResizeObserver=new ResizeObserver(()=>{refreshLayoutNow()});
  ['topbar','panel','foot','golRules','impactOverlay'].forEach(id=>{
    const el=document.getElementById(id);
    if(el)layoutResizeObserver.observe(el);
  });
}

document.addEventListener('visibilitychange',()=>{
  pageVisible=!document.hidden;
  addCrashLog('visibility-change','info',{hidden:document.hidden});
  if(pageVisible){
    lastFrame=performance.now();
    lastRender=0;
    lastOverlayLayout=0;
    refreshLayoutNow();
  }
});

window.addEventListener('error',e=>{
  addCrashLog('window-error','error',{
    message:e.message||'',
    source:e.filename||'',
    line:e.lineno||0,
    column:e.colno||0
  });
});

window.addEventListener('unhandledrejection',e=>{
  let reason='';
  try{reason=String(e&&e.reason&&e.reason.stack?e.reason.stack:e.reason)}catch(err){reason='[unserializable rejection]'}
  addCrashLog('unhandled-rejection','error',{reason});
});

function disposeScene(){
  if(disposed)return;
  addCrashLog('dispose-scene','warn');
  disposed=true;
  running=false;
  if(contextRecoveryTimer){clearTimeout(contextRecoveryTimer);contextRecoveryTimer=0;}
  hideGpuRecoveryNotice();
  if(rafId)cancelAnimationFrame(rafId);

  for(let i=activeMeteors.length-1;i>=0;i--){
    disposeMeteorVisuals(activeMeteors[i]);
  }
  activeMeteors.length=0;
  for(let i=meteorPool.length-1;i>=0;i--){
    disposeMeteorVisuals(meteorPool[i]);
  }
  meteorPool.length=0;
  impactRings.length=0;
  impactSlots.length=0;
  meteorFlashIdx.length=0;
  meteorFlashMark.fill(0);
  if(window.visualViewport&&visualViewportHandler){
    window.visualViewport.removeEventListener('resize',visualViewportHandler);
    window.visualViewport.removeEventListener('scroll',visualViewportHandler);
    visualViewportHandler=null;
  }
  if(layoutResizeObserver){
    layoutResizeObserver.disconnect();
    layoutResizeObserver=null;
  }

  meteorHeadGeo.dispose();
  meteorGlowTex.dispose();
  lifeTex.dispose();
  sphGeo.dispose();
  sphMat.dispose();
  sphBackMat.dispose();
  _wGeo.dispose();
  wireShaderMat.dispose();
  stGeo.dispose();
  stMat.dispose();

  renderer.dispose();
}

window.addEventListener('pagehide',e=>{
  addCrashLog('pagehide','info',{persisted:!!(e&&e.persisted)});
  // Don't tear down on BFCache pagehide; this page can resume.
  if(e&&e.persisted)return;
  disposeScene();
},{once:true});
window.addEventListener('beforeunload',()=>{
  addCrashLog('beforeunload','info');
  disposeScene();
},{once:true});

// ========================================
// INIT
// ========================================
loadCrashLog();
addCrashLog('logger-initialized','info',{existingEntries:crashLogEntries.length});
load();
initPatternSymbols();
scheduleNextMeteor();
randomize();
updStats();
logRendererDebugInfo();
addCrashLog('app-init-complete','info');
animate(0);



</script>
</body>
</html>
